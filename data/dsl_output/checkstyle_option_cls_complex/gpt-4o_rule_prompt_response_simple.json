{
    "PackageDeclaration": [
        "Analyze the following CheckStyle Rule and DSL representation parsed using given grammar, please delete unexisted OptionName. \n\n1. Analyze whether each sentence of descriptions of CheckStyle Rule is a rule or not. If it is a rule, parsing it as a rule using the given Grammar. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. \n2. For each option that is not data specification, for each value, please parse it as a rule using giving Grammar. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.\n3. For each option that is data specification, please provide the option type, value range, default value. \n4. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nPackageDeclaration\nDescription\n\nEnsures that a class has a package declaration, and (optionally) whether\nthe package name matches the directory name for the source file.\n\n\nRationale: Classes that live in the null package cannot be\nimported. Many novice developers are not aware of this.\n\n\nPackages provide logical namespace to classes and should be stored in\nthe form of directory levels to provide physical grouping to your classes.\nThese directories are added to the classpath so that your classes\nare visible to JVM when it runs the code.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nmatchDirectoryStructure\nControl whether to check for directory and package name match.\nboolean\ntrue\n7.6.1\n\nAnswer about Options are data specifications or not\nNone\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, respond like: \nFinal RuleSet Representation:\nBasic Rule:\nMandatory: Order of [import groups] is {{customImportOrderRules}}\nAnd\nMandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]\n\nOption Rule:\nseparateLineBetweenGroups option:\ntrue: Mandatory: [empty line] between [import groups]\nfalse: Optional: [empty line] not between [import groups]\n\nsortImportsInGroupAlphabetically option:\ntrue: Mandatory: Order of [imports] of [import group] is [ASCII sort order]\nfalse: Optional: Order of [imports] of [import group] is not [ASCII sort order]\n\nOptions that are data specifications:\n{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};\n{{thirdPartyPackageRegExp}}: Pattern; RegExp; \u201c.*\u201d;\n\nFinal RuleSet Representation:\n[block] of {{tokens}} have [Brace]\n\nOption Rule:\nallowEmptyLoopBody option:\nfalse: Mandatory: [body] of [loop statement] is not [Null]\ntrue: Optional: [body] of [loop statement] is [Null]\n\nallowSingleLineStatement option:\nfalse: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 \u2014> [body] of {{tokens}} have [Brace]\ntrue: Optional: Number of [statement] of [body] of [{{tokens}} is 1 \u2014> [body] of {{tokens}} not have [Brace]\n\nOptions that are data specifications:\ntokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};\n\n\nResponse Format:\nIf there is no option, you only give basic rule\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOtherwise,\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOption Rule:\n...\n\nOptions that are data specifications:\n...\n",
        "Final RuleSet Representation:\nBasic Rule:\nMandatory: Order of [PackageDeclaration] is [PackageDeclaration]\nAnd\nOptional: [PackageDeclaration] match [DirectoryStructure]\n\nOptions that are data specifications:\nNone"
    ]
}