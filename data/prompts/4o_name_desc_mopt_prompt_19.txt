Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.4 Column limit: 100
Java code has a column limit of 100 characters. A "character" means any Unicode code point. Except as noted below, any line that would exceed this limit must be line-wrapped, as explained in Section 4.5, Line-wrapping .
 Each Unicode code point counts as one character, even if its display width is greater or less. For example, if using fullwidth characters , you may choose to wrap the line earlier than where this rule strictly requires.
 Exceptions:
 Lines where obeying the column limit is not possible (for example, a long URL in Javadoc, or a long JSNI method reference). 
 `package` and `import` statements (see Sections 3.2 Package statement and 3.3 Import statements ). 
 Command lines in a comment that may be copied-and-pasted into a shell. 
 Very long identifiers, on the rare occasions they are called for, are allowed to exceed the column limit. In that case, the valid wrapping for the surrounding code is as produced by google-java-format .

CheckStyle Rules:
[Rule]
Indentation
[Description]
Checks correct indentation of Java code.


The idea behind this is that while pretty printers are
sometimes convenient for bulk reformats of legacy code, they often
either aren't configurable enough or just can't anticipate how
format should be done. Sometimes this is personal preference, other
times it is practical experience. In any case, this check should
just ensure that a minimal set of indentation rules is followed.


Basic offset indentation is used for indentation inside code blocks.
For any lines that span more than 1, line wrapping indentation is used for those
lines after the first.
Brace adjustment, case, and throws indentations are all used only if those specific
identifiers start the line. If, for example, a brace is used in the middle of the line,
its indentation will not take effect.
All indentations have an accumulative/recursive effect when they are triggered. If
during a line wrapping, another code block is found and it doesn't end on that same
line, then the subsequent lines afterwards, in that new code block, are increased on
top of the line wrap and any indentations above it.

Example:


if ((condition1 && condition2)
|| (condition3 && condition4)    // line wrap with bigger indentation
||!(condition5 && condition6)) { // line wrap with bigger indentation
field.doSomething()                    // basic offset
.doSomething()                     // line wrap
.doSomething( c -> {               // line wrap
return c.doSome();               // basic offset
});
}
[Options]
arrayInitIndent, Specify how far an array initialization should be indented when on next line.
basicOffset, Specify how far new indentation level should be indented when on the next line.
braceAdjustment, Specify how far a braces should be indented when on the next line.
caseIndent, Specify how far a case label should be indented when on next line.
forceStrictCondition, Force strict indent level in line wrapping case. If value is true, line wrap indent have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like.
lineWrappingIndentation, Specify how far continuation line should be indented when line-wrapping is present.
throwsIndent, Specify how far a throws clause should be indented when on next line.
[Rule]
TrailingComment
[Description]
The check to ensure that lines with code do not end with comment.
For the case of // comments that means that the only thing
that should precede it is whitespace. It doesn't check comments if
they do not end a line; for example, it accepts the following:
Thread.sleep( 10 /*some comment here*/ ); Format
property is intended to deal with the } // while example.


Rationale: Steve McConnell in Code Complete suggests that
endline comments are a bad practice. An end line comment would be
one that is on the same line as actual code. For example:



a = b + c;      // Some insightful comment
d = e / f;        // Another comment for this line


Quoting Code Complete for the justification:


"The comments have to be aligned so that they do not
interfere with the visual structure of the code. If you don't align
them neatly, they'll make your listing look like it's been through a
washing machine."

"Endline comments tend to be hard to format...It takes
time to align them. Such time is not spent learning more about the
code; it's dedicated solely to the tedious task of pressing the
spacebar or tab key."

"Endline comments are also hard to maintain. If the code
on any line containing an endline comment grows, it bumps the
comment farther out, and all the other endline comments will have to
bumped out to match. Styles that are hard to maintain aren't
maintained...."

"Endline comments also tend to be cryptic. The right side
of the line doesn't offer much room and the desire to keep the
comment on one line means the comment must be short. Work then goes
into making the line as short as possible instead of as clear as
possible. The comment usually ends up as cryptic as
possible...."

"A systemic problem with endline comments is that it's
hard to write a meaningful comment for one line of code. Most
endline comments just repeat the line of code, which hurts more than
it helps."



McConnell's comments on being hard to maintain when the size of the line
changes are even more important in the age of automated
refactorings.
[Options]
format, Specify pattern for strings allowed before the comment.
legalComment, Define pattern for text allowed in trailing comments. This pattern will not be applied to multiline comments.
[Rule]
LineLength
[Description]
Checks for long lines.


Rationale: Long lines are hard to read in printouts or if developers
have limited screen space for the source code, e.g. if the IDE
displays additional information like project tree, class hierarchy,
etc.
[Options]
fileExtensions, Specify the file extensions of the files to process.
ignorePattern, Specify pattern for lines to ignore.
max, Specify the maximum line length allowed.
[Rule]
RegexpSinglelineJava
[Description]
Checks that a specified pattern matches a single-line in Java files.


This class is variation on
RegexpSingleline for detecting
single-lines that match a supplied regular expression in Java files. It supports
suppressing matches in Java comments.
[Options]
format, Specify the format of the regular expression to match.
ignoreCase, Control whether to ignore case when searching.
ignoreComments, Control whether to ignore text in comments when searching.
maximum, Specify the maximum number of matches required in each file.
message, Specify the message which is used to notify about violations, if empty then default (hard-coded) message is used.
minimum, Specify the minimum number of matches required in each file.
[Rule]
FileTabCharacter
[Description]
Checks that there are no tab characters ('\t') in the source code.


Rationale:



Developers should not need to configure the tab width of their
text editors in order to be able to read source code.


From the Apache jakarta coding standards: In a distributed
development environment, when the commit messages get sent
to a mailing list, they are almost impossible to read if you
use tabs.
[Options]
eachLine, Control whether to report on each line containing a tab, or just the first instance.
fileExtensions, Specify the file extensions of the files to process.
[Rule]
SingleSpaceSeparator
[Description]
Checks that non-whitespace characters are separated by no more than one
whitespace. Separating characters by tabs or multiple spaces will be
reported. Currently, the check doesn't permit horizontal alignment. To inspect
whitespaces before and after comments, set the property
validateComments to true.


Setting validateComments to false will ignore cases like:



int i;  // Multiple whitespaces before comment tokens will be ignored.
private void foo(int  /* whitespaces before and after block-comments will be
ignored */  i) {


Sometimes, users like to space similar items on different lines to the same
column position for easier reading. This feature isn't supported by this
check, so both braces in the following case will be reported as violations.



public long toNanos(long d)  { return d;             } // 2 violations
public long toMicros(long d) { return d / (C1 / C0); }
[Options]
validateComments, Control whether to validate whitespaces surrounding comments.
[Rule]
JavadocContentLocation
[Description]
Checks that the Javadoc content begins from the same position
for all Javadoc comments in the project. Any leading asterisks and spaces
are not counted as the beginning of the content and are therefore ignored.


It is possible to enforce two different styles:



{@code first_line} - Javadoc content starts from the first line:



/** Summary text.
* More details.
*/
public void method();



{@code second_line} - Javadoc content starts from the second line:



/**
* Summary text.
* More details.
*/
public void method();
[Options]
location, Specify the policy on placement of the Javadoc content.
[Rule]
UnusedImports
[Description]
Checks for unused import statements. An
import statement is considered unused if:



It is not referenced in the file. The algorithm does not support
wild-card imports like import
java.io.*;. Most IDE's provide very sophisticated checks
for imports that handle wild-card imports.


The class imported is from the java.lang
package. For example importing java.lang.String.


The class imported is from the same package.


A static method is imported when used as method reference. In that case,
only the type needs to be imported and that's enough to resolve the method.


Optionally: it is referenced in Javadoc comments. This check
is on by default, but it is considered bad practice to introduce
a compile-time dependency for documentation purposes only.
As an example, the import java.util.List would be
considered referenced with the Javadoc comment
{@link List}. The alternative to avoid introducing a
compile-time dependency would be to write the Javadoc comment as
{@link java.util.List}.



The main limitation of this check is handling the cases where:



An imported type has the same name as a declaration, such as a member variable.


There are two or more static imports with the same method name
(javac can distinguish imports with same name but different parameters, but checkstyle
can not due to
limitation.)
[Options]
processJavadoc, Control whether to process Javadoc comments.
[Rule]
SingleLineJavadoc
[Description]
Checks that a Javadoc block can fit in a single-line and doesn't
contain block tags. Javadoc comment that contains at least one block tag
should be formatted in a few lines.
[Options]
ignoreInlineTags, Control whether
inline tags must be ignored.
ignoredTags, Specify
block tags which are ignored by the check.
violateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at
Tight-HTML Rules.
[Rule]
JavadocParagraph
[Description]
Checks the Javadoc paragraph.


Checks that:



There is one blank line between each of two paragraphs.


Each paragraph but the first has <p> immediately before the first word, with
no space after.
[Options]
allowNewlineParagraph, Control whether the <p> tag should be placed immediately before the first word.
violateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at
Tight-HTML Rules.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
