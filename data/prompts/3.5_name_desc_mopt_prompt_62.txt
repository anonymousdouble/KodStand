Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.8.3.1 Array initializers: can be "block-like"
Any array initializer may optionally be formatted as if it were a "block-like construct." For example, the following are all valid (not an exhaustive list):
 new int[] {  new int[] {
  0, 1, 2, 3 0,
 }  1,
  2,
 new int[] {  3,
  0, 1,  }
  2, 3
 }  new int[]
  {0, 1, 2, 3}

CheckStyle Rules:
[Rule]
ArrayTrailingComma
[Description]
Checks that array initialization contains a trailing comma.



int[] a = new int[]
{
1,
2,
3,
};


By default, the check demands a comma at the end if neither left nor right curly braces
are on the same line as the last element of the array.



return new int[] { 0 };
return new int[] { 0
};
return new int[] {
0 };


Rationale: Putting this comma in makes it easier to change the order
of the elements or add new elements on the end. Main benefit of a trailing
comma is that when you add new entry to an array, no surrounding lines are changed.



{
100000000000000000000,
200000000000000000000, // OK
}

{
100000000000000000000,
200000000000000000000,
300000000000000000000,  // Just this line added, no other changes
}


If closing brace is on the same line as trailing comma, this benefit is gone
(as the check does not demand a certain location of curly braces the following
two cases will not produce a violation):



{100000000000000000000,
200000000000000000000,} // Trailing comma not needed, line needs to be modified anyway

{100000000000000000000,
200000000000000000000, // Modified line
300000000000000000000,} // Added line


If opening brace is on the same line as trailing comma there's also (more arguable)
problem:



{100000000000000000000, // Line cannot be just duplicated to slightly modify entry
}

{100000000000000000000,
100000000000000000001, // More work needed to duplicate
}
[Options]
alwaysDemandTrailingComma, Control whether to always check for a trailing comma, even when an array is inline.
[Rule]
NoArrayTrailingComma
[Description]
Checks that array initialization do not contain a trailing comma.
Rationale: JLS allows trailing commas in arrays and enumerations, but does not allow
them in other locations. To unify the coding style, the use of trailing commas should
be prohibited.



int[] foo = new int[] {
1,
2
};


The check demands that there should not be any comma after the last element of an array.



String[] foo = new String[] {
"FOO",
"BAR", //violation
}
[Options]
[Rule]
AvoidNestedBlocks
[Description]
Finds nested blocks (blocks that are used freely in the code).


Rationale: Nested blocks are often leftovers from the
debugging process, they confuse the reader.


For example, this check finds the obsolete braces in



public void guessTheOutput()
{
int whichIsWhich = 0;
{
whichIsWhich = 2;
}
System.out.println("value = " + whichIsWhich);
}

and debugging / refactoring leftovers such as


// if (conditionThatIsNotUsedAnyLonger)
{
System.out.println("unconditional");
}


A case in a switch statement does not implicitly form a block.
Thus, to be able to introduce local variables that have case
scope it is necessary to open a nested block. This is
supported, set the allowInSwitchCase property to true and
include all statements of the case in the block.
[Options]
allowInSwitchCase, Allow nested blocks if they are the only child of a switch case.
[Rule]
AvoidDoubleBraceInitialization
[Description]
Detects double brace initialization.


Rationale: Double brace initialization (set of

Instance Initializers in class body) may look cool,
but it is considered as anti-pattern and should be avoided.
This is also can lead to a hard-to-detect memory leak, if the anonymous class instance is
returned outside and other object(s) hold reference to it.
Created anonymous class is not static, it holds an implicit reference to the outer class
instance.
See this

blog post and

article for more details.
Check ignores any comments and semicolons in class body.
[Options]
[Rule]
InnerAssignment
[Description]
Checks for assignments in subexpressions, such as in
String s = Integer.toString(i = 2);.


Rationale: Except for the loop idioms,
all assignments should occur in their own top-level statement
to increase readability. With inner assignments like the one given above, it is difficult
to see all places where a variable is set.


Note: Check allows usage of the popular assignments in loops:



String line;
while ((line = bufferedReader.readLine()) != null) { // OK
// process the line
}

for (;(line = bufferedReader.readLine()) != null;) { // OK
// process the line
}

do {
// process the line
}
while ((line = bufferedReader.readLine()) != null); // OK


Assignment inside a condition is not a problem here, as the assignment is surrounded by
an extra pair of parentheses. The comparison is != null and there is no
chance that intention was to write line == reader.readLine().
[Options]
[Rule]
Indentation
[Description]
Checks correct indentation of Java code.


The idea behind this is that while pretty printers are
sometimes convenient for bulk reformats of legacy code, they often
either aren't configurable enough or just can't anticipate how
format should be done. Sometimes this is personal preference, other
times it is practical experience. In any case, this check should
just ensure that a minimal set of indentation rules is followed.


Basic offset indentation is used for indentation inside code blocks.
For any lines that span more than 1, line wrapping indentation is used for those
lines after the first.
Brace adjustment, case, and throws indentations are all used only if those specific
identifiers start the line. If, for example, a brace is used in the middle of the line,
its indentation will not take effect.
All indentations have an accumulative/recursive effect when they are triggered. If
during a line wrapping, another code block is found and it doesn't end on that same
line, then the subsequent lines afterwards, in that new code block, are increased on
top of the line wrap and any indentations above it.

Example:


if ((condition1 && condition2)
|| (condition3 && condition4)    // line wrap with bigger indentation
||!(condition5 && condition6)) { // line wrap with bigger indentation
field.doSomething()                    // basic offset
.doSomething()                     // line wrap
.doSomething( c -> {               // line wrap
return c.doSome();               // basic offset
});
}
[Options]
arrayInitIndent, Specify how far an array initialization should be indented when on next line.
basicOffset, Specify how far new indentation level should be indented when on the next line.
braceAdjustment, Specify how far a braces should be indented when on the next line.
caseIndent, Specify how far a case label should be indented when on next line.
forceStrictCondition, Force strict indent level in line wrapping case. If value is true, line wrap indent have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like.
lineWrappingIndentation, Specify how far continuation line should be indented when line-wrapping is present.
throwsIndent, Specify how far a throws clause should be indented when on next line.
[Rule]
AvoidInlineConditionals
[Description]
Detects inline conditionals. Here is one example of an inline conditional:



String a = getParameter("a");
String b = (a==null || a.length()<1) ? null : a.substring(1);


Rationale: Some developers find inline conditionals hard to read, so
their employer's coding standards forbid them.
[Options]
[Rule]
ArrayTypeStyle
[Description]
Checks the style of array type definitions. Some like Java style:
public static void main(String[] args) and some like
C style: public static void main(String args[]).


By default, the Check enforces Java style.


This check strictly enforces only Java style for method return types
regardless of the value for 'javaStyle'. For example, byte[] getData().
This is because C doesn't compile methods with array declarations on the name.
[Options]
javaStyle, Control whether to enforce Java style (true) or C style (false).
[Rule]
UnusedLocalVariable
[Description]
Checks that a local variable is declared and/or assigned, but not used.
Doesn't support pattern variables yet.
Doesn't check array components as array
components are classified as different kind of variables by JLS.
[Options]
[Rule]
SingleLineJavadoc
[Description]
Checks that a Javadoc block can fit in a single-line and doesn't
contain block tags. Javadoc comment that contains at least one block tag
should be formatted in a few lines.
[Options]
ignoreInlineTags, Control whether
inline tags must be ignored.
ignoredTags, Specify
block tags which are ignored by the check.
violateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at
Tight-HTML Rules.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
