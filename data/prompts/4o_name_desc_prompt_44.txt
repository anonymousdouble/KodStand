Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
6.3 Static members: qualified using class
When a reference to a static class member must be qualified, it is qualified with that class's name, not with a reference or expression of that class's type.
 Foo aFoo = ...;
 Foo.aStaticMethod(); // good
 aFoo.aStaticMethod(); // bad
 somethingThatYieldsAFoo().aStaticMethod(); // very bad

CheckStyle Rules:
[Rule]
AvoidStaticImport
[Description]
Checks that there are no static import statements.


Rationale: Importing static members can lead to naming
conflicts between class' members. It may lead to poor code
readability since it may no longer be clear what class a
member resides in (without looking at the import statement).
[Rule]
FinalClass
[Description]
Ensures that identifies classes that can be effectively declared as final are explicitly
marked as final. The following are different types of classes that can be identified:



Private classes with no declared constructors.


Classes with any modifier, and contains only private constructors.



Classes are skipped if:



Class is Super class of some Anonymous inner class.


Class is extended by another class in the same file.
[Rule]
HideUtilityClassConstructor
[Description]
Makes sure that utility classes (classes that contain only static
methods or fields in their API) do not have a public constructor.


Rationale: Instantiating utility classes does not make sense. Hence,
the constructors should either be private or (if you want to allow
subclassing) protected. A common mistake is forgetting to hide the
default constructor.


If you make the constructor protected you may want to consider the
following constructor implementation technique to disallow
instantiating subclasses:



public class StringUtils // not final to allow subclassing
{
protected StringUtils() {
// prevents calls from subclass
throw new UnsupportedOperationException();
}

public static int count(char c, String s) {
// ...
}
}
[Rule]
RequireThis
[Description]
Checks that references to instance variables and methods of the present
object are explicitly of the form "this.varName" or
"this.methodName(args)" and that those references don't
rely on the default behavior when "this." is absent.


Warning: the Check is very controversial if 'validateOnlyOverlapping' option is set to
'false' and not that actual nowadays.


Rationale:



The same notation/habit for C++ and Java (C++ have global methods, so having
"this." do make sense in it to distinguish call of method of class
instead of global).


Non-IDE development (ease of refactoring, some clearness to distinguish
static and non-static methods).
[Rule]
ClassMemberImpliedModifier
[Description]
Checks for implicit modifiers on nested types in classes and records.


This check is effectively the opposite of
RedundantModifier.
It checks the modifiers on nested types in classes and records, ensuring that certain
modifiers are explicitly specified even though they are actually redundant.


Nested enums, interfaces, and records within a class are always static and as
such the compiler does not require the static modifier. This check provides
the ability to enforce that the static modifier is explicitly coded and not
implicitly added by the compiler.



public final class Person {
enum Age {  // violation
CHILD, ADULT
}
}


Rationale for this check:
Nested enums, interfaces, and records are treated differently from nested classes as they
are only allowed to be static. Developers should not need to remember this
rule, and this check provides the means to enforce that the modifier is coded explicitly.
[Rule]
ConstantName
[Description]
Checks that constant names conform to a specified pattern.
A constant is a static and final field or an
interface/annotation field, except serialVersionUID and
serialPersistentFields.
[Rule]
RedundantModifier
[Description]
Checks for redundant modifiers.


Rationale: The Java Language Specification strongly
discourages the usage of public and abstract for method
declarations in interface definitions as a matter of style.

The check validates:

Interface and annotation definitions.
Final modifier on methods of final and anonymous classes.

Type declarations nested under interfaces that are declared as public
or static.

Class constructors.

Nested enum definitions that are declared
as static.


record definitions that are declared as final and nested
record definitions that are declared as static.



interfaces by definition are abstract so the abstract modifier is
redundant on them.


Type declarations nested under interfaces by definition are public and static,
so the public and static modifiers on nested type
declarations are redundant. On the other hand, classes inside of interfaces can
be abstract or non abstract. So, abstract modifier is allowed.


Fields in interfaces and annotations are automatically
public, static and final, so these modifiers are redundant as
well.


As annotations are a form of interface, their fields are also
automatically public, static and final just as their
annotation fields are automatically public and abstract.


A record class is implicitly final and cannot be abstract, these restrictions emphasize
that the API of a record class is defined solely by its state description, and cannot be
enhanced later by another class. Nested records are implicitly static. This avoids an
immediately enclosing instance which would silently add state to the record class.
See JEP 395 for more info.


Enums by definition are static implicit subclasses of java.lang.Enum<E>.
So, the static modifier on the enums is redundant. In addition,
if enum is inside of interface, public modifier is also redundant.


Enums can also contain abstract methods and methods which can be overridden by the
declared enumeration fields.
See the following example:



public enum EnumClass {
FIELD_1,
FIELD_2 {
@Override
public final void method1() {} // violation expected
};

public void method1() {}
public final void method2() {} // no violation expected
}


Since these methods can be overridden in these situations, the final methods are not
marked as redundant even though they can't be extended by other classes/enums.


Nested enum types are always static by default.


Final classes by definition cannot be extended so the final
modifier on the method of a final class is redundant.


Public modifier for constructors in non-public non-protected classes
is always obsolete:



public class PublicClass {
public PublicClass() {} // OK
}

class PackagePrivateClass {
public PackagePrivateClass() {} // violation expected
}

There is no violation in the following example,
because removing public modifier from ProtectedInnerClass
constructor will make this code not compiling:



package a;
public class ClassExample {
protected class ProtectedInnerClass {
public ProtectedInnerClass () {}
}
}

package b;
import a.ClassExample;
public class ClassExtending extends ClassExample {
ProtectedInnerClass pc = new ProtectedInnerClass();
}
[Rule]
StaticVariableName
[Description]
Checks that static, non-final variable names
conform to a specified pattern.
[Rule]
OneTopLevelClass
[Description]
Checks that each top-level class, interface, enum
or annotation resides in a source file of its own.
Official description of a 'top-level' term:
7.6. Top Level Type Declarations.
If file doesn't contain public class, interface, enum or annotation,
top-level type is the first type in file.
[Rule]
InterfaceMemberImpliedModifier
[Description]
Checks for implicit modifiers on interface members and nested types.


This check is effectively the opposite of
RedundantModifier.
It checks the modifiers on interface members, ensuring that certain
modifiers are explicitly specified even though they are actually redundant.


Methods in interfaces are public by default, however from Java 9
they can also be private. This check provides the ability to enforce
that public is explicitly coded and not implicitly added by the compiler.


From Java 8, there are three types of methods in interfaces - static methods
marked with static, default methods marked with default and
abstract methods which do not have to be marked with anything.
From Java 9, there are also private methods marked with private.
This check provides the ability to enforce that abstract is explicitly
coded and not implicitly added by the compiler.


Fields in interfaces are always public static final and as such the
compiler does not require these modifiers. This check provides the ability to
enforce that these modifiers are explicitly coded and not implicitly added by
the compiler.


Nested types within an interface are always public static and as such the
compiler does not require the public static modifiers. This check provides
the ability to enforce that the public and static modifiers
are explicitly coded and not implicitly added by the compiler.



public interface AddressFactory {
// check enforces code contains "public static final"
public static final String UNKNOWN = "Unknown";

String OTHER = "Other";  // violation

// check enforces code contains "public" or "private"
public static AddressFactory instance();

// check enforces code contains "public abstract"
public abstract Address createAddress(String addressLine, String city);

List<Address> findAddresses(String city);  // violation

// check enforces default methods are explicitly declared "public"
public default Address createAddress(String city) {
return createAddress(UNKNOWN, city);
}

default Address createOtherAddress() {  // violation
return createAddress(OTHER, OTHER);
}
}


Rationale for this check:
Methods, fields and nested types are treated differently depending on whether
they are part of an interface or part of a class. For example, by default methods
are package-scoped on classes, but public in interfaces. However, from Java 8 onwards,
interfaces have changed to be much more like abstract classes.
Interfaces now have static and instance methods with code. Developers should not have
to remember which modifiers are required and which are implied.
This check allows the simpler alternative approach to be adopted where the
implied modifiers must always be coded explicitly.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
