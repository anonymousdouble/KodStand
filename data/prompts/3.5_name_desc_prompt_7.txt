Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
3.3.1 No wildcard imports
Wildcard imports , static or otherwise, are not used .

CheckStyle Rules:
[Rule]
AvoidStaticImport
[Description]
Checks that there are no static import statements.


Rationale: Importing static members can lead to naming
conflicts between class' members. It may lead to poor code
readability since it may no longer be clear what class a
member resides in (without looking at the import statement).
[Rule]
AvoidStarImport
[Description]
Checks that there are no import statements that use the * notation.


Rationale: Importing all classes from a package or static
members from a class leads to tight coupling between packages
or classes and might lead to problems when a new version of a
library introduces name clashes.
[Rule]
UnusedImports
[Description]
Checks for unused import statements. An
import statement is considered unused if:



It is not referenced in the file. The algorithm does not support
wild-card imports like import
java.io.*;. Most IDE's provide very sophisticated checks
for imports that handle wild-card imports.


The class imported is from the java.lang
package. For example importing java.lang.String.


The class imported is from the same package.


A static method is imported when used as method reference. In that case,
only the type needs to be imported and that's enough to resolve the method.


Optionally: it is referenced in Javadoc comments. This check
is on by default, but it is considered bad practice to introduce
a compile-time dependency for documentation purposes only.
As an example, the import java.util.List would be
considered referenced with the Javadoc comment
{@link List}. The alternative to avoid introducing a
compile-time dependency would be to write the Javadoc comment as
{@link java.util.List}.



The main limitation of this check is handling the cases where:



An imported type has the same name as a declaration, such as a member variable.


There are two or more static imports with the same method name
(javac can distinguish imports with same name but different parameters, but checkstyle
can not due to
limitation.)
[Rule]
RedundantImport
[Description]
Checks for redundant import statements. An import statement is
considered redundant if:



It is a duplicate of another import. This is, when a class is
imported more than once.


The class non-statically imported is from the java.lang
package, e.g. importing java.lang.String.


The class non-statically imported is from the same package as the current package.
[Rule]
HideUtilityClassConstructor
[Description]
Makes sure that utility classes (classes that contain only static
methods or fields in their API) do not have a public constructor.


Rationale: Instantiating utility classes does not make sense. Hence,
the constructors should either be private or (if you want to allow
subclassing) protected. A common mistake is forgetting to hide the
default constructor.


If you make the constructor protected you may want to consider the
following constructor implementation technique to disallow
instantiating subclasses:



public class StringUtils // not final to allow subclassing
{
protected StringUtils() {
// prevents calls from subclass
throw new UnsupportedOperationException();
}

public static int count(char c, String s) {
// ...
}
}
[Rule]
ImportOrder
[Description]
Checks the ordering/grouping of imports. Features are:

groups type/static imports: ensures that groups of imports come in a
specific order (e.g., java. comes first, javax. comes second,
then everything else)
adds a separation between type import groups : ensures that a blank
line sit between each group
type/static import groups aren't separated internally: ensures that
each group aren't separated internally by blank line or comment
sorts type/static imports inside each group: ensures that imports
within each group are in lexicographic order

sorts according to case: ensures that the comparison
between imports is case-sensitive, in
ASCII sort order


arrange static imports: ensures the relative order between
type imports and static imports (see
ImportOrderOption)
[Rule]
MagicNumber
[Description]
Checks that there are no

"magic numbers" where a magic
number is a numeric literal that is not defined as a constant.
By default, -1, 0, 1, and 2 are not considered to be magic numbers.


Constant definition is any variable/field that has 'final' modifier.
It is fine to have one constant defining multiple numeric literals within one expression:



static final int SECONDS_PER_DAY = 24 * 60 * 60;
static final double SPECIAL_RATIO = 4.0 / 3.0;
static final double SPECIAL_SUM = 1 + Math.E;
static final double SPECIAL_DIFFERENCE = 4 - Math.PI;
static final Border STANDARD_BORDER = BorderFactory.createEmptyBorder(3, 3, 3, 3);
static final Integer ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE = new Integer(42);
[Rule]
FinalClass
[Description]
Ensures that identifies classes that can be effectively declared as final are explicitly
marked as final. The following are different types of classes that can be identified:



Private classes with no declared constructors.


Classes with any modifier, and contains only private constructors.



Classes are skipped if:



Class is Super class of some Anonymous inner class.


Class is extended by another class in the same file.
[Rule]
PackageDeclaration
[Description]
Ensures that a class has a package declaration, and (optionally) whether
the package name matches the directory name for the source file.


Rationale: Classes that live in the null package cannot be
imported. Many novice developers are not aware of this.


Packages provide logical namespace to classes and should be stored in
the form of directory levels to provide physical grouping to your classes.
These directories are added to the classpath so that your classes
are visible to JVM when it runs the code.
[Rule]
IllegalType
[Description]
Checks that particular classes or interfaces are never used.


Rationale: Helps reduce coupling on concrete classes.


For additional restriction of type usage see also:
IllegalInstantiation,
IllegalImport

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
