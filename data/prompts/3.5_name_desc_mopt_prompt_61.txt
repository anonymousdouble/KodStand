Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.8.2.2 Declared when needed
Local variables are not habitually declared at the start of their containing block or block-like construct. Instead, local variables are declared close to the point they are first used (within reason), to minimize their scope. Local variable declarations typically have initializers, or are initialized immediately after declaration.

CheckStyle Rules:
[Rule]
UnusedLocalVariable
[Description]
Checks that a local variable is declared and/or assigned, but not used.
Doesn't support pattern variables yet.
Doesn't check array components as array
components are classified as different kind of variables by JLS.
[Options]
[Rule]
MultipleVariableDeclarations
[Description]
Checks that each variable declaration is in its own statement and on
its own line.


Rationale:

the Java code conventions chapter 6.1 recommends that
declarations should be one per line/statement.
[Options]
[Rule]
FinalLocalVariable
[Description]
Checks that local variables that never have their values changed are
declared final. The check can be configured to also check that
unchanged parameters are declared final.
[Options]
validateEnhancedForLoopVariable, Control whether to check
enhanced for-loop variable.
tokens, tokens to check
[Rule]
VariableDeclarationUsageDistance
[Description]
Checks the distance between declaration of variable and its first usage.
Note : Variable declaration/initialization statements are not counted
while calculating length.
[Options]
allowedDistance, Specify distance between declaration of variable and its first usage. Values should be greater than 0.
ignoreFinal, Allow to ignore variables with a 'final' modifier.
ignoreVariablePattern, Define RegExp to ignore distance calculation for variables listed in this pattern.
validateBetweenScopes, Allow to calculate the distance between declaration of variable and its first usage in the different scopes.
[Rule]
AvoidNestedBlocks
[Description]
Finds nested blocks (blocks that are used freely in the code).


Rationale: Nested blocks are often leftovers from the
debugging process, they confuse the reader.


For example, this check finds the obsolete braces in



public void guessTheOutput()
{
int whichIsWhich = 0;
{
whichIsWhich = 2;
}
System.out.println("value = " + whichIsWhich);
}

and debugging / refactoring leftovers such as


// if (conditionThatIsNotUsedAnyLonger)
{
System.out.println("unconditional");
}


A case in a switch statement does not implicitly form a block.
Thus, to be able to introduce local variables that have case
scope it is necessary to open a nested block. This is
supported, set the allowInSwitchCase property to true and
include all statements of the case in the block.
[Options]
allowInSwitchCase, Allow nested blocks if they are the only child of a switch case.
[Rule]
AvoidDoubleBraceInitialization
[Description]
Detects double brace initialization.


Rationale: Double brace initialization (set of

Instance Initializers in class body) may look cool,
but it is considered as anti-pattern and should be avoided.
This is also can lead to a hard-to-detect memory leak, if the anonymous class instance is
returned outside and other object(s) hold reference to it.
Created anonymous class is not static, it holds an implicit reference to the outer class
instance.
See this

blog post and

article for more details.
Check ignores any comments and semicolons in class body.
[Options]
[Rule]
InnerAssignment
[Description]
Checks for assignments in subexpressions, such as in
String s = Integer.toString(i = 2);.


Rationale: Except for the loop idioms,
all assignments should occur in their own top-level statement
to increase readability. With inner assignments like the one given above, it is difficult
to see all places where a variable is set.


Note: Check allows usage of the popular assignments in loops:



String line;
while ((line = bufferedReader.readLine()) != null) { // OK
// process the line
}

for (;(line = bufferedReader.readLine()) != null;) { // OK
// process the line
}

do {
// process the line
}
while ((line = bufferedReader.readLine()) != null); // OK


Assignment inside a condition is not a problem here, as the assignment is surrounded by
an extra pair of parentheses. The comparison is != null and there is no
chance that intention was to write line == reader.readLine().
[Options]
[Rule]
AvoidInlineConditionals
[Description]
Detects inline conditionals. Here is one example of an inline conditional:



String a = getParameter("a");
String b = (a==null || a.length()<1) ? null : a.substring(1);


Rationale: Some developers find inline conditionals hard to read, so
their employer's coding standards forbid them.
[Options]
[Rule]
InnerTypeLast
[Description]
Checks nested (internal) classes/interfaces are declared at the bottom of the
primary (top-level) class after all init and static init blocks,
method, constructor and field declarations.
[Options]
[Rule]
ModifiedControlVariable
[Description]
Checks that for loop control variables are not modified inside
the for block. An example is:



for (int i = 0; i < 1; i++) {
i++; // violation
}


Rationale: If the control variable is modified inside the loop
body, the program flow becomes more difficult to follow. See

FOR statement specification for more details.


Such loop would be suppressed:



for (int i = 0; i < 10;) {
i++;
}


NOTE:The check works with only primitive type variables.
The check will not work for arrays used as control variable.An example is



for (int a[]={0};a[0] < 10;a[0]++) {
a[0]++;   // it will skip this violation
}
[Options]
skipEnhancedForLoopVariable, Control whether to check
enhanced for-loop variable.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
