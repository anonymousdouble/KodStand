Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
5.2.7 Local variable names
Local variable names are written in lowerCamelCase .
 Even when final and immutable, local variables are not considered to be constants, and should not be styled as constants.

CheckStyle Rules:
[Rule]
UnusedLocalVariable
[Description]
Checks that a local variable is declared and/or assigned, but not used.
Doesn't support pattern variables yet.
Doesn't check array components as array
components are classified as different kind of variables by JLS.
[Options]
[Rule]
LocalVariableName
[Description]
Checks that local, non-final variable names conform to a specified pattern.
A catch parameter is considered to be a local variable.
[Options]
allowOneCharVarInForLoop, Allow one character variable name in
initialization expressions in FOR loop if one char variable name is prohibited by format regexp.
format, Sets the pattern to match valid identifiers.
[Rule]
AbbreviationAsWordInName
[Description]
Validates abbreviations (consecutive capital letters) length in identifier name,
it also allows to enforce camel case naming. Please read more at

Google Style Guide
to get to know how to avoid long abbreviations in names.

'_' is considered as word separator in identifier name.

allowedAbbreviationLength specifies how many consecutive capital letters are
allowed in the identifier.
A value of 3 indicates that up to 4 consecutive capital letters are allowed,
one after the other, before a violation is printed. The identifier 'MyTEST' would be
allowed, but 'MyTESTS' would not be.
A value of 0 indicates that only 1 consecutive capital letter is allowed. This
is what should be used to enforce strict camel casing. The identifier 'MyTest' would
be allowed, but 'MyTEst' would not be.


ignoreFinal, ignoreStatic, and ignoreStaticFinal
control whether variables with the respective modifiers are to be ignored.
Note that a variable that is both static and final will always be considered under
ignoreStaticFinal only, regardless of the values of ignoreFinal
and ignoreStatic. So for example if ignoreStatic is true but
ignoreStaticFinal is false, then static final variables will not be ignored.
[Options]
allowedAbbreviationLength, Indicate the number of consecutive capital letters allowed in targeted identifiers (abbreviations in the classes, interfaces, variables and methods names, ... ).
allowedAbbreviations, Specify abbreviations that must be skipped for checking.
ignoreFinal, Allow to skip variables with final modifier.
ignoreOverriddenMethods, Allow to ignore methods tagged with @Override annotation (that usually mean inherited name).
ignoreStatic, Allow to skip variables with static modifier.
ignoreStaticFinal, Allow to skip variables with both static and final modifiers.
tokens, tokens to check
[Rule]
FinalLocalVariable
[Description]
Checks that local variables that never have their values changed are
declared final. The check can be configured to also check that
unchanged parameters are declared final.
[Options]
validateEnhancedForLoopVariable, Control whether to check
enhanced for-loop variable.
tokens, tokens to check
[Rule]
StaticVariableName
[Description]
Checks that static, non-final variable names
conform to a specified pattern.
[Options]
applyToPackage, Control if check should apply to package-private members.
applyToPrivate, Control if check should apply to private members.
applyToProtected, Control if check should apply to protected members.
applyToPublic, Control if check should apply to public members.
format, Sets the pattern to match valid identifiers.
[Rule]
HiddenField
[Description]
Checks that a local variable or a parameter does not shadow a field
that is defined in the same class.
[Options]
ignoreAbstractMethods, Control whether to ignore parameters of abstract methods.
ignoreConstructorParameter, Control whether to ignore constructor parameters.
ignoreFormat, Define the RegExp for names of variables and parameters to ignore.
ignoreSetter, Allow to ignore the parameter of a property setter method.
setterCanReturnItsClass, Allow to expand the definition of a setter method to include methods that return the class' instance.
tokens, tokens to check
[Rule]
MultipleVariableDeclarations
[Description]
Checks that each variable declaration is in its own statement and on
its own line.


Rationale:

the Java code conventions chapter 6.1 recommends that
declarations should be one per line/statement.
[Options]
[Rule]
LocalFinalVariableName
[Description]
Checks that local final variable names conform to a specified pattern.
A catch parameter and resources in try statements
are considered to be a local, final variables.
[Options]
format, Sets the pattern to match valid identifiers.
tokens, tokens to check
[Rule]
ModifierOrder
[Description]
Checks that the order of modifiers conforms to the suggestions in
the Java
Language specification, ¡ì 8.1.1, 8.3.1, 8.4.3 and

9.4. The correct order is:



public


protected


private


abstract


default


static


sealed


non-sealed


final


transient


volatile


synchronized


native


strictfp



In additional, modifiers are checked to ensure all annotations are
declared before all other modifiers.


Rationale: Code is easier to read if everybody follows a standard.


ATTENTION: We skip

type annotations from validation.
[Options]
[Rule]
LambdaParameterName
[Description]
Checks lambda parameter names.
[Options]
format, Sets the pattern to match valid identifiers.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
