Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.8.5.3 Method and constructor annotations
The rules for annotations on method and constructor declarations are the same as the previous section. Example:
 @Deprecated
 @Override
 public String getNameIfPresent() { ... }
 Exception: A single parameterless annotation may instead appear together with the first line of the signature, for example:
 @Override public int hashCode() { ... }

CheckStyle Rules:
[Rule]
MissingDeprecated
[Description]
Verifies that the annotation @Deprecated and the Javadoc tag
@deprecated are both present when either of them is present.


Both ways of flagging deprecation serve their own purpose.
The @Deprecated annotation is used for compilers and development tools.
The @deprecated javadoc tag is used to document why something is deprecated
and what, if any, alternatives exist.


In order to properly mark something as deprecated both forms of
deprecation should be present.


Package deprecation is an exception to the rule of always using the
javadoc tag and annotation to deprecate.  It is not clear if the
javadoc tool will support it or not as newer versions keep flip-flopping
on if it is supported or will cause an error.
See
JDK-8160601.
The deprecated javadoc tag is currently the only way to say why the package
is deprecated and what to use instead.  Until this is resolved, if you
don't want to print violations on package-info, you can use a
filter to ignore these files until
the javadoc tool faithfully supports it. An example config using
SuppressionSingleFilter is:



<!-- required till https://bugs.openjdk.org/browse/JDK-8160601 -->
<module name="SuppressionSingleFilter">
<property name="checks" value="MissingDeprecatedCheck"/>
<property name="files" value="package-info\.java"/>
</module>
[Rule]
AnnotationLocation
[Description]
Checks location of annotation on language elements.
By default, Check enforce to locate annotations immediately after documentation block
and before target element, annotation should be located on separate line from target
element. This check also verifies that the annotations are on the same indenting level as
the annotated element if they are not on the same line.


Attention: Elements that cannot have JavaDoc comments like local variables are not in the
scope of this check even though a token type like VARIABLE_DEF would match
them.


Attention: Annotations among modifiers are ignored (looks like false-negative)
as there might be a problem with annotations for return types:


public @Nullable Long getStartTimeOrNull() { ... }

Such annotations are better to keep close to type.
Due to limitations, Checkstyle can not examine the target of an annotation.


Example:



@Override
@Nullable
public String getNameIfPresent() { ... }
[Rule]
DeclarationOrder
[Description]
Checks that the parts of a class, record, or interface declaration appear in the order
suggested by the

Code Conventions for the Java Programming Language.


According to

Code Conventions for the Java Programming Language , the parts
of a class or interface declaration should appear in the following
order:



Class (static) variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.


Instance variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.

Constructors
Methods


Purpose of ignore* option is to ignore related violations,
however it still impacts on other class members.


ATTENTION: the check skips class fields which have

forward references
from validation due to the fact that we have Checkstyle's limitations to clearly
detect user intention of fields location and grouping. For example:



public class A {
private double x = 1.0;
private double y = 2.0;
public double slope = x / y; // will be skipped from validation due to forward reference
}
[Rule]
RedundantModifier
[Description]
Checks for redundant modifiers.


Rationale: The Java Language Specification strongly
discourages the usage of public and abstract for method
declarations in interface definitions as a matter of style.

The check validates:

Interface and annotation definitions.
Final modifier on methods of final and anonymous classes.

Type declarations nested under interfaces that are declared as public
or static.

Class constructors.

Nested enum definitions that are declared
as static.


record definitions that are declared as final and nested
record definitions that are declared as static.



interfaces by definition are abstract so the abstract modifier is
redundant on them.


Type declarations nested under interfaces by definition are public and static,
so the public and static modifiers on nested type
declarations are redundant. On the other hand, classes inside of interfaces can
be abstract or non abstract. So, abstract modifier is allowed.


Fields in interfaces and annotations are automatically
public, static and final, so these modifiers are redundant as
well.


As annotations are a form of interface, their fields are also
automatically public, static and final just as their
annotation fields are automatically public and abstract.


A record class is implicitly final and cannot be abstract, these restrictions emphasize
that the API of a record class is defined solely by its state description, and cannot be
enhanced later by another class. Nested records are implicitly static. This avoids an
immediately enclosing instance which would silently add state to the record class.
See JEP 395 for more info.


Enums by definition are static implicit subclasses of java.lang.Enum<E>.
So, the static modifier on the enums is redundant. In addition,
if enum is inside of interface, public modifier is also redundant.


Enums can also contain abstract methods and methods which can be overridden by the
declared enumeration fields.
See the following example:



public enum EnumClass {
FIELD_1,
FIELD_2 {
@Override
public final void method1() {} // violation expected
};

public void method1() {}
public final void method2() {} // no violation expected
}


Since these methods can be overridden in these situations, the final methods are not
marked as redundant even though they can't be extended by other classes/enums.


Nested enum types are always static by default.


Final classes by definition cannot be extended so the final
modifier on the method of a final class is redundant.


Public modifier for constructors in non-public non-protected classes
is always obsolete:



public class PublicClass {
public PublicClass() {} // OK
}

class PackagePrivateClass {
public PackagePrivateClass() {} // violation expected
}

There is no violation in the following example,
because removing public modifier from ProtectedInnerClass
constructor will make this code not compiling:



package a;
public class ClassExample {
protected class ProtectedInnerClass {
public ProtectedInnerClass () {}
}
}

package b;
import a.ClassExample;
public class ClassExtending extends ClassExample {
ProtectedInnerClass pc = new ProtectedInnerClass();
}
[Rule]
DesignForExtension
[Description]
Checks that classes are designed for extension (subclass creation).


Nothing wrong could be with founded classes.
This check makes sense only for library projects (not application projects)
which care of ideal OOP-design to make sure that class works in all cases even misusage.
Even in library projects this check most likely will find classes that are designed
for extension by somebody. User needs to use suppressions extensively to got a benefit
from this check, and keep in suppressions all confirmed/known classes that are deigned
for inheritance intentionally to let the check catch only new classes, and bring this to
team/user attention.


ATTENTION: Only user can decide whether a class is designed for extension or not.
The check just shows all classes which are possibly designed for extension.
If smth inappropriate is found please use suppression.


ATTENTION: If the method which can be overridden in a subclass has a javadoc comment
(a good practice is to explain its self-use of overridable methods) the check will not
rise a violation. The violation can also be skipped if the method which can be overridden
in a subclass has one or more annotations that are specified in ignoredAnnotations
option. Note, that by default @Override annotation is not included in the
ignoredAnnotations set as in a subclass the method which has the annotation can also be
overridden in its subclass.


Problem is described at "Effective Java, 2nd Edition by Joshua Bloch" book, chapter
"Item 17: Design and document for inheritance or else prohibit it".


Some quotes from book:

The class must document its self-use of overridable methods.
By convention, a method that invokes overridable methods contains a description
of these invocations at the end of its documentation comment. The description
begins with the phrase ¡°This implementation.¡±

The best solution to this problem is to prohibit subclassing in classes that
are not designed and documented to be safely subclassed.

If a concrete class does not implement a standard interface, then you may
inconvenience some programmers by prohibiting inheritance. If you feel that you
must allow inheritance from such a class, one reasonable approach is to ensure
that the class never invokes any of its overridable methods and to document this
fact. In other words, eliminate the class¡¯s self-use of overridable methods entirely.
In doing so, you¡¯ll create a class that is reasonably safe to subclass. Overriding a
method will never affect the behavior of any other method.


The check finds classes that have overridable methods (public or protected methods
that are non-static, not-final, non-abstract) and have non-empty implementation.


Rationale: This library design style protects superclasses against
being broken by subclasses. The downside is that subclasses are
limited in their flexibility, in particular they cannot prevent
execution of code in the superclass, but that also means that
subclasses cannot corrupt the state of the superclass by forgetting
to call the superclass's method.


More specifically,
it enforces a programming style where superclasses provide empty
"hooks" that can be implemented by subclasses.


Example of code that cause violation as it is designed for extension:



public abstract class Plant {
private String roots;
private String trunk;

protected void validate() {
if (roots == null) throw new IllegalArgumentException("No roots!");
if (trunk == null) throw new IllegalArgumentException("No trunk!");
}

public abstract void grow();
}

public class Tree extends Plant {
private List leaves;

@Overrides
protected void validate() {
super.validate();
if (leaves == null) throw new IllegalArgumentException("No leaves!");
}

public void grow() {
validate();
}
}


Example of code without violation:



public abstract class Plant {
private String roots;
private String trunk;

private void validate() {
if (roots == null) throw new IllegalArgumentException("No roots!");
if (trunk == null) throw new IllegalArgumentException("No trunk!");
validateEx();
}

protected void validateEx() { }

public abstract void grow();
}
[Rule]
ModifierOrder
[Description]
Checks that the order of modifiers conforms to the suggestions in
the Java
Language specification, ¡ì 8.1.1, 8.3.1, 8.4.3 and

9.4. The correct order is:



public


protected


private


abstract


default


static


sealed


non-sealed


final


transient


volatile


synchronized


native


strictfp



In additional, modifiers are checked to ensure all annotations are
declared before all other modifiers.


Rationale: Code is easier to read if everybody follows a standard.


ATTENTION: We skip

type annotations from validation.
[Rule]
IllegalInstantiation
[Description]
Checks for illegal instantiations where a factory method is
preferred.


Rationale: Depending on the project, for some classes it might be
preferable to create instances through factory methods rather than
calling the constructor.


A simple example is the java.lang.Boolean
class. For performance reasons, it is preferable to
use the predefined constants  TRUE and
FALSE. Constructor invocations should be
replaced by calls to Boolean.valueOf().


Some extremely performance sensitive projects may require the use of
factory methods for other classes as well, to enforce the usage of
number caches or object pools.
[Rule]
FinalParameters
[Description]
Checks that parameters for methods, constructors, catch and for-each blocks are
final. Interface, abstract, and native methods are not checked: the final
keyword does not make sense for interface, abstract, and native method
parameters as there is no code that could modify the parameter.


Rationale: Changing the value of parameters during the execution of
the method's algorithm can be confusing and should be avoided. A
great way to let the Java compiler prevent this coding style is to
declare parameters final.
[Rule]
AvoidInlineConditionals
[Description]
Detects inline conditionals. Here is one example of an inline conditional:



String a = getParameter("a");
String b = (a==null || a.length()<1) ? null : a.substring(1);


Rationale: Some developers find inline conditionals hard to read, so
their employer's coding standards forbid them.
[Rule]
MissingOverride
[Description]
Verifies that the @Override annotation is present
when the @inheritDoc javadoc tag is present.


Rationale: The @Override annotation helps
compiler tools ensure that an override is actually occurring.  It is
quite easy to accidentally overload a method or hide a static method
and using the @Override annotation points out these problems.


This check will log a violation if using the @inheritDoc tag on a method that
is not valid (ex: private, or static method).


There is a slight difference between the @Override annotation in Java 5 versus
Java 6 and above. In Java 5, any method overridden from an interface cannot
be annotated with @Override. In Java 6 this behavior is allowed.


As a result of the aforementioned difference between Java 5 and Java 6, a
property called javaFiveCompatibility is available. This
property will only check classes, interfaces, etc. that do not contain the
extends or implements keyword or are not anonymous classes. This means it
only checks methods overridden from java.lang.Object.
Java 5 Compatibility mode severely limits this check. It is recommended to
only use it on Java 5 source.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
