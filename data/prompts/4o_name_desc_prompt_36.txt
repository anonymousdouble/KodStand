Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
5.2.3 Method names
Method names are written in lowerCamelCase .
 Method names are typically verbs or verb phrases. For example, `sendMessage` or `stop` .
 Underscores may appear in JUnit test method names to separate logical components of the name, with each component written in lowerCamelCase , for example `transferMoney_deductsFromSource` . There is no One Correct Way to name test methods.

CheckStyle Rules:
[Rule]
MethodName
[Description]
Checks that method names conform to a specified pattern.


Also, checks if a method name has the same name as the residing class.
The default is false (it is not allowed). It is legal in Java to have
method with the same name as a class. As long as a return type is specified
it is a method and not a constructor which it could be easily confused as.
Does not check-style the name of an overridden methods because the developer
does not have a choice in renaming such methods.
[Rule]
AbbreviationAsWordInName
[Description]
Validates abbreviations (consecutive capital letters) length in identifier name,
it also allows to enforce camel case naming. Please read more at

Google Style Guide
to get to know how to avoid long abbreviations in names.

'_' is considered as word separator in identifier name.

allowedAbbreviationLength specifies how many consecutive capital letters are
allowed in the identifier.
A value of 3 indicates that up to 4 consecutive capital letters are allowed,
one after the other, before a violation is printed. The identifier 'MyTEST' would be
allowed, but 'MyTESTS' would not be.
A value of 0 indicates that only 1 consecutive capital letter is allowed. This
is what should be used to enforce strict camel casing. The identifier 'MyTest' would
be allowed, but 'MyTEst' would not be.


ignoreFinal, ignoreStatic, and ignoreStaticFinal
control whether variables with the respective modifiers are to be ignored.
Note that a variable that is both static and final will always be considered under
ignoreStaticFinal only, regardless of the values of ignoreFinal
and ignoreStatic. So for example if ignoreStatic is true but
ignoreStaticFinal is false, then static final variables will not be ignored.
[Rule]
MethodLength
[Description]
Checks for long methods and constructors.


Rationale: If a method becomes very long it is hard to
understand. Therefore, long methods should usually be refactored into
several individual methods that focus on a specific task.
[Rule]
HideUtilityClassConstructor
[Description]
Makes sure that utility classes (classes that contain only static
methods or fields in their API) do not have a public constructor.


Rationale: Instantiating utility classes does not make sense. Hence,
the constructors should either be private or (if you want to allow
subclassing) protected. A common mistake is forgetting to hide the
default constructor.


If you make the constructor protected you may want to consider the
following constructor implementation technique to disallow
instantiating subclasses:



public class StringUtils // not final to allow subclassing
{
protected StringUtils() {
// prevents calls from subclass
throw new UnsupportedOperationException();
}

public static int count(char c, String s) {
// ...
}
}
[Rule]
MemberName
[Description]
Checks that instance variable names conform to a specified pattern.
[Rule]
ParameterName
[Description]
Checks that method parameter names conform to a specified pattern.
By using accessModifiers property it is possible
to specify different formats for methods at different visibility levels.


To validate catch parameters please use

CatchParameterName
.


To validate lambda parameters please use

LambdaParameterName
.
[Rule]
CatchParameterName
[Description]
Checks that catch parameter names conform to a specified pattern.


Default pattern has the following characteristic:


allows names beginning with two lowercase letters followed by at least one uppercase
or lowercase letter
allows e abbreviation (suitable for exceptions end errors)
allows ex abbreviation (suitable for exceptions)
allows t abbreviation (suitable for throwables)
prohibits numbered abbreviations like e1 or t2
prohibits one letter prefixes like pException
prohibits two letter abbreviations like ie or ee
prohibits any other characters than letters
[Rule]
RequireThis
[Description]
Checks that references to instance variables and methods of the present
object are explicitly of the form "this.varName" or
"this.methodName(args)" and that those references don't
rely on the default behavior when "this." is absent.


Warning: the Check is very controversial if 'validateOnlyOverlapping' option is set to
'false' and not that actual nowadays.


Rationale:



The same notation/habit for C++ and Java (C++ have global methods, so having
"this." do make sense in it to distinguish call of method of class
instead of global).


Non-IDE development (ease of refactoring, some clearness to distinguish
static and non-static methods).
[Rule]
PackageName
[Description]
Checks that package names conform to a specified pattern.


The default value of format for module PackageName has been
chosen to match the requirements in the
Java
Language specification and the Sun coding conventions. However,
both underscores and uppercase letters are rather uncommon, so most
configurations should probably assign value ^[a-z]+(\.[a-z][a-z0-9]*)*$ to
format for module PackageName.
[Rule]
MethodCount
[Description]
Checks the number of methods declared in each type declaration by access modifier or
total count.


This check can be configured to flag classes that define too many methods to prevent the
class from getting too complex.
Counting can be customized to prevent too many total methods in a type definition
(maxTotal), or to prevent too many methods of a specific access modifier
(private, package, protected or
public).
Each count is completely separated to customize how many methods of each you want to
allow. For example, specifying a maxTotal of 10, still means you can
prevent more than 0 maxPackage methods. A violation won't appear for 8
public methods, but one will appear if there is also 3 private methods or any
package-private methods.


Methods defined in anonymous classes are not counted towards any totals.
Counts only go towards the main type declaration parent, and are kept separate from it's
children's inner types.



public class ExampleClass {
public enum Colors {
RED, GREEN, YELLOW;

public String getRGB() { ... } // NOT counted towards ExampleClass
}

public void example() { // counted towards ExampleClass
Runnable r = (new Runnable() {
public void run() { ... } // NOT counted towards ExampleClass, won't produce any violations
});
}

public static class InnerExampleClass {
protected void example2() { ... } // NOT counted towards ExampleClass,
// but counted towards InnerExampleClass
}
}

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
