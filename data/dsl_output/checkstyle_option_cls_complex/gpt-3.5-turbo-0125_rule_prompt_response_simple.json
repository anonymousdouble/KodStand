{
    "PackageDeclaration": [
        "Analyze the following CheckStyle Rule and DSL representation parsed using given grammar, please delete unexisted OptionName. \n\n1. Analyze whether each sentence of descriptions of CheckStyle Rule is a rule or not. If it is a rule, parsing it as a rule using the given Grammar. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. \n2. For each option that is not data specification, for each value, please parse it as a rule using giving Grammar. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.\n3. For each option that is data specification, please provide the option type, value range, default value. \n4. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nPackageDeclaration\nDescription\n\nEnsures that a class has a package declaration, and (optionally) whether\nthe package name matches the directory name for the source file.\n\n\nRationale: Classes that live in the null package cannot be\nimported. Many novice developers are not aware of this.\n\n\nPackages provide logical namespace to classes and should be stored in\nthe form of directory levels to provide physical grouping to your classes.\nThese directories are added to the classpath so that your classes\nare visible to JVM when it runs the code.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nmatchDirectoryStructure\nControl whether to check for directory and package name match.\nboolean\ntrue\n7.6.1\n\nAnswer about Options are data specifications or not\nNone\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, respond like: \nFinal RuleSet Representation:\nBasic Rule:\nMandatory: Order of [import groups] is {{customImportOrderRules}}\nAnd\nMandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]\n\nOption Rule:\nseparateLineBetweenGroups option:\ntrue: Mandatory: [empty line] between [import groups]\nfalse: Optional: [empty line] not between [import groups]\n\nsortImportsInGroupAlphabetically option:\ntrue: Mandatory: Order of [imports] of [import group] is [ASCII sort order]\nfalse: Optional: Order of [imports] of [import group] is not [ASCII sort order]\n\nOptions that are data specifications:\n{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};\n{{thirdPartyPackageRegExp}}: Pattern; RegExp; \u201c.*\u201d;\n\nFinal RuleSet Representation:\n[block] of {{tokens}} have [Brace]\n\nOption Rule:\nallowEmptyLoopBody option:\nfalse: Mandatory: [body] of [loop statement] is not [Null]\ntrue: Optional: [body] of [loop statement] is [Null]\n\nallowSingleLineStatement option:\nfalse: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 \u2014> [body] of {{tokens}} have [Brace]\ntrue: Optional: Number of [statement] of [body] of [{{tokens}} is 1 \u2014> [body] of {{tokens}} not have [Brace]\n\nOptions that are data specifications:\ntokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};\n\n\nResponse Format:\nIf there is no option, you only give basic rule\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOtherwise,\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOption Rule:\n...\n\nOptions that are data specifications:\n...\n",
        "Final RuleSet Representation:\nBasic Rule:\nMandatory: Order of [PackageDeclaration] is [PackageDeclaration]\nAnd\nOptional: [PackageDeclaration] match [DirectoryStructure]\n\nOptions that are data specifications:\nNone"
    ],
    "VisibilityModifier": [
        "Analyze the following CheckStyle Rule and DSL representation parsed using given grammar, please delete unexisted OptionName. \n\n1. Analyze whether each sentence of descriptions of CheckStyle Rule is a rule or not. If it is a rule, parsing it as a rule using the given Grammar. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. \n2. For each option that is not data specification, for each value, please parse it as a rule using giving Grammar. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.\n3. For each option that is data specification, please provide the option type, value range, default value. \n4. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nVisibilityModifier\nDescription\n\nChecks visibility of class members. Only static final, immutable or annotated\nby specified annotation members may be public; other class members must be private\nunless the property protectedAllowed or packageAllowed is set.\n\n\nPublic members are not flagged if the name matches the public\nmember regular expression (contains \"^serialVersionUID$\" by default).\n\nNote that\nCheckstyle 2 used to include \"^f[A-Z][a-zA-Z0-9]*$\" in the default\npattern to allow names used in container-managed persistence for Enterprise JavaBeans\n(EJB) 1.1 with the default settings. With EJB 2.0 it is no longer necessary to have\npublic access for persistent fields, so the default has been changed.\n\n\nRationale: Enforce encapsulation.\n\n\nCheck also has options making it less strict:\n\n\nignoreAnnotationCanonicalNames - the list of annotations which ignore variables\nin consideration. If user want to provide short annotation name that type\nwill match to any named the same type without consideration of package.\n\n\nallowPublicFinalFields - which allows public final fields.\n\n\nallowPublicImmutableFields - which allows immutable fields to be declared as\npublic if defined in final class.\n\n\nField is known to be immutable if:\n\n\nIt's declared as final\n\nHas either a primitive type or instance of class user defined to be immutable\n(such as String, ImmutableCollection from Guava, etc.)\n\n\n\nClasses known to be immutable are listed in immutableClassCanonicalNames by their\ncanonical names.\n\n\nProperty Rationale: Forcing all fields of class to have private modifier by default is\ngood in most cases, but in some cases it drawbacks in too much boilerplate get/set code.\nOne of such cases are immutable classes.\n\n\nRestriction: Check doesn't check if class is immutable, there's no\nchecking if accessory methods are missing and all fields are immutable, we only check\nif current field is immutable or final. Under the flag\nallowPublicImmutableFields, the enclosing class must also be final, to encourage\nimmutability. Under the flag allowPublicFinalFields, the final modifier on\nthe enclosing class is optional.\n\n\nStar imports are out of scope of this Check. So if one of type imported via\nstar import collides with user specified one by its short name -\nthere won't be Check's violation.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nallowPublicFinalFields\nAllow final fields to be declared as public.\nboolean\nfalse\n7.0\n\n\nallowPublicImmutableFields\nAllow immutable fields to be declared as public if defined in final class.\nboolean\nfalse\n6.4\n\n\nignoreAnnotationCanonicalNames\nSpecify annotations canonical names which ignore variables in consideration.\nString[]\ncom.google.common.annotations.VisibleForTesting, org.junit.ClassRule, org.junit.Rule\n6.5\n\n\nimmutableClassCanonicalNames\nSpecify immutable classes canonical names.\nString[]\njava.io.File, java.lang.Boolean, java.lang.Byte, java.lang.Character, java.lang.Double, java.lang.Float, java.lang.Integer, java.lang.Long, java.lang.Short, java.lang.StackTraceElement, java.lang.String, java.math.BigDecimal, java.math.BigInteger, java.net.Inet4Address, java.net.Inet6Address, java.net.InetSocketAddress, java.net.URI, java.net.URL, java.util.Locale, java.util.UUID\n6.4.1\n\n\npackageAllowed\nControl whether package visible members are allowed.\nboolean\nfalse\n3.0\n\n\nprotectedAllowed\nControl whether protected members are allowed.\nboolean\nfalse\n3.0\n\n\npublicMemberPattern\nSpecify pattern for public members that should be ignored.\nPattern\n\"^serialVersionUID$\"\n3.0\n\nAnswer about Options are data specifications or not\nNone\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, respond like: \nFinal RuleSet Representation:\nBasic Rule:\nMandatory: Order of [import groups] is {{customImportOrderRules}}\nAnd\nMandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]\n\nOption Rule:\nseparateLineBetweenGroups option:\ntrue: Mandatory: [empty line] between [import groups]\nfalse: Optional: [empty line] not between [import groups]\n\nsortImportsInGroupAlphabetically option:\ntrue: Mandatory: Order of [imports] of [import group] is [ASCII sort order]\nfalse: Optional: Order of [imports] of [import group] is not [ASCII sort order]\n\nOptions that are data specifications:\n{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};\n{{thirdPartyPackageRegExp}}: Pattern; RegExp; \u201c.*\u201d;\n\nFinal RuleSet Representation:\n[block] of {{tokens}} have [Brace]\n\nOption Rule:\nallowEmptyLoopBody option:\nfalse: Mandatory: [body] of [loop statement] is not [Null]\ntrue: Optional: [body] of [loop statement] is [Null]\n\nallowSingleLineStatement option:\nfalse: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 \u2014> [body] of {{tokens}} have [Brace]\ntrue: Optional: Number of [statement] of [body] of [{{tokens}} is 1 \u2014> [body] of {{tokens}} not have [Brace]\n\nOptions that are data specifications:\ntokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};\n\n\nResponse Format:\nIf there is no option, you only give basic rule\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOtherwise,\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOption Rule:\n...\n\nOptions that are data specifications:\n...\n",
        "Final RuleSet Representation:\nBasic Rule:\nMandatory: Order of [class members] is {{VisibilityModifier}}\nAnd\nMandatory: {{VisibilityModifier}} not have [public members] -> [private members]\n\nOption Rule:\nNone\n\nOptions that are data specifications:\nVisibilityModifier: String[]; {static final, immutable, specified annotation}; {};"
    ],
    "Indentation": [
        "Analyze the following CheckStyle Rule and DSL representation parsed using given grammar, please delete unexisted OptionName. \n\n1. Analyze whether each sentence of descriptions of CheckStyle Rule is a rule or not. If it is a rule, parsing it as a rule using the given Grammar. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. \n2. For each option that is not data specification, for each value, please parse it as a rule using giving Grammar. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.\n3. For each option that is data specification, please provide the option type, value range, default value. \n4. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nIndentation\nDescription\n\nChecks correct indentation of Java code.\n\n\nThe idea behind this is that while pretty printers are\nsometimes convenient for bulk reformats of legacy code, they often\neither aren't configurable enough or just can't anticipate how\nformat should be done. Sometimes this is personal preference, other\ntimes it is practical experience. In any case, this check should\njust ensure that a minimal set of indentation rules is followed.\n\n\nBasic offset indentation is used for indentation inside code blocks.\nFor any lines that span more than 1, line wrapping indentation is used for those\nlines after the first.\nBrace adjustment, case, and throws indentations are all used only if those specific\nidentifiers start the line. If, for example, a brace is used in the middle of the line,\nits indentation will not take effect.\nAll indentations have an accumulative/recursive effect when they are triggered. If\nduring a line wrapping, another code block is found and it doesn't end on that same\nline, then the subsequent lines afterwards, in that new code block, are increased on\ntop of the line wrap and any indentations above it.\n\nExample:\n\n\nif ((condition1 && condition2)\n|| (condition3 && condition4)    // line wrap with bigger indentation\n||!(condition5 && condition6)) { // line wrap with bigger indentation\nfield.doSomething()                    // basic offset\n.doSomething()                     // line wrap\n.doSomething( c -> {               // line wrap\nreturn c.doSome();               // basic offset\n});\n}\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\narrayInitIndent\nSpecify how far an array initialization should be indented when on next line.\nint\n4\n5.8\n\n\nbasicOffset\nSpecify how far new indentation level should be indented when on the next line.\nint\n4\n3.1\n\n\nbraceAdjustment\nSpecify how far a braces should be indented when on the next line.\nint\n0\n3.1\n\n\ncaseIndent\nSpecify how far a case label should be indented when on next line.\nint\n4\n3.1\n\n\nforceStrictCondition\nForce strict indent level in line wrapping case. If value is true, line wrap indent have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like.\nboolean\nfalse\n6.3\n\n\nlineWrappingIndentation\nSpecify how far continuation line should be indented when line-wrapping is present.\nint\n4\n5.9\n\n\nthrowsIndent\nSpecify how far a throws clause should be indented when on next line.\nint\n4\n5.7\n\nAnswer about Options are data specifications or not\nNone\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, respond like: \nFinal RuleSet Representation:\nBasic Rule:\nMandatory: Order of [import groups] is {{customImportOrderRules}}\nAnd\nMandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]\n\nOption Rule:\nseparateLineBetweenGroups option:\ntrue: Mandatory: [empty line] between [import groups]\nfalse: Optional: [empty line] not between [import groups]\n\nsortImportsInGroupAlphabetically option:\ntrue: Mandatory: Order of [imports] of [import group] is [ASCII sort order]\nfalse: Optional: Order of [imports] of [import group] is not [ASCII sort order]\n\nOptions that are data specifications:\n{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};\n{{thirdPartyPackageRegExp}}: Pattern; RegExp; \u201c.*\u201d;\n\nFinal RuleSet Representation:\n[block] of {{tokens}} have [Brace]\n\nOption Rule:\nallowEmptyLoopBody option:\nfalse: Mandatory: [body] of [loop statement] is not [Null]\ntrue: Optional: [body] of [loop statement] is [Null]\n\nallowSingleLineStatement option:\nfalse: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 \u2014> [body] of {{tokens}} have [Brace]\ntrue: Optional: Number of [statement] of [body] of [{{tokens}} is 1 \u2014> [body] of {{tokens}} not have [Brace]\n\nOptions that are data specifications:\ntokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};\n\n\nResponse Format:\nIf there is no option, you only give basic rule\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOtherwise,\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOption Rule:\n...\n\nOptions that are data specifications:\n...\n",
        "Final RuleSet Representation:\nBasic Rule:\nMandatory: Order of [arrayInitIndent] is [int] >= 4\nAnd\nMandatory: Order of [basicOffset] is [int] >= 4\nAnd\nMandatory: Order of [braceAdjustment] is [int] >= 0\nAnd\nMandatory: Order of [caseIndent] is [int] >= 4\nAnd\nMandatory: Order of [forceStrictCondition] is [boolean] = false\nAnd\nMandatory: Order of [lineWrappingIndentation] is [int] >= 4\nAnd\nMandatory: Order of [throwsIndent] is [int] >= 4\n\nOption Rule:\narrayInitIndent option:\n4: Mandatory: [array initialization] of [arrayInitIndent] is [int] >= 4\n\nbasicOffset option:\n4: Mandatory: [new indentation level] of [basicOffset] is [int] >= 4\n\nbraceAdjustment option:\n0: Mandatory: [braces] of [braceAdjustment] is [int] >= 0\n\ncaseIndent option:\n4: Mandatory: [case label] of [caseIndent] is [int] >= 4\n\nforceStrictCondition option:\nfalse: Mandatory: [line wrap indent] of [forceStrictCondition] is [boolean] = false\n\nlineWrappingIndentation option:\n4: Mandatory: [continuation line] of [lineWrappingIndentation] is [int] >= 4\n\nthrowsIndent option:\n4: Mandatory: [throws clause] of [throwsIndent] is [int] >= 4\n\nOptions that are data specifications:\narrayInitIndent: int; >= 0; 4\nbasicOffset: int; >= 0; 4\nbraceAdjustment: int; >= 0; 0\ncaseIndent: int; >= 0; 4\nforceStrictCondition: boolean; {true, false}; false\nlineWrappingIndentation: int; >= 0; 4\nthrowsIndent: int; >= 0; 4"
    ],
    "OneTopLevelClass": [
        "Analyze the following CheckStyle Rule and DSL representation parsed using given grammar, please delete unexisted OptionName. \n\n1. Analyze whether each sentence of descriptions of CheckStyle Rule is a rule or not. If it is a rule, parsing it as a rule using the given Grammar. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. \n2. For each option that is not data specification, for each value, please parse it as a rule using giving Grammar. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.\n3. For each option that is data specification, please provide the option type, value range, default value. \n4. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nOneTopLevelClass\nDescription\n\nChecks that each top-level class, interface, enum\nor annotation resides in a source file of its own.\nOfficial description of a 'top-level' term:\n7.6. Top Level Type Declarations.\nIf file doesn't contain public class, interface, enum or annotation,\ntop-level type is the first type in file.\n\nAnswer about Options are data specifications or not\nNone\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, respond like: \nFinal RuleSet Representation:\nBasic Rule:\nMandatory: Order of [import groups] is {{customImportOrderRules}}\nAnd\nMandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]\n\nOption Rule:\nseparateLineBetweenGroups option:\ntrue: Mandatory: [empty line] between [import groups]\nfalse: Optional: [empty line] not between [import groups]\n\nsortImportsInGroupAlphabetically option:\ntrue: Mandatory: Order of [imports] of [import group] is [ASCII sort order]\nfalse: Optional: Order of [imports] of [import group] is not [ASCII sort order]\n\nOptions that are data specifications:\n{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};\n{{thirdPartyPackageRegExp}}: Pattern; RegExp; \u201c.*\u201d;\n\nFinal RuleSet Representation:\n[block] of {{tokens}} have [Brace]\n\nOption Rule:\nallowEmptyLoopBody option:\nfalse: Mandatory: [body] of [loop statement] is not [Null]\ntrue: Optional: [body] of [loop statement] is [Null]\n\nallowSingleLineStatement option:\nfalse: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 \u2014> [body] of {{tokens}} have [Brace]\ntrue: Optional: Number of [statement] of [body] of [{{tokens}} is 1 \u2014> [body] of {{tokens}} not have [Brace]\n\nOptions that are data specifications:\ntokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};\n\n\nResponse Format:\nIf there is no option, you only give basic rule\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOtherwise,\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOption Rule:\n...\n\nOptions that are data specifications:\n...\n",
        "Final RuleSet Representation:\nBasic Rule:\nMandatory: Order of [top-level type declarations] is [each in its own source file]\n\nOptions that are data specifications:\nNone"
    ],
    "MissingDeprecated": [
        "Analyze the following CheckStyle Rule and DSL representation parsed using given grammar, please delete unexisted OptionName. \n\n1. Analyze whether each sentence of descriptions of CheckStyle Rule is a rule or not. If it is a rule, parsing it as a rule using the given Grammar. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. \n2. For each option that is not data specification, for each value, please parse it as a rule using giving Grammar. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.\n3. For each option that is data specification, please provide the option type, value range, default value. \n4. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nMissingDeprecated\nDescription\n\nVerifies that the annotation @Deprecated and the Javadoc tag\n@deprecated are both present when either of them is present.\n\n\nBoth ways of flagging deprecation serve their own purpose.\nThe @Deprecated annotation is used for compilers and development tools.\nThe @deprecated javadoc tag is used to document why something is deprecated\nand what, if any, alternatives exist.\n\n\nIn order to properly mark something as deprecated both forms of\ndeprecation should be present.\n\n\nPackage deprecation is an exception to the rule of always using the\njavadoc tag and annotation to deprecate.  It is not clear if the\njavadoc tool will support it or not as newer versions keep flip-flopping\non if it is supported or will cause an error.\nSee\nJDK-8160601.\nThe deprecated javadoc tag is currently the only way to say why the package\nis deprecated and what to use instead.  Until this is resolved, if you\ndon't want to print violations on package-info, you can use a\nfilter to ignore these files until\nthe javadoc tool faithfully supports it. An example config using\nSuppressionSingleFilter is:\n\n\n\n<!-- required till https://bugs.openjdk.org/browse/JDK-8160601 -->\n<module name=\"SuppressionSingleFilter\">\n<property name=\"checks\" value=\"MissingDeprecatedCheck\"/>\n<property name=\"files\" value=\"package-info\\.java\"/>\n</module>\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nviolateExecutionOnNonTightHtml\nControl when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules.\nboolean\nfalse\n8.24\n\nAnswer about Options are data specifications or not\nNone\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, respond like: \nFinal RuleSet Representation:\nBasic Rule:\nMandatory: Order of [import groups] is {{customImportOrderRules}}\nAnd\nMandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]\n\nOption Rule:\nseparateLineBetweenGroups option:\ntrue: Mandatory: [empty line] between [import groups]\nfalse: Optional: [empty line] not between [import groups]\n\nsortImportsInGroupAlphabetically option:\ntrue: Mandatory: Order of [imports] of [import group] is [ASCII sort order]\nfalse: Optional: Order of [imports] of [import group] is not [ASCII sort order]\n\nOptions that are data specifications:\n{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};\n{{thirdPartyPackageRegExp}}: Pattern; RegExp; \u201c.*\u201d;\n\nFinal RuleSet Representation:\n[block] of {{tokens}} have [Brace]\n\nOption Rule:\nallowEmptyLoopBody option:\nfalse: Mandatory: [body] of [loop statement] is not [Null]\ntrue: Optional: [body] of [loop statement] is [Null]\n\nallowSingleLineStatement option:\nfalse: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 \u2014> [body] of {{tokens}} have [Brace]\ntrue: Optional: Number of [statement] of [body] of [{{tokens}} is 1 \u2014> [body] of {{tokens}} not have [Brace]\n\nOptions that are data specifications:\ntokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};\n\n\nResponse Format:\nIf there is no option, you only give basic rule\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOtherwise,\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOption Rule:\n...\n\nOptions that are data specifications:\n...\n",
        "Final RuleSet Representation:\nBasic Rule:\nMandatory: Order of [annotation @Deprecated] is [present]\nAnd\nMandatory: Order of [Javadoc tag @deprecated] is [present]\n\nOption Rule:\nviolateExecutionOnNonTightHtml option:\ntrue: Mandatory: [Javadoc] violates [tight html rules] -> [print violations]\nfalse: Optional: [Javadoc] not violates [tight html rules]\n\nOptions that are data specifications:\nNone"
    ],
    "JavadocVariable": [
        "Analyze the following CheckStyle Rule and DSL representation parsed using given grammar, please delete unexisted OptionName. \n\n1. Analyze whether each sentence of descriptions of CheckStyle Rule is a rule or not. If it is a rule, parsing it as a rule using the given Grammar. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. \n2. For each option that is not data specification, for each value, please parse it as a rule using giving Grammar. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.\n3. For each option that is data specification, please provide the option type, value range, default value. \n4. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nJavadocVariable\nDescription\n\nChecks that a variable has a Javadoc comment. Ignores serialVersionUID\nfields.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nexcludeScope\nSpecify the visibility scope where Javadoc comments are not checked.\nScope\nnull\n3.4\n\n\nignoreNamePattern\nSpecify the regexp to define variable names to ignore.\nPattern\nnull\n5.8\n\n\nscope\nSpecify the visibility scope where Javadoc comments are checked.\nScope\nprivate\n3.0\n\n\ntokens\ntokens to check\nsubset of tokens\n\nENUM_CONSTANT_DEF\n.\n\n\n\nENUM_CONSTANT_DEF\n.\n\n3.0\n\nAnswer about Options are data specifications or not\nNone\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, respond like: \nFinal RuleSet Representation:\nBasic Rule:\nMandatory: Order of [import groups] is {{customImportOrderRules}}\nAnd\nMandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]\n\nOption Rule:\nseparateLineBetweenGroups option:\ntrue: Mandatory: [empty line] between [import groups]\nfalse: Optional: [empty line] not between [import groups]\n\nsortImportsInGroupAlphabetically option:\ntrue: Mandatory: Order of [imports] of [import group] is [ASCII sort order]\nfalse: Optional: Order of [imports] of [import group] is not [ASCII sort order]\n\nOptions that are data specifications:\n{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};\n{{thirdPartyPackageRegExp}}: Pattern; RegExp; \u201c.*\u201d;\n\nFinal RuleSet Representation:\n[block] of {{tokens}} have [Brace]\n\nOption Rule:\nallowEmptyLoopBody option:\nfalse: Mandatory: [body] of [loop statement] is not [Null]\ntrue: Optional: [body] of [loop statement] is [Null]\n\nallowSingleLineStatement option:\nfalse: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 \u2014> [body] of {{tokens}} have [Brace]\ntrue: Optional: Number of [statement] of [body] of [{{tokens}} is 1 \u2014> [body] of {{tokens}} not have [Brace]\n\nOptions that are data specifications:\ntokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};\n\n\nResponse Format:\nIf there is no option, you only give basic rule\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOtherwise,\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOption Rule:\n...\n\nOptions that are data specifications:\n...\n",
        "Final RuleSet Representation:\nBasic Rule:\nMandatory: Order of [tokens] is {{ENUM_CONSTANT_DEF}}\nAnd\nMandatory: {{ENUM_CONSTANT_DEF}} not have [ENUM_CONSTANT_DEF] -> [ENUM_CONSTANT_DEF]\n\nOptions that are data specifications:\n{{ENUM_CONSTANT_DEF}}: Scope; {private, protected, public, package}; {private}"
    ],
    "NoEnumTrailingComma": [
        "Analyze the following CheckStyle Rule and DSL representation parsed using given grammar, please delete unexisted OptionName. \n\n1. Analyze whether each sentence of descriptions of CheckStyle Rule is a rule or not. If it is a rule, parsing it as a rule using the given Grammar. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. \n2. For each option that is not data specification, for each value, please parse it as a rule using giving Grammar. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.\n3. For each option that is data specification, please provide the option type, value range, default value. \n4. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nNoEnumTrailingComma\nDescription\n\nChecks that enum definition does not contain a trailing comma.\nRationale: JLS allows trailing commas in arrays and enumerations, but does not allow\nthem in other locations. To unify the coding style, the use of trailing commas should\nbe prohibited.\n\n\n\nenum Foo1 {\nFOO,\nBAR;\n}\n\n\nThe check demands that there should not be any comma after last constant in\nenum definition.\n\n\n\nenum Foo1 {\nFOO,\nBAR, //violation\n}\n\nAnswer about Options are data specifications or not\nNone\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, respond like: \nFinal RuleSet Representation:\nBasic Rule:\nMandatory: Order of [import groups] is {{customImportOrderRules}}\nAnd\nMandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]\n\nOption Rule:\nseparateLineBetweenGroups option:\ntrue: Mandatory: [empty line] between [import groups]\nfalse: Optional: [empty line] not between [import groups]\n\nsortImportsInGroupAlphabetically option:\ntrue: Mandatory: Order of [imports] of [import group] is [ASCII sort order]\nfalse: Optional: Order of [imports] of [import group] is not [ASCII sort order]\n\nOptions that are data specifications:\n{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};\n{{thirdPartyPackageRegExp}}: Pattern; RegExp; \u201c.*\u201d;\n\nFinal RuleSet Representation:\n[block] of {{tokens}} have [Brace]\n\nOption Rule:\nallowEmptyLoopBody option:\nfalse: Mandatory: [body] of [loop statement] is not [Null]\ntrue: Optional: [body] of [loop statement] is [Null]\n\nallowSingleLineStatement option:\nfalse: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 \u2014> [body] of {{tokens}} have [Brace]\ntrue: Optional: Number of [statement] of [body] of [{{tokens}} is 1 \u2014> [body] of {{tokens}} not have [Brace]\n\nOptions that are data specifications:\ntokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};\n\n\nResponse Format:\nIf there is no option, you only give basic rule\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOtherwise,\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOption Rule:\n...\n\nOptions that are data specifications:\n...\n",
        "Final RuleSet Representation:\nBasic Rule:\nMandatory: Order of [enum constants] not have [comma] at end of [enum definition]\n\nOptions that are data specifications:\nNone"
    ],
    "UniqueProperties": [
        "Analyze the following CheckStyle Rule and DSL representation parsed using given grammar, please delete unexisted OptionName. \n\n1. Analyze whether each sentence of descriptions of CheckStyle Rule is a rule or not. If it is a rule, parsing it as a rule using the given Grammar. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. \n2. For each option that is not data specification, for each value, please parse it as a rule using giving Grammar. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.\n3. For each option that is data specification, please provide the option type, value range, default value. \n4. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nUniqueProperties\nDescription\n\nDetects duplicated keys in properties files.\n\n\nRationale: Multiple property keys usually appear after merge\nor rebase of several branches. While there are no problems in\nruntime, there can be a confusion due to having different values\nfor the duplicated properties.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nfileExtensions\nSpecify the file extensions of the files to process.\nString[]\n.properties\n5.7\n\nAnswer about Options are data specifications or not\nNone\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, respond like: \nFinal RuleSet Representation:\nBasic Rule:\nMandatory: Order of [import groups] is {{customImportOrderRules}}\nAnd\nMandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]\n\nOption Rule:\nseparateLineBetweenGroups option:\ntrue: Mandatory: [empty line] between [import groups]\nfalse: Optional: [empty line] not between [import groups]\n\nsortImportsInGroupAlphabetically option:\ntrue: Mandatory: Order of [imports] of [import group] is [ASCII sort order]\nfalse: Optional: Order of [imports] of [import group] is not [ASCII sort order]\n\nOptions that are data specifications:\n{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};\n{{thirdPartyPackageRegExp}}: Pattern; RegExp; \u201c.*\u201d;\n\nFinal RuleSet Representation:\n[block] of {{tokens}} have [Brace]\n\nOption Rule:\nallowEmptyLoopBody option:\nfalse: Mandatory: [body] of [loop statement] is not [Null]\ntrue: Optional: [body] of [loop statement] is [Null]\n\nallowSingleLineStatement option:\nfalse: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 \u2014> [body] of {{tokens}} have [Brace]\ntrue: Optional: Number of [statement] of [body] of [{{tokens}} is 1 \u2014> [body] of {{tokens}} not have [Brace]\n\nOptions that are data specifications:\ntokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};\n\n\nResponse Format:\nIf there is no option, you only give basic rule\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOtherwise,\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOption Rule:\n...\n\nOptions that are data specifications:\n...\n",
        "Final RuleSet Representation:\nBasic Rule:\nMandatory: Order of [Properties] is [UniqueProperties]\nAnd\nMandatory: [UniqueProperties] not have [a property] -> [the property] at end of [Properties]\n\nOptions that are data specifications:\nUniqueProperties: String[]; {}; {};\n\nfileExtensions: String[]; {}; {\".properties\"}; {5.7}"
    ],
    "JavadocTagContinuationIndentation": [
        "Analyze the following CheckStyle Rule and DSL representation parsed using given grammar, please delete unexisted OptionName. \n\n1. Analyze whether each sentence of descriptions of CheckStyle Rule is a rule or not. If it is a rule, parsing it as a rule using the given Grammar. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. \n2. For each option that is not data specification, for each value, please parse it as a rule using giving Grammar. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.\n3. For each option that is data specification, please provide the option type, value range, default value. \n4. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nJavadocTagContinuationIndentation\nDescription\n\nChecks the indentation of the continuation lines in block tags.\nThat is whether the\ncontinued description of at clauses should be indented or not. If the text is not properly\nindented it throws a violation. A continuation line is when the description starts/spans\npast the line with the tag. Default indentation required is at least 4, but this can be\nchanged with the help of properties below.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\noffset\nSpecify how many spaces to use for new indentation level.\nint\n4\n6.0\n\n\nviolateExecutionOnNonTightHtml\nControl when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules.\nboolean\nfalse\n8.3\n\nAnswer about Options are data specifications or not\nNone\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, respond like: \nFinal RuleSet Representation:\nBasic Rule:\nMandatory: Order of [import groups] is {{customImportOrderRules}}\nAnd\nMandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]\n\nOption Rule:\nseparateLineBetweenGroups option:\ntrue: Mandatory: [empty line] between [import groups]\nfalse: Optional: [empty line] not between [import groups]\n\nsortImportsInGroupAlphabetically option:\ntrue: Mandatory: Order of [imports] of [import group] is [ASCII sort order]\nfalse: Optional: Order of [imports] of [import group] is not [ASCII sort order]\n\nOptions that are data specifications:\n{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};\n{{thirdPartyPackageRegExp}}: Pattern; RegExp; \u201c.*\u201d;\n\nFinal RuleSet Representation:\n[block] of {{tokens}} have [Brace]\n\nOption Rule:\nallowEmptyLoopBody option:\nfalse: Mandatory: [body] of [loop statement] is not [Null]\ntrue: Optional: [body] of [loop statement] is [Null]\n\nallowSingleLineStatement option:\nfalse: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 \u2014> [body] of {{tokens}} have [Brace]\ntrue: Optional: Number of [statement] of [body] of [{{tokens}} is 1 \u2014> [body] of {{tokens}} not have [Brace]\n\nOptions that are data specifications:\ntokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};\n\n\nResponse Format:\nIf there is no option, you only give basic rule\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOtherwise,\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOption Rule:\n...\n\nOptions that are data specifications:\n...\n",
        "Final RuleSet Representation:\nBasic Rule:\nMandatory: Order of [block tags] is [JavadocTagContinuationIndentation]\nAnd\nMandatory: [JavadocTagContinuationIndentation] is >= [offset]\n\nOption Rule:\nviolateExecutionOnNonTightHtml option:\ntrue: Mandatory: [violateExecutionOnNonTightHtml] is [true]\nfalse: Optional: [violateExecutionOnNonTightHtml] is [false]\n\nOptions that are data specifications:\noffset: int; >=4; 4\nviolateExecutionOnNonTightHtml: boolean; {true, false}; false"
    ],
    "LambdaParameterName": [
        "Analyze the following CheckStyle Rule and DSL representation parsed using given grammar, please delete unexisted OptionName. \n\n1. Analyze whether each sentence of descriptions of CheckStyle Rule is a rule or not. If it is a rule, parsing it as a rule using the given Grammar. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. \n2. For each option that is not data specification, for each value, please parse it as a rule using giving Grammar. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.\n3. For each option that is data specification, please provide the option type, value range, default value. \n4. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nLambdaParameterName\nDescription\n\nChecks lambda parameter names.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nformat\nSets the pattern to match valid identifiers.\nPattern\n\"^[a-z][a-zA-Z0-9]*$\"\n8.11\n\nAnswer about Options are data specifications or not\nNone\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, respond like: \nFinal RuleSet Representation:\nBasic Rule:\nMandatory: Order of [import groups] is {{customImportOrderRules}}\nAnd\nMandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]\n\nOption Rule:\nseparateLineBetweenGroups option:\ntrue: Mandatory: [empty line] between [import groups]\nfalse: Optional: [empty line] not between [import groups]\n\nsortImportsInGroupAlphabetically option:\ntrue: Mandatory: Order of [imports] of [import group] is [ASCII sort order]\nfalse: Optional: Order of [imports] of [import group] is not [ASCII sort order]\n\nOptions that are data specifications:\n{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};\n{{thirdPartyPackageRegExp}}: Pattern; RegExp; \u201c.*\u201d;\n\nFinal RuleSet Representation:\n[block] of {{tokens}} have [Brace]\n\nOption Rule:\nallowEmptyLoopBody option:\nfalse: Mandatory: [body] of [loop statement] is not [Null]\ntrue: Optional: [body] of [loop statement] is [Null]\n\nallowSingleLineStatement option:\nfalse: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 \u2014> [body] of {{tokens}} have [Brace]\ntrue: Optional: Number of [statement] of [body] of [{{tokens}} is 1 \u2014> [body] of {{tokens}} not have [Brace]\n\nOptions that are data specifications:\ntokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};\n\n\nResponse Format:\nIf there is no option, you only give basic rule\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOtherwise,\nFinal RuleSet Representation:\nBasic Rule:\n...\n\nOption Rule:\n...\n\nOptions that are data specifications:\n...\n",
        "Final RuleSet Representation:\nBasic Rule:\nMandatory: Order of [LambdaParameterName] is [format]\n\nOptions that are data specifications:\nLambdaParameterName: Pattern; \"^[a-z][a-zA-Z0-9]*$\"; "
    ]
}