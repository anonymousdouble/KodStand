Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.6.2 Horizontal whitespace
Beyond where required by the language or other style rules, and apart from literals, comments and Javadoc, a single ASCII space also appears in the following places only .
 Separating any reserved word, such as `if` , `for` or `catch` , from an open parenthesis ( `(` ) that follows it on that line 
 Separating any reserved word, such as `else` or `catch` , from a closing curly brace ( `}` ) that precedes it on that line 
 Before any open curly brace ( `{` ), with two exceptions: 
 `@SomeAnnotation({a,b})` (no space is used) 
 `String[][]x={{"foo"}};` (no space is required between `{{` , by item 9 below) 
 On both sides of any binary or ternary operator. This also applies to the following "operator-like" symbols: 
 the ampersand in a conjunctive type bound: `<TextendsFoo&Bar>` 
 the pipe for a catch block that handles multiple exceptions: `catch(FooException|BarExceptione)` 
 the colon ( `:` ) in an enhanced `for` ("foreach") statement 
 the arrow in a lambda expression: `(Stringstr)->str.length()` 
 but not 
 the two colons ( `::` ) of a method reference, which is written like `Object::toString` 
 the dot separator ( `.` ), which is written like `object.toString()` 
 After `,:;` or the closing parenthesis ( `)` ) of a cast 
 Between any content and a double slash ( `//` ) which begins a comment. Multiple spaces are allowed. 
 Between a double slash ( `//` ) which begins a comment and the comment's text. Multiple spaces are allowed. 
 Between the type and variable of a declaration: `List<String>list` 
 Optional just inside both braces of an array initializer 
 `newint[]{5,6}` and `newint[]{5,6}` are both valid 
 Between a type annotation and `[]` or `...` .
 This rule is never interpreted as requiring or forbidding additional space at the start or end of a line; it addresses only interior space.

CheckStyle Rules:
[Rule]
SingleSpaceSeparator
[Description]
Checks that non-whitespace characters are separated by no more than one
whitespace. Separating characters by tabs or multiple spaces will be
reported. Currently, the check doesn't permit horizontal alignment. To inspect
whitespaces before and after comments, set the property
validateComments to true.


Setting validateComments to false will ignore cases like:



int i;  // Multiple whitespaces before comment tokens will be ignored.
private void foo(int  /* whitespaces before and after block-comments will be
ignored */  i) {


Sometimes, users like to space similar items on different lines to the same
column position for easier reading. This feature isn't supported by this
check, so both braces in the following case will be reported as violations.



public long toNanos(long d)  { return d;             } // 2 violations
public long toMicros(long d) { return d / (C1 / C0); }
[Rule]
GenericWhitespace
[Description]
Checks that the whitespace around the Generic tokens (angle brackets)
"<" and ">" are correct to the typical convention.
The convention is not configurable.


Left angle bracket ("<"):


should be preceded with whitespace only in generic methods definitions.
should not be preceded with whitespace when it is preceded method name
or constructor.
should not be preceded with whitespace when following type name.
should not be followed with whitespace in all cases.


Right angle bracket (">"):


should not be preceded with whitespace in all cases.
should be followed with whitespace in almost all cases, except diamond operators
and when preceding a method name, constructor, or record header.
[Rule]
WhitespaceAround
[Description]
Checks that a token is surrounded by whitespace. Empty constructor,
method, class, enum, interface, loop bodies (blocks), lambdas of the form


public MyClass() {}      // empty constructor
public void func() {}    // empty method
public interface Foo {} // empty interface
public class Foo {} // empty class
public enum Foo {} // empty enum
MyClass c = new MyClass() {}; // empty anonymous class
while (i = 1) {} // empty while loop
for (int i = 1; i > 1; i++) {} // empty for loop
do {} while (i = 1); // empty do-while loop
Runnable noop = () -> {}; // empty lambda
public @interface Beta {} // empty annotation type


may optionally be exempted from the policy using the
allowEmptyMethods, allowEmptyConstructors,
allowEmptyTypes, allowEmptyLoops,
allowEmptyLambdas and allowEmptyCatches
properties.

This check does not flag as violation double brace initialization like:



new Properties() {{
setProperty("key", "value");
}};


Parameter allowEmptyCatches allows to suppress violations when token
list contains SLIST to check if beginning of block is surrounded by
whitespace and catch block is empty, for example:



try {
k = 5 / i;
} catch (ArithmeticException ex) {}



With this property turned off, this raises violation because the beginning of the
catch block (left curly bracket) is not separated from the end of the catch
block (right curly bracket).
[Rule]
JavadocMissingWhitespaceAfterAsterisk
[Description]
Checks that there is at least one whitespace after the leading asterisk.
Although spaces after asterisks are optional in the Javadoc comments, their absence
makes the documentation difficult to read. It is the de facto standard to put at least
one whitespace after the leading asterisk.
[Rule]
NoWhitespaceBefore
[Description]
Checks that there is no whitespace before a token. More
specifically, it checks that it is not preceded with whitespace, or
(if linebreaks are allowed) all characters on the line before are
whitespace. To allow linebreaks before a token, set property
allowLineBreaks to true. No check occurs
before semicolons in empty for loop initializers or conditions.
[Rule]
TrailingComment
[Description]
The check to ensure that lines with code do not end with comment.
For the case of // comments that means that the only thing
that should precede it is whitespace. It doesn't check comments if
they do not end a line; for example, it accepts the following:
Thread.sleep( 10 /*some comment here*/ ); Format
property is intended to deal with the } // while example.


Rationale: Steve McConnell in Code Complete suggests that
endline comments are a bad practice. An end line comment would be
one that is on the same line as actual code. For example:



a = b + c;      // Some insightful comment
d = e / f;        // Another comment for this line


Quoting Code Complete for the justification:


"The comments have to be aligned so that they do not
interfere with the visual structure of the code. If you don't align
them neatly, they'll make your listing look like it's been through a
washing machine."

"Endline comments tend to be hard to format...It takes
time to align them. Such time is not spent learning more about the
code; it's dedicated solely to the tedious task of pressing the
spacebar or tab key."

"Endline comments are also hard to maintain. If the code
on any line containing an endline comment grows, it bumps the
comment farther out, and all the other endline comments will have to
bumped out to match. Styles that are hard to maintain aren't
maintained...."

"Endline comments also tend to be cryptic. The right side
of the line doesn't offer much room and the desire to keep the
comment on one line means the comment must be short. Work then goes
into making the line as short as possible instead of as clear as
possible. The comment usually ends up as cryptic as
possible...."

"A systemic problem with endline comments is that it's
hard to write a meaningful comment for one line of code. Most
endline comments just repeat the line of code, which hurts more than
it helps."



McConnell's comments on being hard to maintain when the size of the line
changes are even more important in the age of automated
refactorings.
[Rule]
NoWhitespaceAfter
[Description]
Checks that there is no whitespace after a token. More specifically,
it checks that it is not followed by whitespace, or (if linebreaks
are allowed) all characters on the line after are whitespace. To
forbid linebreaks after a token, set property allowLineBreaks to
false.


The check processes

ARRAY_DECLARATOR
and
INDEX_OP
tokens specially from other tokens. Actually it is checked that there is
no whitespace before these tokens, not after them.
Space after the

ANNOTATIONS before

ARRAY_DECLARATOR
and

INDEX_OP
will be ignored.


If the annotation is between the type and the array,
like char @NotNull [] param, the check will skip
validation for spaces.


Note: This check processes the

LITERAL_SYNCHRONIZED token only when it appears as a part of a

synchronized statement, i.e. synchronized(this) {}.
[Rule]
Indentation
[Description]
Checks correct indentation of Java code.


The idea behind this is that while pretty printers are
sometimes convenient for bulk reformats of legacy code, they often
either aren't configurable enough or just can't anticipate how
format should be done. Sometimes this is personal preference, other
times it is practical experience. In any case, this check should
just ensure that a minimal set of indentation rules is followed.


Basic offset indentation is used for indentation inside code blocks.
For any lines that span more than 1, line wrapping indentation is used for those
lines after the first.
Brace adjustment, case, and throws indentations are all used only if those specific
identifiers start the line. If, for example, a brace is used in the middle of the line,
its indentation will not take effect.
All indentations have an accumulative/recursive effect when they are triggered. If
during a line wrapping, another code block is found and it doesn't end on that same
line, then the subsequent lines afterwards, in that new code block, are increased on
top of the line wrap and any indentations above it.

Example:


if ((condition1 && condition2)
|| (condition3 && condition4)    // line wrap with bigger indentation
||!(condition5 && condition6)) { // line wrap with bigger indentation
field.doSomething()                    // basic offset
.doSomething()                     // line wrap
.doSomething( c -> {               // line wrap
return c.doSome();               // basic offset
});
}
[Rule]
MethodParamPad
[Description]
Checks the padding between the identifier of a method definition,
constructor definition, method call, or constructor invocation; and
the left parenthesis of the parameter list. That is, if the
identifier and left parenthesis are on the same line, checks whether
a space is required immediately after the identifier or such a space
is forbidden. If they are not on the same line, reports a violation,
unless configured to allow line breaks. To allow linebreaks after
the identifier, set property allowLineBreaks to
true.
[Rule]
EmptyLineSeparator
[Description]
Checks for empty line separators before package, all import declarations,
fields, constructors, methods, nested classes,
static initializers and instance initializers.


Checks for empty line separators before not only statements but
implementation and documentation comments and blocks as well.


ATTENTION: empty line separator is required between token siblings,
not after line where token is found.
If token does not have a sibling of the same type, then empty line
is required at its end (for example for CLASS_DEF it is after '}').
Also, trailing comments are skipped.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
