{
    "Rulename\nPackageDeclaration\nDescription\n\nEnsures that a class has a package declaration, and (optionally) whether\nthe package name matches the directory name for the source file.\n\n\nRationale: Classes that live in the null package cannot be\nimported. Many novice developers are not aware of this.\n\n\nPackages provide logical namespace to classes and should be stored in\nthe form of directory levels to provide physical grouping to your classes.\nThese directories are added to the classpath so that your classes\nare visible to JVM when it runs the code.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nmatchDirectoryStructure\nControl whether to check for directory and package name match.\nboolean\ntrue\n7.6.1": [
        "Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\n1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. \n2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.\n3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nPackageDeclaration\nDescription\n\nEnsures that a class has a package declaration, and (optionally) whether\nthe package name matches the directory name for the source file.\n\n\nRationale: Classes that live in the null package cannot be\nimported. Many novice developers are not aware of this.\n\n\nPackages provide logical namespace to classes and should be stored in\nthe form of directory levels to provide physical grouping to your classes.\nThese directories are added to the classpath so that your classes\nare visible to JVM when it runs the code.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nmatchDirectoryStructure\nControl whether to check for directory and package name match.\nboolean\ntrue\n7.6.1\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 \nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\nCheckStyle Rule:\nRulename:\nNeedBraces\n\nDescription\nChecks for braces around code blocks.\n\nOptions:\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n\nFinal RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n",
        "Final RuleSet Representation:\nBasic Rule:\n{{PackageDeclaration}} has [Rulename]\n\nOption Rule:\nmatchDirectoryStructure option:\nFalse: Mandatory: [package name] of {{PackageDeclaration}} is not [match] [directory name]\nTrue: Optional: [package name] of {{PackageDeclaration}} is [match] [directory name]"
    ]
}