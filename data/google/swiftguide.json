[
    {
        "title": "Table of Contents",
        "belongs to": "Table of Contents",
        "cases": [
            {
                "description": "Source File Basics \nFile Names \nFile Encoding \nWhitespace Characters \nSpecial Escape Sequences \nInvisible Characters and Modifiers \nString Literals \nSource File Structure \nFile Comments \nImport Statements \nType, Variable, and Function Declarations \nOverloaded Declarations \nExtensions \nGeneral Formatting \nColumn Limit \nBraces \nSemicolons \nOne Statement Per Line \nLine-Wrapping \nFunction Declarations \nType and Extension Declarations \nFunction Calls \nControl Flow Statements \nOther Expressions \nHorizontal Whitespace \nHorizontal Alignment \nVertical Whitespace \nParentheses \nFormatting Specific Constructs \nNon-Documentation Comments \nProperties \nSwitch Statements \nEnum Cases \nTrailing Closures \nTrailing Commas \nNumeric Literals \nAttributes \nNaming \nApple‚Äôs API Style Guidelines \nNaming Conventions Are Not Access Control \nIdentifiers \nInitializers \nStatic and Class Properties \nGlobal Constants \nDelegate Methods \nProgramming Practices \nCompiler Warnings \nInitializers \nProperties \nTypes with Shorthand Names \nOptional Types \nError Types \nForce Unwrapping and Force Casts \nImplicitly Unwrapped Optionals \nAccess Levels \nNesting and Namespacing \nguards for Early Exits \nfor-where Loops \nfallthrough in switch Statements \nPattern Matching \nTuple Patterns \nNumeric and String Literals \nPlayground Literals \nTrapping vs. Overflowing Arithmetic \nDefining New Operators \nOverloading Existing Operators \nDocumentation Comments \nGeneral Format \nSingle-Sentence Summary \nParameter, Returns, and Throws Tags \nApple‚Äôs Markup Format \nWhere to Document"
            }
        ]
    },
    {
        "title": "Source File Basics",
        "belongs to": "Source File Basics",
        "cases": []
    },
    {
        "title": "File Names",
        "belongs to": "Source File Basics/File Names",
        "cases": [
            {
                "description": "All Swift source files end with the extension `.swift` .\nIn general, the name of a source file best describes the primary entity that it contains. A file that primarily contains a single type has the name of that type. A file that extends an existing type with protocol conformance is named with a combination of the type name and the protocol name, joined with a plus ( `+` ) sign. For more complex situations, exercise your best judgment.\nFor example,\nA file containing a single type `MyType` is named `MyType.swift` . \nA file containing a type `MyType` and some top-level helper functions is also named `MyType.swift` . (The top-level helpers are not the primary entity.) \nA file containing a single extension to a type `MyType` that adds conformance to a protocol `MyProtocol` is named `MyType+MyProtocol.swift` . \nA file containing multiple extensions to a type `MyType` that add conformances, nested types, or other functionality to a type can be named more generally, as long as it is prefixed with `MyType+` ; for example, `MyType+Additions.swift` . \nA file containing related declarations that are not otherwise scoped under a common type or namespace (such as a collection of global mathematical functions) can be named descriptively; for example, `Math.swift` ."
            }
        ]
    },
    {
        "title": "File Encoding",
        "belongs to": "Source File Basics/File Encoding",
        "cases": [
            {
                "description": "Source files are encoded in UTF-8."
            }
        ]
    },
    {
        "title": "Whitespace Characters",
        "belongs to": "Source File Basics/Whitespace Characters",
        "cases": [
            {
                "description": "Aside from the line terminator, the Unicode horizontal space character ( `U+0020` ) is the only whitespace character that appears anywhere in a source file. The implications are:\nAll other whitespace characters in string and character literals are represented by their corresponding escape sequence. \nTab characters are not used for indentation."
            }
        ]
    },
    {
        "title": "Special Escape Sequences",
        "belongs to": "Source File Basics/Special Escape Sequences",
        "cases": [
            {
                "description": "For any character that has a special escape sequence ( `\\t` , `\\n` , `\\r` , `\\\"` , `\\'` , `\\\\` , and `\\0` ), that sequence is used rather than the equivalent Unicode (e.g., `\\u{000a}` ) escape sequence."
            }
        ]
    },
    {
        "title": "Invisible Characters and Modifiers",
        "belongs to": "Source File Basics/Invisible Characters and Modifiers",
        "cases": [
            {
                "description": "Invisible characters, such as the zero width space and other control characters that do not affect the graphical representation of a string, are always written as Unicode escape sequences.\nControl characters, combining characters, and variation selectors that do affect the graphical representation of a string are not escaped when they are attached to a character or characters that they modify. If such a Unicode scalar is present in isolation or is otherwise not modifying another character in the same string, it is written as a Unicode escape sequence.\nThe strings below are well-formed because the umlauts and variation selectors associate with neighboring characters in the string. The second example is in fact composed of five Unicode scalars, but they are unescaped because the specific combination is rendered as a single character.",
                "example": "let size = \"√úbergr√∂√üe\"\nlet shrug = \"ü§∑üèø‚ÄçÔ∏è\"\n"
            },
            {
                "description": "In the example below, the umlaut and variation selector are in strings by themselves, so they are escaped.",
                "example": "let diaeresis = \"\\u{0308}\"\nlet skinToneType6 = \"\\u{1F3FF}\"\n"
            },
            {
                "description": "If the umlaut were included in the string literally, it would combine with the preceding quotation mark, impairing readability. Likewise, while most systems may render a standalone skin tone modifier as a block graphic, the example below is still forbidden because it is a modifier that is not modifying a character in the same string.",
                "example": "let diaeresis = \"Ãà\"\nlet skinToneType6 = \"üèø\"\n"
            }
        ]
    },
    {
        "title": "String Literals",
        "belongs to": "Source File Basics/String Literals",
        "cases": [
            {
                "description": "Unicode escape sequences ( `\\u{????}` ) and literal code points (for example, `√ú` ) outside the 7-bit ASCII range are never mixed in the same string.\nMore specifically, string literals are either:\ncomposed of a combination of Unicode code points written literally and/or single character escape sequences (such as `\\t` , but not \n`\\u{????}` ), or \ncomposed of 7-bit ASCII with any number of Unicode escape sequences and/or other escape sequences.\nThe following example is correct because `\\n` is allowed to be present among other Unicode code points.",
                "example": "let size = \"√úbergr√∂√üe\\n\"\n"
            },
            {
                "description": "The following example is allowed because it follows the rules above, but it is not preferred because the text is harder to read and understand compared to the string above.",
                "example": "let size = \"\\u{00DC}bergr\\u{00F6}\\u{00DF}e\\n\"\n"
            },
            {
                "description": "The example below is forbidden because it mixes code points outside the 7-bit ASCII range in both literal form and in escaped form.",
                "example": "let size = \"√úbergr\\u{00F6}\\u{00DF}e\\n\"\n"
            },
            {
                "description": "Aside: Never make your code less readable simply out of fear that some programs might not handle non-ASCII characters properly. If that should happen, those programs are broken and must be fixed."
            }
        ]
    },
    {
        "title": "Source File Structure",
        "belongs to": "Source File Structure",
        "cases": []
    },
    {
        "title": "File Comments",
        "belongs to": "Source File Structure/File Comments",
        "cases": [
            {
                "description": "Comments describing the contents of a source file are optional. They are discouraged for files that contain only a single abstraction (such as a class declaration)‚Äîin those cases, the documentation comment on the abstraction itself is sufficient and a file comment is only present if it provides additional useful information. File comments are allowed for files that contain multiple abstractions in order to document that grouping as a whole."
            }
        ]
    },
    {
        "title": "Import Statements",
        "belongs to": "Source File Structure/Import Statements",
        "cases": [
            {
                "description": "A source file imports exactly the top-level modules that it needs; nothing more and nothing less. If a source file uses definitions from both `UIKit` and `Foundation` , it imports both explicitly; it does not rely on the fact that some Apple frameworks transitively import others as an implementation detail.\nImports of whole modules are preferred to imports of individual declarations or submodules.\nThere are a number of reasons to avoid importing individual members: \nThere is no automated tooling to resolve/organize imports. \nExisting automated tooling (such as Xcode‚Äôs migrator) are less likely to work well on code that imports individual members because they are considered corner cases. \nThe prevailing style in Swift (based on official examples and community code) is to import entire modules.\nImports of individual declarations are permitted when importing the whole module would otherwise pollute the global namespace with top-level definitions (such as C interfaces). Use your best judgment in these situations.\nImports of submodules are permitted if the submodule exports functionality that is not available when importing the top-level module. For example, `UIKit.UIGestureRecognizerSubclass` must be imported explicitly to expose the methods that allow client code to subclass `UIGestureRecognizer` ‚Äîthose are not visible by importing `UIKit` alone.\nImport statements are not line-wrapped.\nImport statements are the first non-comment tokens in a source file. They are grouped in the following fashion, with the imports in each group ordered lexicographically and with exactly one blank line between each group:\nModule/submodule imports not under test \nIndividual declaration imports ( `class` , `enum` , `func` , `struct` , `var` ) \nModules imported with `@testable` (only present in test sources)",
                "example": "import CoreLocation\nimport MyThirdPartyModule\nimport SpriteKit\nimport UIKit\n\nimport func Darwin.C.isatty\n\n@testable import MyModuleUnderTest\n"
            }
        ]
    },
    {
        "title": "Type, Variable, and Function Declarations",
        "belongs to": "Source File Structure/Type, Variable, and Function Declarations",
        "cases": [
            {
                "description": "In general, most source files contain only one top-level type, especially when the type declaration is large. Exceptions are allowed when it makes sense to include multiple related types in a single file. For example,\nA class and its delegate protocol may be defined in the same file. \nA type and its small related helper types may be defined in the same file. This can be useful when using `fileprivate` to restrict certain functionality of the type and/or its helpers to only that file and not the rest of the module.\nThe order of types, variables, and functions in a source file, and the order of the members of those types, can have a great effect on readability. However, there is no single correct recipe for how to do it; different files and different types may order their contents in different ways.\nWhat is important is that each file and type uses some logical order, which its maintainer could explain if asked. For example, new methods are not just habitually added to the end of the type, as that would yield ‚Äúchronological by date added‚Äù ordering, which is not a logical ordering.\nWhen deciding on the logical order of members, it can be helpful for readers and future writers (including yourself) to use `//MARK:` comments to provide descriptions for that grouping. These comments are also interpreted by Xcode and provide bookmarks in the source window‚Äôs navigation bar. (Likewise, `//MARK:-` , written with a hyphen before the description, causes Xcode to insert a divider before the menu item.) For example,",
                "example": "class MovieRatingViewController: UITableViewController {\n\n  // MARK: - View controller lifecycle methods\n\n  override func viewDidLoad() {\n    // ...\n  }\n\n  override func viewWillAppear(_ animated: Bool) {\n    // ...\n  }\n\n  // MARK: - Movie rating manipulation methods\n\n  @objc private func ratingStarWasTapped(_ sender: UIButton?) {\n    // ...\n  }\n\n  @objc private func criticReviewWasTapped(_ sender: UIButton?) {\n    // ...\n  }\n}\n"
            }
        ]
    },
    {
        "title": "Overloaded Declarations",
        "belongs to": "Source File Structure/Overloaded Declarations",
        "cases": [
            {
                "description": "When a type has multiple initializers or subscripts, or a file/type has multiple functions with the same base name (though perhaps with different argument labels), and when these overloads appear in the same type or extension scope, they appear sequentially with no other code in between."
            }
        ]
    },
    {
        "title": "Extensions",
        "belongs to": "Source File Structure/Extensions",
        "cases": [
            {
                "description": "Extensions can be used to organize functionality of a type across multiple ‚Äúunits.‚Äù As with member order, the organizational structure/grouping you choose can have a great effect on readability; you must use some logical organizational structure that you could explain to a reviewer if asked."
            }
        ]
    },
    {
        "title": "General Formatting",
        "belongs to": "General Formatting",
        "cases": []
    },
    {
        "title": "Column Limit",
        "belongs to": "General Formatting/Column Limit",
        "cases": [
            {
                "description": "Swift code has a column limit of 100 characters. Except as noted below, any line that would exceed this limit must be line-wrapped as described in Line-Wrapping .\nExceptions:\nLines where obeying the column limit is not possible without breaking a meaningful unit of text that should not be broken (for example, a long URL in a comment). \n`import` statements. \nCode generated by another tool."
            }
        ]
    },
    {
        "title": "Braces",
        "belongs to": "General Formatting/Braces",
        "cases": [
            {
                "description": "In general, braces follow Kernighan and Ritchie (K&R) style for non-empty blocks with exceptions for Swift-specific constructs and rules:\nThere is no line break before the opening brace ( `{` ), unless required by application of the rules in Line-Wrapping . \nThere is a line break after the opening brace ( `{` ), except \nin closures, where the signature of the closure is placed on the same line as the curly brace, if it fits, and a line break follows the `in` keyword. \nwhere it may be omitted as described in One Statement Per Line . \nempty blocks may be written as `{}` . \nThere is a line break before the closing brace ( `}` ), except where it may be omitted as described in One Statement Per Line , or it completes an empty block. \nThere is a line break after the closing brace ( `}` ), if and only if that brace terminates a statement or the body of a declaration. For example, an `else` block is written `}else{` with both braces on the same line."
            }
        ]
    },
    {
        "title": "Semicolons",
        "belongs to": "General Formatting/Semicolons",
        "cases": [
            {
                "description": "Semicolons ( `;` ) are not used , either to terminate or separate statements.\nIn other words, the only location where a semicolon may appear is inside a string literal or a comment.",
                "example": "func printSum(_ a: Int, _ b: Int) {\n  let sum = a + b\n  print(sum)\n}\n\nfunc printSum(_ a: Int, _ b: Int) {\n  let sum = a + b;\n  print(sum);\n}\n"
            }
        ]
    },
    {
        "title": "One Statement Per Line",
        "belongs to": "General Formatting/One Statement Per Line",
        "cases": [
            {
                "description": "There is at most one statement per line, and each statement is followed by a line break, except when the line ends with a block that also contains zero or one statements.",
                "example": "guard let value = value else { return 0 }\n\ndefer { file.close() }\n\nswitch someEnum {\ncase .first: return 5\ncase .second: return 10\ncase .third: return 20\n}\n\nlet squares = numbers.map { $0 * $0 }\n\nvar someProperty: Int {\n  get { return otherObject.property }\n  set { otherObject.property = newValue }\n}\n\nvar someProperty: Int { return otherObject.somethingElse() }\n\nrequired init?(coder aDecoder: NSCoder) { fatalError(\"no coder\") }\n"
            },
            {
                "description": "Wrapping the body of a single-statement block onto its own line is always allowed. Exercise best judgment when deciding whether to place a conditional statement and its body on the same line. For example, single line conditionals work well for early-return and basic cleanup tasks, but less so when the body contains a function call with significant logic. When in doubt, write it as a multi-line statement."
            }
        ]
    },
    {
        "title": "Line-Wrapping",
        "belongs to": "General Formatting/Line-Wrapping",
        "cases": [
            {
                "description": "Terminology note: Line-wrapping is the activity of dividing code into multiple lines that might otherwise legally occupy a single line.\nFor the purposes of Google Swift style, many declarations (such as type declarations and function declarations) and other expressions (like function calls) can be partitioned into breakable units that are separated by unbreakable delimiting token sequences.\nAs an example, consider the following complex function declaration, which needs to be line-wrapped:",
                "example": "public func index<Elements: Collection, Element>(of element: Element, in collection: Elements) -> Elements.Index? where Elements.Element == Element, Element: Equatable {\n  // ...\n}\n"
            },
            {
                "description": "This declaration is split as follows (scroll horizontally if necessary to see the full example). Unbreakable token sequences are indicated in orange; breakable sequences are indicated in blue.",
                "example": "public func index<Elements: Collection, Element>(of element: Element, in collection: Elements) ->Elements.Index?whereElements.Element == Element, Element: Equatable{\n  // ...\n}\n"
            },
            {
                "description": "The unbreakable token sequence up through the open angle bracket ( `<` ) that begins the generic argument list. \nThe breakable list of generic arguments. \nThe unbreakable token sequence ( `>(` ) that separates the generic arguments from the formal arguments. \nThe breakable comma-delimited list of formal arguments. \nThe unbreakable token-sequence from the closing parenthesis ( `)` ) up through the arrow ( `->` ) that precedes the return type. \nThe breakable return type. \nThe unbreakable \n`where` keyword that begins the generic constraints list. \nThe breakable comma-delimited list of generic constraints.\nUsing these concepts, the cardinal rules of Google Swift style for line-wrapping are:\nIf the entire declaration, statement, or expression fits on one line, then do that. \nComma-delimited lists are only laid out in one direction: horizontally or vertically. In other words, all elements must fit on the same line, or each element must be on its own line. A horizontally-oriented list does not contain any line breaks, even before the first element or after the last element. Except in control flow statements, a vertically-oriented list contains a line break before the first element and after each element. \nA continuation line starting with an unbreakable token sequence is indented at the same level as the original line. \nA continuation line that is part of a vertically-oriented comma-delimited list is indented exactly +2 from the original line. \nWhen an open curly brace ( `{` ) follows a line-wrapped declaration or expression, it is on the same line as the final continuation line unless that line is indented at +2 from the original line. In that case, the brace is placed on its own line, to avoid the continuation lines from blending visually with the body of the subsequent block.",
                "example": "public func index<Elements: Collection, Element>(\n  of element: Element,\n  in collection: Elements\n) -> Elements.Index?\nwhere\n  Elements.Element == Element,\n  Element: Equatable\n{  // GOOD.\n  for current in elements {\n    // ...\n  }\n}\n\npublic func index<Elements: Collection, Element>(\n  of element: Element,\n  in collection: Elements\n) -> Elements.Index?\nwhere\n  Elements.Element == Element,\n  Element: Equatable {  // AVOID.\n  for current in elements {\n    // ...\n  }\n}\n"
            },
            {
                "description": "For declarations that contain a `where` clause followed by generic constraints, additional rules apply:\nIf the generic constraint list exceeds the column limit when placed on the same line as the return type, then a line break is first inserted before the `where` keyword and the `where` keyword is indented at the same level as the original line. \nIf the generic constraint list still exceeds the column limit after inserting the line break above, then the constraint list is oriented vertically with a line break after the `where` keyword and a line break after the final constraint.\nConcrete examples of this are shown in the relevant subsections below.\nThis line-wrapping style ensures that the different parts of a declaration are quickly and easily identifiable to the reader by using indentation and line breaks, while also preserving the same indentation level for those parts throughout the file. Specifically, it prevents the zig-zag effect that would be present if the arguments are indented based on opening parentheses, as is common in other languages:",
                "example": "public func index<Elements: Collection, Element>(of element: Element,  // AVOID.\n                                                 in collection: Elements) -> Elements.Index?\n    where Elements.Element == Element, Element: Equatable {\n  doSomething()\n}\n"
            }
        ]
    },
    {
        "title": "Function Declarations",
        "belongs to": "General Formatting/Line-Wrapping/Function Declarations",
        "cases": [
            {
                "example": "modifiers func name(formal arguments){\n\nmodifiers func name(formal arguments) ->result{\n\nmodifiers func name<generic arguments>(formal arguments) throws ->result{\n\nmodifiers func name<generic arguments>(formal arguments) throws ->resultwheregeneric constraints{\n"
            },
            {
                "description": "Applying the rules above from left to right gives us the following line-wrapping:",
                "example": "public func index<Elements: Collection, Element>(\n  of element: Element,\n  in collection: Elements\n) -> Elements.Index? where Elements.Element == Element, Element: Equatable {\n  for current in elements {\n    // ...\n  }\n}\n"
            },
            {
                "description": "Function declarations in protocols that are terminated with a closing parenthesis ( `)` ) may place the parenthesis on the same line as the final argument or on its own line.",
                "example": "public protocol ContrivedExampleDelegate {\n  func contrivedExample(\n    _ contrivedExample: ContrivedExample,\n    willDoSomethingTo someValue: SomeValue)\n}\n\npublic protocol ContrivedExampleDelegate {\n  func contrivedExample(\n    _ contrivedExample: ContrivedExample,\n    willDoSomethingTo someValue: SomeValue\n  )\n}\n"
            },
            {
                "description": "If types are complex and/or deeply nested, individual elements in the arguments/constraints lists and/or the return type may also need to be wrapped. In these rare cases, the same line-wrapping rules apply to those parts as apply to the declaration itself.",
                "example": "public func performanceTrackingIndex<Elements: Collection, Element>(\n  of element: Element,\n  in collection: Elements\n) -> (\n  Element.Index?,\n  PerformanceTrackingIndexStatistics.Timings,\n  PerformanceTrackingIndexStatistics.SpaceUsed\n) {\n  // ...\n}\n"
            },
            {
                "description": "However, `typealias` es or some other means are often a better way to simplify complex declarations whenever possible."
            }
        ]
    },
    {
        "title": "Type and Extension Declarations",
        "belongs to": "General Formatting/Line-Wrapping/Type and Extension Declarations",
        "cases": [
            {
                "description": "The examples below apply equally to `class` , `struct` , `enum` , `extension` , and `protocol` (with the obvious exception that all but the first do not have superclasses in their inheritance list, but they are otherwise structurally similar).",
                "example": "modifiers class Name{\n\nmodifiers class Name:superclass and protocols{\n\nmodifiers class Name<generic arguments>:superclass and protocols{\n\nmodifiers class Name<generic arguments>:superclass and protocolswheregeneric constraints{\n\nclass MyClass:\n  MySuperclass,\n  MyProtocol,\n  SomeoneElsesProtocol,\n  SomeFrameworkProtocol\n{\n  // ...\n}\n\nclass MyContainer<Element>:\n  MyContainerSuperclass,\n  MyContainerProtocol,\n  SomeoneElsesContainerProtocol,\n  SomeFrameworkContainerProtocol\n{\n  // ...\n}\n\nclass MyContainer<BaseCollection>:\n  MyContainerSuperclass,\n  MyContainerProtocol,\n  SomeoneElsesContainerProtocol,\n  SomeFrameworkContainerProtocol\nwhere BaseCollection: Collection {\n  // ...\n}\n\nclass MyContainer<BaseCollection>:\n  MyContainerSuperclass,\n  MyContainerProtocol,\n  SomeoneElsesContainerProtocol,\n  SomeFrameworkContainerProtocol\nwhere\n  BaseCollection: Collection,\n  BaseCollection.Element: Equatable,\n  BaseCollection.Element: SomeOtherProtocolOnlyUsedToForceLineWrapping\n{\n  // ...\n}\n"
            }
        ]
    },
    {
        "title": "Function Calls",
        "belongs to": "General Formatting/Line-Wrapping/Function Calls",
        "cases": [
            {
                "description": "When a function call is line-wrapped, each argument is written on its own line, indented +2 from the original line.\nAs with function declarations, if the function call terminates its enclosing statement and ends with a closing parenthesis ( `)` ) (that is, it has no trailing closure), then the parenthesis may be placed either on the same line as the final argument or on its own line.",
                "example": "let index = index(\n  of: veryLongElementVariableName,\n  in: aCollectionOfElementsThatAlsoHappensToHaveALongName)\n\nlet index = index(\n  of: veryLongElementVariableName,\n  in: aCollectionOfElementsThatAlsoHappensToHaveALongName\n)\n"
            },
            {
                "description": "If the function call ends with a trailing closure and the closure‚Äôs signature must be wrapped, then place it on its own line and wrap the argument list in parentheses to distinguish it from the body of the closure below it.",
                "example": "someAsynchronousAction.execute(withDelay: howManySeconds, context: actionContext) {\n  (context, completion) in\n  doSomething(withContext: context)\n  completion()\n}\n"
            }
        ]
    },
    {
        "title": "Control Flow Statements",
        "belongs to": "General Formatting/Line-Wrapping/Control Flow Statements",
        "cases": [
            {
                "description": "When a control flow statement (such as `if` , `guard` , `while` , or `for` ) is wrapped, the first continuation line is indented to the same position as the token following the control flow keyword. Additional continuation lines are indented at that same position if they are syntactically parallel elements, or in +2 increments from that position if they are syntactically nested.\nThe open brace ( `{` ) preceding the body of the control flow statement can either be placed on the same line as the last continuation line or on the next line, at the same indentation level as the beginning of the statement. For `guard` statements, the `else{` must be kept together, either on the same line or on the next line.",
                "example": "if aBooleanValueReturnedByAVeryLongOptionalThing() &&\n   aDifferentBooleanValueReturnedByAVeryLongOptionalThing() &&\n   yetAnotherBooleanValueThatContributesToTheWrapping() {\n  doSomething()\n}\n\nif aBooleanValueReturnedByAVeryLongOptionalThing() &&\n   aDifferentBooleanValueReturnedByAVeryLongOptionalThing() &&\n   yetAnotherBooleanValueThatContributesToTheWrapping()\n{\n  doSomething()\n}\n\nif let value = aValueReturnedByAVeryLongOptionalThing(),\n   let value2 = aDifferentValueReturnedByAVeryLongOptionalThing() {\n  doSomething()\n}\n\nif let value = aValueReturnedByAVeryLongOptionalThing(),\n   let value2 = aDifferentValueReturnedByAVeryLongOptionalThingThatForcesTheBraceToBeWrapped()\n{\n  doSomething()\n}\n\nguard let value = aValueReturnedByAVeryLongOptionalThing(),\n      let value2 = aDifferentValueReturnedByAVeryLongOptionalThing() else {\n  doSomething()\n}\n\nguard let value = aValueReturnedByAVeryLongOptionalThing(),\n      let value2 = aDifferentValueReturnedByAVeryLongOptionalThing()\nelse {\n  doSomething()\n}\n\nfor element in collection\n    where element.happensToHaveAVeryLongPropertyNameThatYouNeedToCheck {\n  doSomething()\n}\n"
            }
        ]
    },
    {
        "title": "Other Expressions",
        "belongs to": "General Formatting/Line-Wrapping/Other Expressions",
        "cases": [
            {
                "description": "When line-wrapping other expressions that are not function calls (as described above), the second line (the one immediately following the first break) is indented exactly +2 from the original line.\nWhen there are multiple continuation lines, indentation may be varied in increments of +2 as needed. In general, two continuation lines use the same indentation level if and only if they begin with syntactically parallel elements. However, if there are many continuation lines caused by long wrapped expressions, consider splitting them into multiple statements using temporary variables when possible.",
                "example": "let result = anExpression + thatIsMadeUpOf * aLargeNumber +\n  ofTerms / andTherefore % mustBeWrapped + (\n    andWeWill - keepMakingItLonger * soThatWeHave / aContrivedExample)\n\nlet result = anExpression + thatIsMadeUpOf * aLargeNumber +\n    ofTerms / andTherefore % mustBeWrapped + (\n        andWeWill - keepMakingItLonger * soThatWeHave / aContrivedExample)\n"
            }
        ]
    },
    {
        "title": "Horizontal Whitespace",
        "belongs to": "General Formatting/Line-Wrapping/Horizontal Whitespace",
        "cases": [
            {
                "description": "Terminology note: In this section, horizontal whitespace refers to interior space. These rules are never interpreted as requiring or forbidding additional space at the start of a line.\nBeyond where required by the language or other style rules, and apart from literals and comments, a single Unicode space also appears in the following places only :\nSeparating any reserved word starting a conditional or switch statement (such as `if` , `guard` , `while` , or `switch` ) from the expression that follows it if that expression starts with an open parenthesis ( `(` ).",
                "example": "if (x == 0 && y == 0) || z == 0 {\n  // ...\n}\n\nif(x == 0 && y == 0) || z == 0 {\n  // ...\n}\n"
            },
            {
                "description": "Before any closing curly brace ( `}` ) that follows code on the same line, before any open curly brace ( `{` ), and after any open curly brace ( `{` ) that is followed by code on the same line.",
                "example": "let nonNegativeCubes = numbers.map { $0 * $0 * $0 }.filter { $0 >= 0 }\n\nlet nonNegativeCubes = numbers.map { $0 * $0 * $0 } .filter { $0 >= 0 }\nlet nonNegativeCubes = numbers.map{$0 * $0 * $0}.filter{$0 >= 0}\n"
            },
            {
                "description": "On both sides of any binary or ternary operator, including the ‚Äúoperator-like‚Äù symbols described below, with exceptions noted at the end: \nThe `=` sign used in assignment, initialization of variables/properties, and default arguments in functions.",
                "example": "var x = 5\n\nfunc sum(_ numbers: [Int], initialValue: Int = 0) {\n  // ...\n}\n\nvar x=5\n\nfunc sum(_ numbers: [Int], initialValue: Int=0) {\n  // ...\n}\n"
            },
            {
                "description": "The ampersand ( `&` ) in a protocol composition type.",
                "example": "func sayHappyBirthday(to person: NameProviding & AgeProviding) {\n  // ...\n}\n\nfunc sayHappyBirthday(to person: NameProviding&AgeProviding) {\n  // ...\n}\n"
            },
            {
                "description": "The operator symbol in a function declaring/implementing that operator.",
                "example": "static func == (lhs: MyType, rhs: MyType) -> Bool {\n  // ...\n}\n\nstatic func ==(lhs: MyType, rhs: MyType) -> Bool {\n  // ...\n}\n"
            },
            {
                "description": "The arrow ( `->` ) preceding the return type of a function.",
                "example": "func sum(_ numbers: [Int]) -> Int {\n  // ...\n}\n\nfunc sum(_ numbers: [Int])->Int {\n  // ...\n}\n"
            },
            {
                "description": "Exception: There is no space on either side of the dot ( `.` ) used to reference value and type members.",
                "example": "let width = view.bounds.width\n\nlet width = view . bounds . width\n"
            },
            {
                "description": "Exception: There is no space on either side of the `..<` or `...` operators used in range expressions.",
                "example": "for number in 1...5 {\n  // ...\n}\n\nlet substring = string[index..<string.endIndex]\n\nfor number in 1 ... 5 {\n  // ...\n}\n\nlet substring = string[index ..< string.endIndex]\n"
            },
            {
                "description": "After, but not before, the comma ( `,` ) in parameter lists and in tuple/array/dictionary literals.",
                "example": "let numbers = [1, 2, 3]\n\nlet numbers = [1,2,3]\nlet numbers = [1 ,2 ,3]\nlet numbers = [1 , 2 , 3]\n"
            },
            {
                "description": "After, but not before, the colon ( `:` ) in \nSuperclass/protocol conformance lists and generic constraints.",
                "example": "struct HashTable: Collection {\n  // ...\n}\n\nstruct AnyEquatable<Wrapped: Equatable>: Equatable {\n  // ...\n}\n\nstruct HashTable : Collection {\n  // ...\n}\n\nstruct AnyEquatable<Wrapped : Equatable> : Equatable {\n  // ...\n}\n"
            },
            {
                "description": "Function argument labels and tuple element labels.",
                "example": "let tuple: (x: Int, y: Int)\n\nfunc sum(_ numbers: [Int]) {\n  // ...\n}\n\nlet tuple: (x:Int, y:Int)\nlet tuple: (x : Int, y : Int)\n\nfunc sum(_ numbers:[Int]) {\n  // ...\n}\n\nfunc sum(_ numbers : [Int]) {\n  // ...\n}\n"
            },
            {
                "description": "Variable/property declarations with explicit types.",
                "example": "let number: Int = 5\n\nlet number:Int = 5\nlet number : Int = 5\n"
            },
            {
                "description": "Shorthand dictionary type names.",
                "example": "var nameAgeMap: [String: Int] = []\n\nvar nameAgeMap: [String:Int] = []\nvar nameAgeMap: [String : Int] = []\n"
            },
            {
                "description": "Dictionary literals.",
                "example": "let nameAgeMap = [\"Ed\": 40, \"Timmy\": 9]\n\nlet nameAgeMap = [\"Ed\":40, \"Timmy\":9]\nlet nameAgeMap = [\"Ed\" : 40, \"Timmy\" : 9]\n"
            },
            {
                "description": "At least two spaces before and exactly one space after the double slash ( `//` ) that begins an end-of-line comment.",
                "example": "let initialFactor = 2  // Warm up the modulator.\n\nlet initialFactor = 2 //    Warm up the modulator.\n"
            },
            {
                "description": "Outside, but not inside, the brackets of an array or dictionary literals and the parentheses of a tuple literal.",
                "example": "let numbers = [1, 2, 3]\n\nlet numbers = [ 1, 2, 3 ]\n"
            }
        ]
    },
    {
        "title": "Horizontal Alignment",
        "belongs to": "General Formatting/Line-Wrapping/Horizontal Alignment",
        "cases": [
            {
                "description": "Terminology note: \nHorizontal alignment is the practice of adding a variable number of additional spaces in your code with the goal of making certain tokens appear directly below certain other tokens on previous lines.\nHorizontal alignment is forbidden except when writing obviously tabular data where omitting the alignment would be harmful to readability. In other cases (for example, lining up the types of stored property declarations in a `struct` or `class` ), horizontal alignment is an invitation for maintenance problems if a new member is introduced that requires every other member to be realigned.",
                "example": "struct DataPoint {\n  var value: Int\n  var primaryColor: UIColor\n}\n\nstruct DataPoint {\n  var value:        Int\n  var primaryColor: UIColor\n}\n"
            }
        ]
    },
    {
        "title": "Vertical Whitespace",
        "belongs to": "General Formatting/Line-Wrapping/Vertical Whitespace",
        "cases": [
            {
                "description": "A single blank line appears in the following locations:\nBetween consecutive members of a type: properties, initializers, methods, enum cases, and nested types, except that : \nA blank line is optional between two consecutive stored properties or two enum cases whose declarations fit entirely on a single line. Such blank lines can be used to create logical groupings of these declarations. \nA blank line is optional between two extremely closely related properties that do not otherwise meet the criterion above; for example, a private stored property and a related public computed property. \nOnly as needed between statements to organize code into logical subsections. \nOptionally before the first member or after the last member of a type (neither is encouraged nor discouraged). \nAnywhere explicitly required by other sections of this document.\nMultiple blank lines are permitted, but never required (nor encouraged). If you do use multiple consecutive blank lines, do so consistently throughout your code base."
            }
        ]
    },
    {
        "title": "Parentheses",
        "belongs to": "General Formatting/Line-Wrapping/Parentheses",
        "cases": [
            {
                "description": "Parentheses are not used around the top-most expression that follows an `if` , `guard` , `while` , or `switch` keyword.",
                "example": "if x == 0 {\n  print(\"x is zero\")\n}\n\nif (x == 0 || y == 1) && z == 2 {\n  print(\"...\")\n}\n\nif (x == 0) {\n  print(\"x is zero\")\n}\n\nif ((x == 0 || y == 1) && z == 2) {\n  print(\"...\")\n}\n"
            },
            {
                "description": "Optional grouping parentheses are omitted only when the author and the reviewer agree that there is no reasonable chance that the code will be misinterpreted without them, nor that they would have made the code easier to read. It is not reasonable to assume that every reader has the entire Swift operator precedence table memorized."
            }
        ]
    },
    {
        "title": "Formatting Specific Constructs",
        "belongs to": "Formatting Specific Constructs",
        "cases": []
    },
    {
        "title": "Non-Documentation Comments",
        "belongs to": "Formatting Specific Constructs/Non-Documentation Comments",
        "cases": [
            {
                "description": "Non-documentation comments always use the double-slash format ( `//` ), never the C-style block format ( `/*...*/` )."
            }
        ]
    },
    {
        "title": "Properties",
        "belongs to": "Formatting Specific Constructs/Properties",
        "cases": [
            {
                "description": "Local variables are declared close to the point at which they are first used (within reason) to minimize their scope.\nWith the exception of tuple destructuring, every `let` or `var` statement (whether a property or a local variable) declares exactly one variable.",
                "example": "var a = 5\nvar b = 10\n\nlet (quotient, remainder) = divide(100, 9)\n\nvar a = 5, b = 10\n"
            }
        ]
    },
    {
        "title": "Switch Statements",
        "belongs to": "Formatting Specific Constructs/Switch Statements",
        "cases": [
            {
                "description": "Case statements are indented at the same level as the switch statement to which they belong; the statements inside the case blocks are then indented +2 spaces from that level.",
                "example": "switch order {\ncase .ascending:\n  print(\"Ascending\")\ncase .descending:\n  print(\"Descending\")\ncase .same:\n  print(\"Same\")\n}\n\nswitch order {\n  case .ascending:\n    print(\"Ascending\")\n  case .descending:\n    print(\"Descending\")\n  case .same:\n    print(\"Same\")\n}\n\nswitch order {\ncase .ascending:\nprint(\"Ascending\")\ncase .descending:\nprint(\"Descending\")\ncase .same:\nprint(\"Same\")\n}\n"
            }
        ]
    },
    {
        "title": "Enum Cases",
        "belongs to": "Formatting Specific Constructs/Enum Cases",
        "cases": [
            {
                "description": "In general, there is only one `case` per line in an `enum` . The comma-delimited form may be used only when none of the cases have associated values or raw values, all cases fit on a single line, and the cases do not need further documentation because their meanings are obvious from their names.",
                "example": "public enum Token {\n  case comma\n  case semicolon\n  case identifier\n}\n\npublic enum Token {\n  case comma, semicolon, identifier\n}\n\npublic enum Token {\n  case comma\n  case semicolon\n  case identifier(String)\n}\n\npublic enum Token {\n  case comma, semicolon, identifier(String)\n}\n"
            },
            {
                "description": "When all cases of an `enum` must be `indirect` , the `enum` itself is declared `indirect` and the keyword is omitted on the individual cases.",
                "example": "public indirect enum DependencyGraphNode {\n  case userDefined(dependencies: [DependencyGraphNode])\n  case synthesized(dependencies: [DependencyGraphNode])\n}\n\npublic enum DependencyGraphNode {\n  indirect case userDefined(dependencies: [DependencyGraphNode])\n  indirect case synthesized(dependencies: [DependencyGraphNode])\n}\n"
            },
            {
                "description": "When an `enum` case does not have associated values, empty parentheses are never present.",
                "example": "public enum BinaryTree<Element> {\n  indirect case node(element: Element, left: BinaryTree, right: BinaryTree)\n  case empty  // GOOD.\n}\n\npublic enum BinaryTree<Element> {\n  indirect case node(element: Element, left: BinaryTree, right: BinaryTree)\n  case empty()  // AVOID.\n}\n"
            },
            {
                "description": "The cases of an enum must follow a logical ordering that the author could explain if asked. If there is no obviously logical ordering, use a lexicographical ordering based on the cases‚Äô names.\nIn the following example, the cases are arranged in numerical order based on the underlying HTTP status code and blank lines are used to separate groups.",
                "example": "public enum HTTPStatus: Int {\n  case ok = 200\n\n  case badRequest = 400\n  case notAuthorized = 401\n  case paymentRequired = 402\n  case forbidden = 403\n  case notFound = 404\n\n  case internalServerError = 500\n}\n"
            },
            {
                "description": "The following version of the same enum is less readable. Although the cases are ordered lexicographically, the meaningful groupings of related values has been lost.",
                "example": "public enum HTTPStatus: Int {\n  case badRequest = 400\n  case forbidden = 403\n  case internalServerError = 500\n  case notAuthorized = 401\n  case notFound = 404\n  case ok = 200\n  case paymentRequired = 402\n}\n"
            }
        ]
    },
    {
        "title": "Trailing Closures",
        "belongs to": "Formatting Specific Constructs/Trailing Closures",
        "cases": [
            {
                "description": "Functions should not be overloaded such that two overloads differ only by the name of their trailing closure argument. Doing so prevents using trailing closure syntax‚Äîwhen the label is not present, a call to the function with a trailing closure is ambiguous.\nConsider the following example, which prohibits using trailing closure syntax to call `greet` :",
                "example": "func greet(enthusiastically nameProvider: () -> String) {\n  print(\"Hello, \\(nameProvider())! It's a pleasure to see you!\")\n}\n\nfunc greet(apathetically nameProvider: () -> String) {\n  print(\"Oh, look. It's \\(nameProvider()).\")\n}\n\ngreet { \"John\" }  // error: ambiguous use of 'greet'\n"
            },
            {
                "description": "This example is fixed by differentiating some part of the function name other than the closure argument‚Äîin this case, the base name:",
                "example": "func greetEnthusiastically(_ nameProvider: () -> String) {\n  print(\"Hello, \\(nameProvider())! It's a pleasure to see you!\")\n}\n\nfunc greetApathetically(_ nameProvider: () -> String) {\n  print(\"Oh, look. It's \\(nameProvider()).\")\n}\n\ngreetEnthusiastically { \"John\" }\ngreetApathetically { \"not John\" }\n"
            },
            {
                "description": "If a function call has multiple closure arguments, then none are called using trailing closure syntax; all are labeled and nested inside the argument list‚Äôs parentheses.",
                "example": "UIView.animate(\n  withDuration: 0.5,\n  animations: {\n    // ...\n  },\n  completion: { finished in\n    // ...\n  })\n\nUIView.animate(\n  withDuration: 0.5,\n  animations: {\n    // ...\n  }) { finished in\n    // ...\n  }\n"
            },
            {
                "description": "If a function has a single closure argument and it is the final argument, then it is always called using trailing closure syntax, except in the following cases to resolve ambiguity or parsing errors:\nAs described above, labeled closure arguments must be used to disambiguate between two overloads with otherwise identical arguments lists. \nLabeled closure arguments must be used in control flow statements where the body of the trailing closure would be parsed as the body of the control flow statement.",
                "example": "Timer.scheduledTimer(timeInterval: 30, repeats: false) { timer in\n  print(\"Timer done!\")\n}\n\nif let firstActive = list.first(where: { $0.isActive }) {\n  process(firstActive)\n}\n\nTimer.scheduledTimer(timeInterval: 30, repeats: false, block: { timer in\n  print(\"Timer done!\")\n})\n\n// This example fails to compile.\nif let firstActive = list.first { $0.isActive } {\n  process(firstActive)\n}\n"
            },
            {
                "description": "When a function called with trailing closure syntax takes no other arguments, empty parentheses ( `()` ) after the function name are never present.",
                "example": "let squares = [1, 2, 3].map { $0 * $0 }\n\nlet squares = [1, 2, 3].map({ $0 * $0 })\nlet squares = [1, 2, 3].map() { $0 * $0 }\n"
            }
        ]
    },
    {
        "title": "Trailing Commas",
        "belongs to": "Formatting Specific Constructs/Trailing Commas",
        "cases": [
            {
                "description": "Trailing commas in array and dictionary literals are required when each element is placed on its own line. Doing so produces cleaner diffs when items are added to those literals later.",
                "example": "let configurationKeys = [\n  \"bufferSize\",\n  \"compression\",\n  \"encoding\",                                    // GOOD.\n]\n\nlet configurationKeys = [\n  \"bufferSize\",\n  \"compression\",\n  \"encoding\"                                     // AVOID.\n]\n"
            }
        ]
    },
    {
        "title": "Numeric Literals",
        "belongs to": "Formatting Specific Constructs/Numeric Literals",
        "cases": [
            {
                "description": "It is recommended but not required that long numeric literals (decimal, hexadecimal, octal, and binary) use the underscore ( `_` ) separator to group digits for readability when the literal has numeric value or when there exists a domain-specific grouping.\nRecommended groupings are three digits for decimal (thousands separators), four digits for hexadecimal, four or eight digits for binary literals, or value-specific field boundaries when they exist (such as three digits for octal file permissions).\nDo not group digits if the literal is an opaque identifier that does not have a meaningful numeric value."
            }
        ]
    },
    {
        "title": "Attributes",
        "belongs to": "Formatting Specific Constructs/Attributes",
        "cases": [
            {
                "description": "Parameterized attributes (such as `@availability(...)` or `@objc(...)` ) are each written on their own line immediately before the declaration to which they apply, are lexicographically ordered, and are indented at the same level as the declaration.",
                "example": "@available(iOS 9.0, *)\npublic func coolNewFeature() {\n  // ...\n}\n\n@available(iOS 9.0, *) public func coolNewFeature() {\n  // ...\n}\n"
            },
            {
                "description": "Attributes without parameters (for example, `@objc` without arguments, `@IBOutlet` , or `@NSManaged` ) are lexicographically ordered and may be placed on the same line as the declaration if and only if they would fit on that line without requiring the line to be rewrapped. If placing an attribute on the same line as the declaration would require a declaration to be wrapped that previously did not need to be wrapped, then the attribute is placed on its own line.",
                "example": "public class MyViewController: UIViewController {\n  @IBOutlet private var tableView: UITableView!\n}\n"
            }
        ]
    },
    {
        "title": "Naming",
        "belongs to": "Naming",
        "cases": []
    },
    {
        "title": "Apple‚Äôs API Style Guidelines",
        "belongs to": "Naming/Apple‚Äôs API Style Guidelines",
        "cases": [
            {
                "description": "Apple‚Äôs official Swift naming and API design guidelines hosted on swift.org are considered part of this style guide and are followed as if they were repeated here in their entirety."
            }
        ]
    },
    {
        "title": "Naming Conventions Are Not Access Control",
        "belongs to": "Naming/Naming Conventions Are Not Access Control",
        "cases": [
            {
                "description": "Restricted access control ( `internal` , `fileprivate` , or `private` ) is preferred for the purposes of hiding information from clients, rather than naming conventions.\nNaming conventions (such as prefixing a leading underscore) are only used in rare situations when a declaration must be given higher visibility than is otherwise desired in order to work around language limitations‚Äîfor example, a type that has a method that is only intended to be called by other parts of a library implementation that crosses module boundaries and must therefore be declared `public` ."
            }
        ]
    },
    {
        "title": "Identifiers",
        "belongs to": "Naming/Identifiers",
        "cases": [
            {
                "description": "In general, identifiers contain only 7-bit ASCII characters. Unicode identifiers are allowed if they have a clear and legitimate meaning in the problem domain of the code base (for example, Greek letters that represent mathematical concepts) and are well understood by the team who owns the code.",
                "example": "let smile = \"üòä\"\nlet deltaX = newX - previousX\nlet Œîx = newX - previousX\n\nlet üòä = \"üòä\"\n"
            }
        ]
    },
    {
        "title": "Initializers",
        "belongs to": "Naming/Initializers",
        "cases": [
            {
                "description": "For clarity, initializer arguments that correspond directly to a stored property have the same name as the property. Explicit `self.` is used during assignment to disambiguate them.",
                "example": "public struct Person {\n  public let name: String\n  public let phoneNumber: String\n\n  // GOOD.\n  public init(name: String, phoneNumber: String) {\n    self.name = name\n    self.phoneNumber = phoneNumber\n  }\n}\n\npublic struct Person {\n  public let name: String\n  public let phoneNumber: String\n\n  // AVOID.\n  public init(name otherName: String, phoneNumber otherPhoneNumber: String) {\n    name = otherName\n    phoneNumber = otherPhoneNumber\n  }\n}\n"
            }
        ]
    },
    {
        "title": "Static and Class Properties",
        "belongs to": "Naming/Static and Class Properties",
        "cases": [
            {
                "description": "Static and class properties that return instances of the declaring type are not suffixed with the name of the type.",
                "example": "public class UIColor {\n  public class var red: UIColor {                // GOOD.\n    // ...\n  }\n}\n\npublic class URLSession {\n  public class var shared: URLSession {          // GOOD.\n    // ...\n  }\n}\n\npublic class UIColor {\n  public class var redColor: UIColor {           // AVOID.\n    // ...\n  }\n}\n\npublic class URLSession {\n  public class var sharedSession: URLSession {   // AVOID.\n    // ...\n  }\n}\n"
            },
            {
                "description": "When a static or class property evaluates to a singleton instance of the declaring type, the names `shared` and `default` are commonly used. This style guide does not require specific names for these; the author should choose a name that makes sense for the type."
            }
        ]
    },
    {
        "title": "Global Constants",
        "belongs to": "Naming/Global Constants",
        "cases": [
            {
                "description": "Like other variables, global constants are `lowerCamelCase` . Hungarian notation, such as a leading `g` or `k` , is not used.",
                "example": "let secondsPerMinute = 60\n\nlet SecondsPerMinute = 60\nlet kSecondsPerMinute = 60\nlet gSecondsPerMinute = 60\nlet SECONDS_PER_MINUTE = 60\n"
            }
        ]
    },
    {
        "title": "Delegate Methods",
        "belongs to": "Naming/Delegate Methods",
        "cases": [
            {
                "description": "Methods on delegate protocols and delegate-like protocols (such as data sources) are named using the linguistic syntax described below, which is inspired by Cocoa‚Äôs protocols.\nThe term ‚Äúdelegate‚Äôs source object‚Äù refers to the object that invokes methods on the delegate. For example, a `UITableView` is the source object that invokes methods on the `UITableViewDelegate` that is set as the view‚Äôs `delegate` property.\nAll methods take the delegate‚Äôs source object as the first argument.\nFor methods that take the delegate‚Äôs source object as their only argument:\nIf the method returns `Void` (such as those used to notify the delegate that an event has occurred), then the method‚Äôs base name is the delegate‚Äôs source type followed by an indicative verb phrase describing the event. The argument is unlabeled.",
                "example": "func scrollViewDidBeginScrolling(_ scrollView: UIScrollView)\n"
            },
            {
                "description": "If the method returns `Bool` (such as those that make an assertion about the delegate‚Äôs source object itself), then the method‚Äôs name is the delegate‚Äôs source type followed by an indicative or conditional verb phrase describing the assertion. The argument is unlabeled.",
                "example": "func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -> Bool\n"
            },
            {
                "description": "If the method returns some other value (such as those querying for information about a property of the delegate‚Äôs source object), then the method‚Äôs base name is a noun phrase describing the property being queried. The argument is labeled with a preposition or phrase with a trailing preposition that appropriately combines the noun phrase and the delegate‚Äôs source object.",
                "example": "func numberOfSections(in scrollView: UIScrollView) -> Int\n"
            },
            {
                "description": "For methods that take additional arguments after the delegate‚Äôs source object, the method‚Äôs base name is the delegate‚Äôs source type by itself and the first argument is unlabeled. Then:\nIf the method returns `Void` , the second argument is labeled with an indicative verb phrase describing the event that has the argument as its direct object or prepositional object, and any other arguments (if present) provide further context.",
                "example": "func tableView(\n  _ tableView: UITableView,\n  willDisplayCell cell: UITableViewCell,\n  forRowAt indexPath: IndexPath)\n"
            },
            {
                "description": "If the method returns `Bool` , the second argument is labeled with an indicative or conditional verb phrase that describes the return value in terms of the argument, and any other arguments (if present) provide further context.",
                "example": "func tableView(\n  _ tableView: UITableView,\n  shouldSpringLoadRowAt indexPath: IndexPath,\n  with context: UISpringLoadedInteractionContext\n) -> Bool\n"
            },
            {
                "description": "If the method returns some other value, the second argument is labeled with a noun phrase and trailing preposition that describes the return value in terms of the argument, and any other arguments (if present) provide further context.",
                "example": "func tableView(\n  _ tableView: UITableView,\n  heightForRowAt indexPath: IndexPath\n) -> CGFloat\n"
            },
            {
                "description": "Apple‚Äôs documentation on delegates and data sources also contains some good general guidance about such names."
            }
        ]
    },
    {
        "title": "Programming Practices",
        "belongs to": "Programming Practices",
        "cases": [
            {
                "description": "Common themes among the rules in this section are: avoid redundancy, avoid ambiguity, and prefer implicitness over explicitness unless being explicit improves readability and/or reduces ambiguity."
            }
        ]
    },
    {
        "title": "Compiler Warnings",
        "belongs to": "Programming Practices/Compiler Warnings",
        "cases": [
            {
                "description": "Code should compile without warnings when feasible. Any warnings that are able to be removed easily by the author must be removed.\nA reasonable exception is deprecation warnings, where it may not be possible to immediately migrate to the replacement API, or where an API may be deprecated for external users but must still be supported inside a library during a deprecation period."
            }
        ]
    },
    {
        "title": "Initializers",
        "belongs to": "Programming Practices/Initializers",
        "cases": [
            {
                "description": "For `struct` s, Swift synthesizes a non-public memberwise `init` that takes arguments for `var` properties and for any `let` properties that lack default values. When that initializer is suitable (that is, a `public` one is not needed), it is used and no explicit initializer is written.\nThe initializers declared by the special `ExpressibleBy*Literal` compiler protocols are never called directly.",
                "example": "struct Kilometers: ExpressibleByIntegerLiteral {\n  init(integerLiteral value: Int) {\n    // ...\n  }\n}\n\nlet k1: Kilometers = 10                          // GOOD.\nlet k2 = 10 as Kilometers                        // ALSO GOOD.\n\nstruct Kilometers: ExpressibleByIntegerLiteral {\n  init(integerLiteral value: Int) {\n    // ...\n  }\n}\n\nlet k = Kilometers(integerLiteral: 10)           // AVOID.\n"
            },
            {
                "description": "Explicitly calling `.init(...)` is allowed only when the receiver of the call is a metatype variable. In direct calls to the initializer using the literal type name, `.init` is omitted. ( Referring to the initializer directly by using `MyType.init` syntax to convert it to a closure is permitted.)",
                "example": "let x = MyType(arguments)\n\nlet type = lookupType(context)\nlet x = type.init(arguments)\n\nlet x = makeValue(factory: MyType.init)\n\nlet x = MyType.init(arguments)\n"
            }
        ]
    },
    {
        "title": "Properties",
        "belongs to": "Programming Practices/Properties",
        "cases": [
            {
                "description": "The `get` block for a read-only computed property is omitted and its body is directly nested inside the property declaration.",
                "example": "var totalCost: Int {\n  return items.sum { $0.cost }\n}\n\nvar totalCost: Int {\n  get {\n    return items.sum { $0.cost }\n  }\n}\n"
            }
        ]
    },
    {
        "title": "Types with Shorthand Names",
        "belongs to": "Programming Practices/Types with Shorthand Names",
        "cases": [
            {
                "description": "Arrays, dictionaries, and optional types are written in their shorthand form whenever possible; that is, `[Element]` , `[Key:Value]` , and `Wrapped?` . The long forms `Array<Element>` , `Dictionary<Key,Value>` , and `Optional<Wrapped>` are only written when required by the compiler; for example, the Swift parser requires `Array<Element>.Index` and does not accept `[Element].Index` .",
                "example": "func enumeratedDictionary<Element>(\n  from values: [Element],\n  start: Array<Element>.Index? = nil\n) -> [Int: Element] {\n  // ...\n}\n\nfunc enumeratedDictionary<Element>(\n  from values: Array<Element>,\n  start: Optional<Array<Element>.Index> = nil\n) -> Dictionary<Int, Element> {\n  // ...\n}\n"
            },
            {
                "description": "`Void` is a `typealias` for the empty tuple `()` , so from an implementation point of view they are equivalent. In function type declarations (such as closures, or variables holding a function reference), the return type is always written as `Void` , never as `()` . In functions declared with the `func` keyword, the `Void` return type is omitted entirely.\nEmpty argument lists are always written as `()` , never as `Void` . (In fact, the function signature `Void->Result` is an error in Swift because function arguments must be surrounded by parentheses, and `(Void)` has a different meaning: an argument list with a single empty-tuple argument.)",
                "example": "func doSomething() {\n  // ...\n}\n\nlet callback: () -> Void\n\nfunc doSomething() -> Void {\n  // ...\n}\n\nfunc doSomething2() -> () {\n  // ...\n}\n\nlet callback: () -> ()\n"
            }
        ]
    },
    {
        "title": "Optional Types",
        "belongs to": "Programming Practices/Optional Types",
        "cases": [
            {
                "description": "Sentinel values are avoided when designing algorithms (for example, an ‚Äúindex‚Äù of ‚àí1 when an element was not found in a collection). Sentinel values can easily and accidentally propagate through other layers of logic because the type system cannot distinguish between them and valid outcomes.\n`Optional` is used to convey a non-error result that is either a value or the absence of a value. For example, when searching a collection for a value, not finding the value is still a valid and expected outcome, not an error.",
                "example": "func index(of thing: Thing, in things: [Thing]) -> Int? {\n  // ...\n}\n\nif let index = index(of: thing, in: lotsOfThings) {\n  // Found it.\n} else {\n  // Didn't find it.\n}\n\nfunc index(of thing: Thing, in things: [Thing]) -> Int {\n  // ...\n}\n\nlet index = index(of: thing, in: lotsOfThings)\nif index != -1 {\n  // Found it.\n} else {\n  // Didn't find it.\n}\n"
            },
            {
                "description": "`Optional` is also used for error scenarios when there is a single, obvious failure state; that is, when an operation may fail for a single domain-specific reason that is clear to the client. (The domain-specific restriction is meant to exclude severe errors that are typically out of the user‚Äôs control to properly handle, such as out-of-memory errors.)\nFor example, converting a string to an integer would fail if the string does not represent a valid integer that fits into the type‚Äôs bit width:",
                "example": "struct Int17 {\n  init?(_ string: String) {\n    // ...\n  }\n}\n"
            },
            {
                "description": "Conditional statements that test that an `Optional` is non- `nil` but do not access the wrapped value are written as comparisons to `nil` . The following example is clear about the programmer‚Äôs intent:",
                "example": "if value != nil {\n  print(\"value was not nil\")\n}\n"
            },
            {
                "description": "This example, while taking advantage of Swift‚Äôs pattern matching and binding syntax, obfuscates the intent by appearing to unwrap the value and then immediately throw it away.",
                "example": "if let _ = value {\n  print(\"value was not nil\")\n}\n"
            }
        ]
    },
    {
        "title": "Error Types",
        "belongs to": "Programming Practices/Error Types",
        "cases": [
            {
                "description": "Error types are used when there are multiple possible error states.\nThrowing errors instead of merging them with the return type cleanly separates concerns in the API. Valid inputs and valid state produce valid outputs in the result domain and are handled with standard sequential control flow. Invalid inputs and invalid state are treated as errors and are handled using the relevant syntactic constructs ( `do` - `catch` and `try` ). For example:",
                "example": "struct Document {\n  enum ReadError: Error {\n    case notFound\n    case permissionDenied\n    case malformedHeader\n  }\n\n  init(path: String) throws {\n    // ...\n  }\n}\n\ndo {\n  let document = try Document(path: \"important.data\")\n} catch Document.ReadError.notFound {\n  // ...\n} catch Document.ReadError.permissionDenied {\n  // ...\n} catch {\n  // ...\n}\n"
            },
            {
                "description": "Such a design forces the caller to consciously acknowledge the failure case by:\nwrapping the calling code in a `do` - `catch` block and handling error cases to whichever degree is appropriate, \ndeclaring the function in which the call is made as `throws` and letting the error propagate out, or \nusing `try?` when the specific reason for failure is unimportant and only the information about whether the call failed is needed.\nIn general, with exceptions noted below, force- `try!` is forbidden; it is equivalent to `try` followed by `fatalError` but without a meaningful message. If an error outcome would mean that the program is in such an unrecoverable state that immediate termination is the only reasonable action, it is better to use `do` - `catch` or `try?` and provide more context in the error message to assist debugging if the operation does fail.\nException: Force- `try!` is allowed in unit tests and test-only code. It is also allowed in non-test code when it is unmistakably clear that an error would only be thrown because of programmer error; we specifically define this to mean a single expression that could be evaluated without context in the Swift REPL. For example, consider initializing a regular expression from a a string literal:",
                "example": "let regex = try! NSRegularExpression(pattern: \"a*b+c?\")\n",
                "appendix": "The `NSRegularExpression` initializer throws an error if the regular expression is malformed, but when it is a string literal, the error would only occur if the programmer mistyped it. There is no benefit to writing extra error handling logic here. \nIf the pattern above were not a literal but instead were dynamic or derived from user input, `try!` should not be used and errors should be handled gracefully."
            }
        ]
    },
    {
        "title": "Force Unwrapping and Force Casts",
        "belongs to": "Programming Practices/Force Unwrapping and Force Casts",
        "cases": [
            {
                "description": "Force-unwrapping and force-casting are often code smells and are strongly discouraged. Unless it is extremely clear from surrounding code why such an operation is safe, a comment should be present that describes the invariant that ensures that the operation is safe. For example,",
                "example": "let value = getSomeInteger()\n\n// ...intervening code...\n\n// This force-unwrap is safe because `value` is guaranteed to fall within the\n// valid enum cases because it came from some data source that only permits\n// those raw values.\nreturn SomeEnum(rawValue: value)!\n"
            },
            {
                "description": "Exception: Force-unwraps are allowed in unit tests and test-only code without additional documentation. This keeps such code free of unnecessary control flow. In the event that `nil` is unwrapped or a cast operation is to an incompatible type, the test will fail which is the desired result."
            }
        ]
    },
    {
        "title": "Implicitly Unwrapped Optionals",
        "belongs to": "Programming Practices/Implicitly Unwrapped Optionals",
        "cases": [
            {
                "description": "Implicitly unwrapped optionals are inherently unsafe and should be avoided whenever possible in favor of non-optional declarations or regular `Optional` types. Exceptions are described below.\nUser-interface objects whose lifetimes are based on the UI lifecycle instead of being strictly based on the lifetime of the owning object are allowed to use implicitly unwrapped optionals. Examples of these include `@IBOutlet` properties connected to objects in a XIB file or storyboard, properties that are initialized externally like in the `prepareForSegue` implementation of a calling view controller, and properties that are initialized elsewhere during a class‚Äôs life cycle, like views in a view controller‚Äôs `viewDidLoad` method. Making such properties regular optionals can put too much burden on the user to unwrap them because they are guaranteed to be non-nil and remain that way once the objects are ready for use.",
                "example": "class SomeViewController: UIViewController {\n  @IBOutlet var button: UIButton!\n\n  override func viewDidLoad() {\n    populateLabel(for: button)\n  }\n\n  private func populateLabel(for button: UIButton) {\n    // ...\n  }\n}\n"
            },
            {
                "description": "Implicitly unwrapped optionals can also surface in Swift code when using Objective-C APIs that lack the appropriate nullability attributes. If possible, coordinate with the owners of that code to add those annotations so that the APIs are imported cleanly into Swift. If this is not possible, try to keep the footprint of those implicitly unwrapped optionals as small as possible in your Swift code; that is, do not propagate them through multiple layers of your own abstractions.\nImplicitly unwrapped optionals are also allowed in unit tests. This is for reasons similar to the UI object scenario above‚Äîthe lifetime of test fixtures often begins not in the test‚Äôs initializer but in the `setUp()` method of a test so that they can be reset before the execution of each test."
            }
        ]
    },
    {
        "title": "Access Levels",
        "belongs to": "Programming Practices/Access Levels",
        "cases": [
            {
                "description": "Omitting an explicit access level is permitted on declarations. For top-level declarations, the default access level is `internal` . For nested declarations, the default access level is the lesser of `internal` and the access level of the enclosing declaration.\nSpecifying an explicit access level at the file level on an extension is forbidden. Each member of the extension has its access level specified if it is different than the default.",
                "example": "extension String {\n  public var isUppercase: Bool {\n    // ...\n  }\n\n  public var isLowercase: Bool {\n    // ...\n  }\n}\n\npublic extension String {\n  var isUppercase: Bool {\n    // ...\n  }\n\n  var isLowercase: Bool {\n    // ...\n  }\n}\n"
            }
        ]
    },
    {
        "title": "Nesting and Namespacing",
        "belongs to": "Programming Practices/Nesting and Namespacing",
        "cases": [
            {
                "description": "Swift allows `enum` s, `struct` s, and `class` es to be nested, so nesting is preferred (instead of naming conventions) to express scoped and hierarchical relationships among types when possible. For example, flag `enum` s or error types that are associated with a specific type are nested in that type.",
                "example": "class Parser {\n  enum Error: Swift.Error {\n    case invalidToken(String)\n    case unexpectedEOF\n  }\n\n  func parse(text: String) throws {\n    // ...\n  }\n}\n\nclass Parser {\n  func parse(text: String) throws {\n    // ...\n  }\n}\n\nenum ParseError: Error {\n  case invalidToken(String)\n  case unexpectedEOF\n}\n"
            },
            {
                "description": "Swift does not currently allow protocols to be nested in other types or vice versa, so this rule does not apply to situations such as the relationship between a controller class and its delegate protocol.\nDeclaring an `enum` without cases is the canonical way to define a ‚Äúnamespace‚Äù to group a set of related declarations, such as constants or helper functions. This `enum` automatically has no instances and does not require that extra boilerplate code be written to prevent instantiation.",
                "example": "enum Dimensions {\n  static let tileMargin: CGFloat = 8\n  static let tilePadding: CGFloat = 4\n  static let tileContentSize: CGSize(width: 80, height: 64)\n}\n\nstruct Dimensions {\n  private init() {}\n\n  static let tileMargin: CGFloat = 8\n  static let tilePadding: CGFloat = 4\n  static let tileContentSize: CGSize(width: 80, height: 64)\n}\n"
            }
        ]
    },
    {
        "title": "guards for Early Exits",
        "belongs to": "Programming Practices/guards for Early Exits",
        "cases": [
            {
                "description": "A `guard` statement, compared to an `if` statement with an inverted condition, provides visual emphasis that the condition being tested is a special case that causes early exit from the enclosing scope.\nFurthermore, `guard` statements improve readability by eliminating extra levels of nesting (the ‚Äúpyramid of doom‚Äù); failure conditions are closely coupled to the conditions that trigger them and the main logic remains flush left within its scope.\nThis can be seen in the following examples; in the first, there is a clear progression that checks for invalid states and exits, then executes the main logic in the successful case. In the second example without `guard` , the main logic is buried at an arbitrary nesting level and the thrown errors are separated from their conditions by a great distance.",
                "example": "func discombobulate(_ values: [Int]) throws -> Int {\n  guard let first = values.first else {\n    throw DiscombobulationError.arrayWasEmpty\n  }\n  guard first >= 0 else {\n    throw DiscombobulationError.negativeEnergy\n  }\n\n  var result = 0\n  for value in values {\n    result += invertedCombobulatoryFactory(of: value)\n  }\n  return result\n}\n\nfunc discombobulate(_ values: [Int]) throws -> Int {\n  if let first = values.first {\n    if first >= 0 {\n      var result = 0\n      for value in values {\n        result += invertedCombobulatoryFactor(of: value)\n      }\n      return result\n    } else {\n      throw DiscombobulationError.negativeEnergy\n    }\n  } else {\n    throw DiscombobulationError.arrayWasEmpty\n  }\n}\n"
            },
            {
                "description": "A `guard` - `continue` statement can also be useful in a loop to avoid increased indentation when the entire body of the loop should only be executed in some cases (but see also the `for` - `where` discussion below.)"
            }
        ]
    },
    {
        "title": "for-where Loops",
        "belongs to": "Programming Practices/for-where Loops",
        "cases": [
            {
                "description": "When the entirety of a `for` loop‚Äôs body would be a single `if` block testing a condition of the element, the test is placed in the `where` clause of the `for` statement instead.",
                "example": "for item in collection where item.hasProperty {\n  // ...\n}\n\nfor item in collection {\n  if item.hasProperty {\n    // ...\n  }\n}\n"
            }
        ]
    },
    {
        "title": "fallthrough in switch Statements",
        "belongs to": "Programming Practices/fallthrough in switch Statements",
        "cases": [
            {
                "description": "When multiple `case` s of a `switch` would execute the same statements, the `case` patterns are combined into ranges or comma-delimited lists. Multiple `case` statements that do nothing but `fallthrough` to a `case` below are not allowed.",
                "example": "switch value {\ncase 1: print(\"one\")\ncase 2...4: print(\"two to four\")\ncase 5, 7: print(\"five or seven\")\ndefault: break\n}\n\nswitch value {\ncase 1: print(\"one\")\ncase 2: fallthrough\ncase 3: fallthrough\ncase 4: print(\"two to four\")\ncase 5: fallthrough\ncase 7: print(\"five or seven\")\ndefault: break\n}\n"
            },
            {
                "description": "In other words, there is never a `case` whose body contains only the `fallthrough` statement. Cases containing additional statements which then fallthrough to the next case are permitted."
            }
        ]
    },
    {
        "title": "Pattern Matching",
        "belongs to": "Programming Practices/Pattern Matching",
        "cases": [
            {
                "description": "The `let` and `var` keywords are placed individually in front of each element in a pattern that is being matched. The shorthand version of `let` / `var` that precedes and distributes across the entire pattern is forbidden because it can introduce unexpected behavior if a value being matched in a pattern is itself a variable.",
                "example": "enum DataPoint {\n  case unlabeled(Int)\n  case labeled(String, Int)\n}\n\nlet label = \"goodbye\"\n\n// `label` is treated as a value here because it is not preceded by `let`, so\n// the pattern below matches only data points that have the label \"goodbye\".\nswitch DataPoint.labeled(\"hello\", 100) {\ncase .labeled(label, let value):\n  // ...\n}\n\n// Writing `let` before each individual binding clarifies that the intent is to\n// introduce a new binding (shadowing the local variable within the case) rather\n// than to match against the value of the local variable. Thus, this pattern\n// matches data points with any string label.\nswitch DataPoint.labeled(\"hello\", 100) {\ncase .labeled(let label, let value):\n  // ...\n}\n"
            },
            {
                "description": "In the example below, if the author‚Äôs intention was to match using the value of the `label` variable above, that has been lost because `let` distributes across the entire pattern and thus shadows the variable with a binding that applies to any string value:",
                "example": "switch DataPoint.labeled(\"hello\", 100) {\ncase let .labeled(label, value):\n  // ...\n}\n"
            },
            {
                "description": "Labels of tuple arguments and `enum` associated values are omitted when binding a value to a variable with the same name as the label.",
                "example": "enum BinaryTree<Element> {\n  indirect case subtree(left: BinaryTree<Element>, right: BinaryTree<Element>)\n  case leaf(element: Element)\n}\n\nswitch treeNode {\ncase .subtree(let left, let right):\n  // ...\ncase .leaf(let element):\n  // ...\n}\n"
            },
            {
                "description": "Including the labels adds noise that is redundant and lacking useful information:",
                "example": "switch treeNode {\ncase .subtree(left: let left, right: let right):\n  // ...\ncase .leaf(element: let element):\n  // ...\n}\n"
            }
        ]
    },
    {
        "title": "Tuple Patterns",
        "belongs to": "Programming Practices/Tuple Patterns",
        "cases": [
            {
                "description": "Assigning variables through a tuple pattern (sometimes referred to as a tuple shuffle ) is only permitted if the left-hand side of the assignment is unlabeled.",
                "example": "let (a, b) = (y: 4, x: 5.0)\n\nlet (x: a, y: b) = (y: 4, x: 5.0)\n"
            },
            {
                "description": "Labels on the left-hand side closely resemble type annotations, and can lead to confusing code.",
                "example": "// This declares two variables, `Int`, which is a `Double` with value 5.0, and\n// `Double`, which is an `Int` with value 4.\n// `x` and `y` are not variables.\nlet (x: Int, y: Double) = (y: 4, x: 5.0)\n"
            }
        ]
    },
    {
        "title": "Numeric and String Literals",
        "belongs to": "Programming Practices/Numeric and String Literals",
        "cases": [
            {
                "description": "Integer and string literals in Swift do not have an intrinsic type. For example, `5` by itself is not an `Int` ; it is a special literal value that can express any type that conforms to `ExpressibleByIntegerLiteral` and only becomes an `Int` if type inference does not map it to a more specific type. Likewise, the literal `\"x\"` is neither `String` nor `Character` nor `UnicodeScalar` , but it can become any of those types depending on its context, falling back to `String` as a default.\nThus, when a literal is used to initialize a value of a type other than its default, and when that type cannot be inferred otherwise by context, specify the type explicitly in the declaration or use an `as` expression to coerce it.",
                "example": "// Without a more explicit type, x1 will be inferred as type Int.\nlet x1 = 50\n\n// These are explicitly type Int32.\nlet x2: Int32 = 50\nlet x3 = 50 as Int32\n\n// Without a more explicit type, y1 will be inferred as type String.\nlet y1 = \"a\"\n\n// These are explicitly type Character.\nlet y2: Character = \"a\"\nlet y3 = \"a\" as Character\n\n// These are explicitly type UnicodeScalar.\nlet y4: UnicodeScalar = \"a\"\nlet y5 = \"a\" as UnicodeScalar\n\nfunc writeByte(_ byte: UInt8) {\n  // ...\n}\n// Inference also occurs for function arguments, so 50 is a UInt8 without\n// explicitly coercion.\nwriteByte(50)\n"
            },
            {
                "description": "The compiler will emit errors appropriately for invalid literal coercions if, for example, a number does not fit into the integer type or a multi-character string is coerced to a character. So while the following examples emit errors, they are ‚Äúgood‚Äù because the errors are caught at compile-time and for the right reasons.",
                "example": "// error: integer literal '9223372036854775808' overflows when stored into 'Int64'\nlet a = 0x8000_0000_0000_0000 as Int64\n\n// error: cannot convert value of type 'String' to type 'Character' in coercion\nlet b = \"ab\" as Character\n"
            },
            {
                "description": "Using initializer syntax for these types of coercions can lead to misleading compiler errors, or worse, hard-to-debug runtime errors.",
                "example": "// This first tries to create an `Int` (signed) from the literal and then\n// convert it to a `UInt64`. Even though this literal fits into a `UInt64`, it\n// doesn't fit into an `Int` first, so it doesn't compile.\nlet a1 = UInt64(0x8000_0000_0000_0000)\n\n// This invokes `Character.init(_: String)`, thus creating a `String` \"a\" at\n// runtime (which involves a slow heap allocation), extracting the character\n// from it, and then releasing it. This is significantly slower than a proper\n// coercion.\nlet b = Character(\"a\")\n\n// As above, this creates a `String` and then `Character.init(_: String)`\n// attempts to extract the single character from it. This fails a precondition\n// check and traps at runtime.\nlet c = Character(\"ab\")\n"
            }
        ]
    },
    {
        "title": "Playground Literals",
        "belongs to": "Programming Practices/Playground Literals",
        "cases": [
            {
                "description": "The graphically-rendered playground literals `#colorLiteral(...)` , `#imageLiteral(...)` , and `#fileLiteral(...)` are forbidden in non-playground production code. They are permitted in playground sources.",
                "example": "let color = UIColor(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)\n\nlet color = #colorLiteral(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)\n"
            }
        ]
    },
    {
        "title": "Trapping vs. Overflowing Arithmetic",
        "belongs to": "Programming Practices/Trapping vs. Overflowing Arithmetic",
        "cases": [
            {
                "description": "The standard (trapping-on-overflow) arithmetic and bitwise operators ( `+` , `-` , `*` , `<<` , and `>>` ) are used for most normal operations, rather than the masking operations (preceded by `&` ). Trapping on overflow is safer because it prevents bad data from propagating through other layers of the system.",
                "example": "// GOOD. Overflow will not cause the balance to go negative.\nlet newBankBalance = oldBankBalance + recentHugeProfit\n\n// AVOID. Overflow will cause the balance to go negative if the summands are\n// large.\nlet newBankBalance = oldBankBalance &+ recentHugeProfit\n"
            },
            {
                "description": "Masking operations are comparatively rare but are permitted (and in fact necessary for correctness) in problem domains that use modular arithmetic, such as cryptography, big-integer implementations, hash functions, and so forth.",
                "example": "var hashValue: Int {\n  // GOOD. What matters here is the distribution of the bit pattern rather than\n  // the actual numeric value.\n  return foo.hashValue &+ 31 * (bar.hashValue &+ 31 &* baz.hashValue)\n}\n\nvar hashValue: Int {\n  // INCORRECT. This will trap arbitrarily and unpredictably depending on the\n  // hash values of the individual terms.\n  return foo.hashValue + 31 * (bar.hashValue + 31 * baz.hashValue)\n}\n"
            },
            {
                "description": "Masking operations are also permitted in performance-sensitive code where the values are already known to not cause overflow (or where overflow is not a concern). In this case, comments should be used to indicate why the use of masking operations is important. Additionally, consider adding debug preconditions to check these assumptions without affecting performance of optimized builds."
            }
        ]
    },
    {
        "title": "Defining New Operators",
        "belongs to": "Programming Practices/Defining New Operators",
        "cases": [
            {
                "description": "When used unwisely, custom-defined operators can significantly reduce the readability of code because such operators often lack the historical context of the more common ones built into the standard library.\nIn general, defining custom operators should be avoided. However, it is allowed when an operator has a clear and well-defined meaning in the problem domain and when using an operator significantly improves the readability of the code when compared to function calls. For example, since `*` is the only multiplication operator defined by Swift (not including the masking version), a numeric matrix library may define additional operators to support other operations like cross product and dot product.\nAn example of a prohibited use case is defining custom `<~~` and `~~>` operators to decode and encode JSON data. Such operators are not native to the problem domain of processing JSON and even an experienced Swift engineer would have difficulty understanding the purpose of the code without seeking out documentation of those operators.\nIf you must use third-party code of unquestionable value that provides an API only available through custom operators, you are strongly encouraged to consider writing a wrapper that defines more readable methods that delegate to the custom operators. This will significantly reduce the learning curve required to understand how such code works for new teammates and other code reviewers."
            }
        ]
    },
    {
        "title": "Overloading Existing Operators",
        "belongs to": "Programming Practices/Overloading Existing Operators",
        "cases": [
            {
                "description": "Overloading operators is permitted when your use of the operator is semantically equivalent to the existing uses in the standard library. Examples of permitted use cases are implementing the operator requirements for `Equatable` and `Hashable` , or defining a new `Matrix` type that supports arithmetic operations.\nIf you wish to overload an existing operator with a meaning other than its natural meaning, follow the guidance in Defining New Operators to determine whether this is permitted. In other words, if the new meaning is well-established in the problem domain and the use of the operator is a readability improvement over other syntactic constructs, then it is permitted.\nAn example of a prohibited case of operator repurposing would be to overload `*` and `+` to build an ad hoc regular expression API. Such an API would not provide strong enough readability benefits compared to simply representing the entire regular expression as a string."
            }
        ]
    },
    {
        "title": "Documentation Comments",
        "belongs to": "Documentation Comments",
        "cases": []
    },
    {
        "title": "General Format",
        "belongs to": "Documentation Comments/General Format",
        "cases": [
            {
                "description": "Documentation comments are written using the format where each line is preceded by a triple slash ( `///` ). Javadoc-style block comments ( `/**...*/` ) are not permitted.",
                "example": "/// Returns the numeric value of the given digit represented as a Unicode scalar.\n///\n/// - Parameters:\n///   - digit: The Unicode scalar whose numeric value should be returned.\n///   - radix: The radix, between 2 and 36, used to compute the numeric value.\n/// - Returns: The numeric value of the scalar.\nfunc numericValue(of digit: UnicodeScalar, radix: Int = 10) -> Int {\n  // ...\n}\n\n/**\n * Returns the numeric value of the given digit represented as a Unicode scalar.\n *\n * - Parameters:\n *   - digit: The Unicode scalar whose numeric value should be returned.\n *   - radix: The radix, between 2 and 36, used to compute the numeric value.\n * - Returns: The numeric value of the scalar.\n */\nfunc numericValue(of digit: UnicodeScalar, radix: Int = 10) -> Int {\n  // ...\n}\n\n/**\nReturns the numeric value of the given digit represented as a Unicode scalar.\n\n- Parameters:\n  - digit: The Unicode scalar whose numeric value should be returned.\n  - radix: The radix, between 2 and 36, used to compute the numeric value.\n- Returns: The numeric value of the scalar.\n*/\nfunc numericValue(of digit: UnicodeScalar, radix: Int = 10) -> Int {\n  // ...\n}\n"
            }
        ]
    },
    {
        "title": "Single-Sentence Summary",
        "belongs to": "Documentation Comments/Single-Sentence Summary",
        "cases": [
            {
                "description": "Documentation comments begin with a brief single-sentence summary that describes the declaration. (This sentence may span multiple lines, but if it spans too many lines, the author should consider whether the summary can be simplified and details moved to a new paragraph.)\nIf more detail is needed than can be stated in the summary, additional paragraphs (each separated by a blank line) are added after it.\nThe single-sentence summary is not necessarily a complete sentence; for example, method summaries are generally written as verb phrases without ‚Äúthis method [‚Ä¶]‚Äù because it is already implied as the subject and writing it out would be redundant. Likewise, properties are often written as noun phrases without ‚Äúthis property is [‚Ä¶]‚Äù. In any case, however, they are still terminated with a period.",
                "example": "/// The background color of the view.\nvar backgroundColor: UIColor\n\n/// Returns the sum of the numbers in the given array.\n///\n/// - Parameter numbers: The numbers to sum.\n/// - Returns: The sum of the numbers.\nfunc sum(_ numbers: [Int]) -> Int {\n  // ...\n}\n\n/// This property is the background color of the view.\nvar backgroundColor: UIColor\n\n/// This method returns the sum of the numbers in the given array.\n///\n/// - Parameter numbers: The numbers to sum.\n/// - Returns: The sum of the numbers.\nfunc sum(_ numbers: [Int]) -> Int {\n  // ...\n}\n"
            }
        ]
    },
    {
        "title": "Parameter, Returns, and Throws Tags",
        "belongs to": "Documentation Comments/Parameter, Returns, and Throws Tags",
        "cases": [
            {
                "description": "Clearly document the parameters, return value, and thrown errors of functions using the `Parameter(s)` , `Returns` , and `Throws` tags, in that order. None ever appears with an empty description. When a description does not fit on a single line, continuation lines are indented 2 spaces in from the position of the hyphen starting the tag.\nThe recommended way to write documentation comments in Xcode is to place the text cursor on the declaration and press Command + Option + / . This will automatically generate the correct format with placeholders to be filled in.\n`Parameter(s)` and `Returns` tags may be omitted only if the single-sentence brief summary fully describes the meaning of those items and including the tags would only repeat what has already been said.\nThe content following the `Parameter(s)` , `Returns` , and `Throws` tags should be terminated with a period, even when they are phrases instead of complete sentences.\nWhen a method takes a single argument, the singular inline form of the `Parameter` tag is used. When a method takes multiple arguments, the grouped plural form `Parameters` is used and each argument is written as an item in a nested list with only its name as the tag.",
                "example": "/// Returns the output generated by executing a command.\n///\n/// - Parameter command: The command to execute in the shell environment.\n/// - Returns: A string containing the contents of the invoked process's\n///   standard output.\nfunc execute(command: String) -> String {\n  // ...\n}\n\n/// Returns the output generated by executing a command with the given string\n/// used as standard input.\n///\n/// - Parameters:\n///   - command: The command to execute in the shell environment.\n///   - stdin: The string to use as standard input.\n/// - Returns: A string containing the contents of the invoked process's\n///   standard output.\nfunc execute(command: String, stdin: String) -> String {\n  // ...\n}\n"
            },
            {
                "description": "The following examples are incorrect, because they use the plural form of `Parameters` for a single parameter or the singular form `Parameter` for multiple parameters.",
                "example": "/// Returns the output generated by executing a command.\n///\n/// - Parameters:\n///   - command: The command to execute in the shell environment.\n/// - Returns: A string containing the contents of the invoked process's\n///   standard output.\nfunc execute(command: String) -> String {\n  // ...\n}\n\n/// Returns the output generated by executing a command with the given string\n/// used as standard input.\n///\n/// - Parameter command: The command to execute in the shell environment.\n/// - Parameter stdin: The string to use as standard input.\n/// - Returns: A string containing the contents of the invoked process's\n///   standard output.\nfunc execute(command: String, stdin: String) -> String {\n  // ...\n}\n"
            }
        ]
    },
    {
        "title": "Apple‚Äôs Markup Format",
        "belongs to": "Documentation Comments/Apple‚Äôs Markup Format",
        "cases": [
            {
                "description": "Use of Apple‚Äôs markup format is strongly encouraged to add rich formatting to documentation. Such markup helps to differentiate symbolic references (like parameter names) from descriptive text in comments and is rendered by Xcode and other documentation generation tools. Some examples of frequently used directives are listed below.\nParagraphs are separated using a single line that starts with `///` and is otherwise blank. \n*Single asterisks* and _single underscores_ surround text that should be rendered in italic/oblique type. \n**Double asterisks** and __double underscores__ surround text that should be rendered in boldface. \nNames of symbols or inline code are surrounded in ``backticks`` . \nMulti-line code (such as example usage) is denoted by placing three backticks ( `` `` `) on the lines before and after the code block."
            }
        ]
    },
    {
        "title": "Where to Document",
        "belongs to": "Documentation Comments/Where to Document",
        "cases": [
            {
                "description": "At a minimum, documentation comments are present for every open or public declaration, and every open or public member of such a declaration, with specific exceptions noted below:\nIndividual cases of an `enum` often are not documented if their meaning is self-explanatory from their name. Cases with associated values, however, should document what those values mean if it is not obvious. \nA documentation comment is not always present on a declaration that overrides a supertype declaration or implements a protocol requirement, or on a declaration that provides the default implementation of a protocol requirement in an extension. \nIt is acceptable to document an overridden declaration to describe new behavior from the declaration that it overrides. In no case should the documentation for the override be a mere copy of the base declaration‚Äôs documentation. \nA documentation comment is not always present on test classes and test methods. However, they can be useful for functional test classes and for helper classes/methods shared by multiple tests. \nA documentation comment is not always present on an extension declaration (that is, the `extension` itself). You may choose to add one if it help clarify the purpose of the extension, but avoid meaningless or misleading comments. \nIn the following example, the comment is just repetition of what is already obvious from the source code:",
                "example": "/// Add `Equatable` conformance.\nextension MyType: Equatable {\n  // ...\n}\n"
            },
            {
                "description": "The next example is more subtle, but it is an example of documentation that is not scalable because the extension or the conformance could be updated in the future. Consider that the type may be made `Comparable` at the time of that writing in order to sort the values, but that is not the only possible use of that conformance and client code could use it for other purposes in the future.",
                "example": "/// Make `Candidate` comparable so that they can be sorted.\nextension Candidate: Comparable {\n  // ...\n}\n"
            },
            {
                "description": "In general, if you find yourself writing documentation that simply repeats information that is obvious from the source and sugaring it with words like ‚Äúa representation of,‚Äù then leave the comment out entirely.\nHowever, it is not appropriate to cite this exception to justify omitting relevant information that a typical reader might need to know. For example, for a property named `canonicalName` , don‚Äôt omit its documentation (with the rationale that it would only say `///Thecanonicalname.` ) if a typical reader may have no idea what the term ‚Äúcanonical name‚Äù means in that context. Use the documentation as an opportunity to define the term."
            }
        ]
    }
]