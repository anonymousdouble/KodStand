Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. 

1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. 
2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.
3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. 

CheckStyle Rule:
Rulename
Indentation
Description

Checks correct indentation of Java code.


The idea behind this is that while pretty printers are
sometimes convenient for bulk reformats of legacy code, they often
either aren't configurable enough or just can't anticipate how
format should be done. Sometimes this is personal preference, other
times it is practical experience. In any case, this check should
just ensure that a minimal set of indentation rules is followed.


Basic offset indentation is used for indentation inside code blocks.
For any lines that span more than 1, line wrapping indentation is used for those
lines after the first.
Brace adjustment, case, and throws indentations are all used only if those specific
identifiers start the line. If, for example, a brace is used in the middle of the line,
its indentation will not take effect.
All indentations have an accumulative/recursive effect when they are triggered. If
during a line wrapping, another code block is found and it doesn't end on that same
line, then the subsequent lines afterwards, in that new code block, are increased on
top of the line wrap and any indentations above it.

Example:


if ((condition1 && condition2)
|| (condition3 && condition4)    // line wrap with bigger indentation
||!(condition5 && condition6)) { // line wrap with bigger indentation
field.doSomething()                    // basic offset
.doSomething()                     // line wrap
.doSomething( c -> {               // line wrap
return c.doSome();               // basic offset
});
}
Options
Properties



name
description
type
default value
since


arrayInitIndent
Specify how far an array initialization should be indented when on next line.
int
4
5.8


basicOffset
Specify how far new indentation level should be indented when on the next line.
int
4
3.1


braceAdjustment
Specify how far a braces should be indented when on the next line.
int
0
3.1


caseIndent
Specify how far a case label should be indented when on next line.
int
4
3.1


forceStrictCondition
Force strict indent level in line wrapping case. If value is true, line wrap indent have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like.
boolean
false
6.3


lineWrappingIndentation
Specify how far continuation line should be indented when line-wrapping is present.
int
4
5.9


throwsIndent
Specify how far a throws clause should be indented when on next line.
int
4
5.7

Grammar:
RuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups
Rule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means if Rule1 then Rule2
ExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule
Operator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'
TermList ::= Term [, Term]*
Modifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...
Term :: = JavaTerm | Modifier* Term | Term of Term
JavaTerm means the formal expression using such format [XXX] "XXX" represent a JavaTerm


For Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. 

CheckStyle Rule:
Rulename:
NeedBraces

Description
Checks for braces around code blocks.

Options:
allowEmptyLoopBody, Allow loops with empty bodies., boolean, false
allowSingleLineStatement, Allow single-line statements without braces., boolean, false
tokens, tokens to check, subset of tokens

LITERAL_DO
,
LITERAL_ELSE
,
LITERAL_FOR
,
LITERAL_IF
,
LITERAL_WHILE
,
LITERAL_CASE
,
LITERAL_DEFAULT
,
LAMBDA
.
,

LITERAL_DO
,
LITERAL_ELSE
,
LITERAL_FOR
,
LITERAL_IF
,
LITERAL_WHILE
.

Final RuleSet Representation:
Basic Rule:
{{tokens}} has [Brace] 

Option Rule:
allowEmptyLoopBody option:
False: Mandatory: [body] of {{tokens}} is not [Null]
True: Optional: [body] of {{tokens}} is [Null]

allowSingleLineStatement option:
False: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] 
True: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]

=======================================================
Final RuleSet Representation:
Basic Rule:
{{Indentation}} has [Correct] 

Option Rule:
arrayInitIndent option:
Mandatory: [array initialization] of {{Indentation}} is [indented] by [int] spaces

basicOffset option:
Mandatory: [new indentation level] of {{Indentation}} is [indented] by [int] spaces

braceAdjustment option:
Mandatory: [braces] of {{Indentation}} is [indented] by [int] spaces

caseIndent option:
Mandatory: [case label] of {{Indentation}} is [indented] by [int] spaces

forceStrictCondition option:
Mandatory: [line wrapping indent] of {{Indentation}} is [same as] [lineWrappingIndentation] parameter

lineWrappingIndentation option:
Mandatory: [continuation line] of {{Indentation}} is [indented] by [int] spaces

throwsIndent option:
Mandatory: [throws clause] of {{Indentation}} is [indented] by [int] spaces