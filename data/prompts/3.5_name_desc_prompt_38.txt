Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
5.2.5 Non-constant field names
Non-constant field names (static or otherwise) are written in lowerCamelCase .
 These names are typically nouns or noun phrases. For example, `computedValues` or `index` .

CheckStyle Rules:
[Rule]
ConstantName
[Description]
Checks that constant names conform to a specified pattern.
A constant is a static and final field or an
interface/annotation field, except serialVersionUID and
serialPersistentFields.
[Rule]
StaticVariableName
[Description]
Checks that static, non-final variable names
conform to a specified pattern.
[Rule]
AbbreviationAsWordInName
[Description]
Validates abbreviations (consecutive capital letters) length in identifier name,
it also allows to enforce camel case naming. Please read more at

Google Style Guide
to get to know how to avoid long abbreviations in names.

'_' is considered as word separator in identifier name.

allowedAbbreviationLength specifies how many consecutive capital letters are
allowed in the identifier.
A value of 3 indicates that up to 4 consecutive capital letters are allowed,
one after the other, before a violation is printed. The identifier 'MyTEST' would be
allowed, but 'MyTESTS' would not be.
A value of 0 indicates that only 1 consecutive capital letter is allowed. This
is what should be used to enforce strict camel casing. The identifier 'MyTest' would
be allowed, but 'MyTEst' would not be.


ignoreFinal, ignoreStatic, and ignoreStaticFinal
control whether variables with the respective modifiers are to be ignored.
Note that a variable that is both static and final will always be considered under
ignoreStaticFinal only, regardless of the values of ignoreFinal
and ignoreStatic. So for example if ignoreStatic is true but
ignoreStaticFinal is false, then static final variables will not be ignored.
[Rule]
MagicNumber
[Description]
Checks that there are no

"magic numbers" where a magic
number is a numeric literal that is not defined as a constant.
By default, -1, 0, 1, and 2 are not considered to be magic numbers.


Constant definition is any variable/field that has 'final' modifier.
It is fine to have one constant defining multiple numeric literals within one expression:



static final int SECONDS_PER_DAY = 24 * 60 * 60;
static final double SPECIAL_RATIO = 4.0 / 3.0;
static final double SPECIAL_SUM = 1 + Math.E;
static final double SPECIAL_DIFFERENCE = 4 - Math.PI;
static final Border STANDARD_BORDER = BorderFactory.createEmptyBorder(3, 3, 3, 3);
static final Integer ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE = new Integer(42);
[Rule]
MemberName
[Description]
Checks that instance variable names conform to a specified pattern.
[Rule]
LocalVariableName
[Description]
Checks that local, non-final variable names conform to a specified pattern.
A catch parameter is considered to be a local variable.
[Rule]
RequireThis
[Description]
Checks that references to instance variables and methods of the present
object are explicitly of the form "this.varName" or
"this.methodName(args)" and that those references don't
rely on the default behavior when "this." is absent.


Warning: the Check is very controversial if 'validateOnlyOverlapping' option is set to
'false' and not that actual nowadays.


Rationale:



The same notation/habit for C++ and Java (C++ have global methods, so having
"this." do make sense in it to distinguish call of method of class
instead of global).


Non-IDE development (ease of refactoring, some clearness to distinguish
static and non-static methods).
[Rule]
DeclarationOrder
[Description]
Checks that the parts of a class, record, or interface declaration appear in the order
suggested by the

Code Conventions for the Java Programming Language.


According to

Code Conventions for the Java Programming Language , the parts
of a class or interface declaration should appear in the following
order:



Class (static) variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.


Instance variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.

Constructors
Methods


Purpose of ignore* option is to ignore related violations,
however it still impacts on other class members.


ATTENTION: the check skips class fields which have

forward references
from validation due to the fact that we have Checkstyle's limitations to clearly
detect user intention of fields location and grouping. For example:



public class A {
private double x = 1.0;
private double y = 2.0;
public double slope = x / y; // will be skipped from validation due to forward reference
}
[Rule]
LambdaParameterName
[Description]
Checks lambda parameter names.
[Rule]
IllegalIdentifierName
[Description]
Checks identifiers with a pattern for a set of illegal names, such as those
that are restricted or contextual keywords. Examples include "yield", "record",
"_", and "var". Please read more at

Java Language Specification
to get to know more about restricted keywords. Since this check uses a
pattern to specify valid identifiers, users can also prohibit the usage
of certain symbols, such as "$", or any non-ascii character.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
