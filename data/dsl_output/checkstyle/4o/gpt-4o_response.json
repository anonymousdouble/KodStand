{
    "PackageDeclaration": "Final RuleSet Representation:\nBasic Rule:\n{{PackageDeclaration}} has [PackageDeclaration]\n\nOption Rule:\nmatchDirectoryStructure option:\nFalse: Mandatory: [package name] of {{PackageDeclaration}} is not [directory name]\nTrue: Optional: [package name] of {{PackageDeclaration}} is [directory name]",
    "VisibilityModifier": "Final RuleSet Representation:\nBasic Rule:\n{{VisibilityModifier}} has [Visibility] \n\nOption Rule:\nallowPublicFinalFields option:\nFalse: Mandatory: [field] of {{VisibilityModifier}} is not [Public] or [Final]\nTrue: Optional: [field] of {{VisibilityModifier}} is [Public] and [Final]\n\nallowPublicImmutableFields option:\nFalse: Mandatory: [field] of {{VisibilityModifier}} is not [Public] or [Immutable]\nTrue: Optional: [field] of {{VisibilityModifier}} is [Public] and [Immutable]\n\nignoreAnnotationCanonicalNames option:\nMandatory: [annotation] of {{VisibilityModifier}} is not [IgnoreAnnotationCanonicalNames]\n\nimmutableClassCanonicalNames option:\nMandatory: [class] of {{VisibilityModifier}} is not [ImmutableClassCanonicalNames]\n\npackageAllowed option:\nFalse: Mandatory: [member] of {{VisibilityModifier}} is not [PackageVisible]\nTrue: Optional: [member] of {{VisibilityModifier}} is [PackageVisible]\n\nprotectedAllowed option:\nFalse: Mandatory: [member] of {{VisibilityModifier}} is not [Protected]\nTrue: Optional: [member] of {{VisibilityModifier}} is [Protected]\n\npublicMemberPattern option:\nMandatory: [member] of {{VisibilityModifier}} does not match [PublicMemberPattern]\n\nExplanation:\n- The basic rule checks for the visibility of class members.\n- The options define different conditions for allowing certain types of fields or members to have specific visibility modifiers.\n- Each option is parsed to determine whether the condition is mandatory or optional based on the specified values.\n- The rules are structured to ensure that the visibility of class members follows the specified criteria, enforcing encapsulation and good coding practices.",
    "Indentation": "Final RuleSet Representation:\nBasic Rule:\nIndentation -> Mandatory: [JavaCode] has [CorrectIndentation]\n\nOption Rule:\narrayInitIndent option:\nMandatory: [ArrayInitialization] is [Indented] by [4]\nOptional: [ArrayInitialization] is not [Indented] by [4]\n\nbasicOffset option:\nMandatory: [NewIndentationLevel] is [Indented] by [4]\nOptional: [NewIndentationLevel] is not [Indented] by [4]\n\nbraceAdjustment option:\nMandatory: [Braces] are [Indented] by [0]\nOptional: [Braces] are not [Indented] by [0]\n\ncaseIndent option:\nMandatory: [CaseLabel] is [Indented] by [4]\nOptional: [CaseLabel] is not [Indented] by [4]\n\nforceStrictCondition option:\nMandatory: [LineWrapIndent] is [SameAs] [LineWrappingIndentation]\nOptional: [LineWrapIndent] can be [Bigger] than [LineWrappingIndentation]\n\nlineWrappingIndentation option:\nMandatory: [ContinuationLine] is [Indented] by [4]\nOptional: [ContinuationLine] is not [Indented] by [4]\n\nthrowsIndent option:\nMandatory: [ThrowsClause] is [Indented] by [4]\nOptional: [ThrowsClause] is not [Indented] by [4]\n\nExplanation:\nThe basic rule of the Indentation CheckStyle rule is to ensure that Java code has correct indentation. The options provided allow for configuring different aspects of the indentation rules. Each option specifies a mandatory rule for how a specific type of indentation should be handled and an optional rule for the opposite case. For example, the arrayInitIndent option mandates that array initializations should be indented by 4 spaces, while the basicOffset option mandates that new indentation levels should also be indented by 4 spaces. The braceAdjustment option specifies that braces should not be indented, and the caseIndent option specifies that case labels should be indented by 4 spaces. The forceStrictCondition option enforces strict indentation levels in line wrapping cases. The lineWrappingIndentation option specifies how continuation lines should be indented when line-wrapping is present, and the throwsIndent option specifies how throws clauses should be indented. Each option provides both mandatory and optional rules to cover different scenarios related to indentation.",
    "OneTopLevelClass": "Based on the provided CheckStyle Rule for \"OneTopLevelClass,\" let's analyze and parse it using the given Grammar:\n\n1. Description Analysis:\n- The description contains a rule: \"Checks that each top-level class, interface, enum or annotation resides in a source file of its own.\" This rule is mandatory as it specifies a required check for the presence of each top-level entity in a separate source file.\n- The description also provides an official definition of a 'top-level' term, which is not a rule but rather an informative explanation.\n\n2. Options Analysis:\n- There are no configurable options provided in the CheckStyle Rule for \"OneTopLevelClass,\" so there are no additional rules to parse for options.\n\n3. Rule Generation:\nBased on the analysis, the rule for \"OneTopLevelClass\" can be represented as follows:\n\nBasic Rule:\nMandatory: Each top-level class, interface, enum, or annotation must reside in a source file of its own.\n\nExplanation:\nThis rule enforces the best practice of having each top-level entity in a separate source file, promoting better organization and maintainability of the codebase.\n\nExplanation of Logic:\nThe rule ensures that each top-level entity is contained in its own source file, which helps in better structuring and understanding of the codebase. By adhering to this rule, developers can maintain a clear and organized project structure, making it easier to navigate and manage the code.",
    "MissingDeprecated": "Based on the provided CheckStyle Rule for \"MissingDeprecated,\" let's analyze and parse it using the given Grammar:\n\n1. Description Analysis:\n- The description contains explanations and examples of the purpose and usage of the rule. It does not explicitly state mandatory or optional rules.\n\n2. Option Analysis:\n- The only option in this rule is \"violateExecutionOnNonTightHtml.\"\n- This option is not a rule but a configurable term to control when to print violations based on the Javadoc being examined.\n\n3. Parsing the Rule:\n- RuleSet: MissingDeprecated\n- Rule: Mandatory: [Annotation @Deprecated] and [Javadoc tag @deprecated] are both present when either of them is present.\n- ExceptionRule: None\n- Operator: None\n\n4. Explanation:\n- The rule \"MissingDeprecated\" enforces the presence of both the @Deprecated annotation and the @deprecated Javadoc tag when either of them is present in the code.\n- The purpose is to ensure that deprecation is properly documented and flagged in the codebase.\n- The option \"violateExecutionOnNonTightHtml\" controls when violations are printed based on Javadoc rules.\n\nIn summary, the \"MissingDeprecated\" rule ensures consistent deprecation handling in Java code, requiring both forms of deprecation markers to be present when one is used. The option provides additional control over violation printing based on Javadoc rules.",
    "JavadocVariable": "Based on the provided CheckStyle Rule for JavadocVariable, let's analyze and parse it using the given Grammar:\n\n1. Description Analysis:\n- The Description contains rules that are mandatory.\n- The rule is to check that a variable has a Javadoc comment, ignoring serialVersionUID fields.\n\n2. Options Analysis:\n- excludeScope: This option is a configurable term to specify the visibility scope where Javadoc comments are not checked. It is not a rule.\n- ignoreNamePattern: This option is a configurable term to specify the regular expression to define variable names to ignore. It is not a rule.\n- scope: This option is a configurable term to specify the visibility scope where Javadoc comments are checked. It is not a rule.\n- tokens: This option is a configurable term to specify the tokens to check. It is not a rule.\n\n3. Rule Generation:\nBasic Rule:\n- Mandatory: [variable] has [Javadoc comment]\n\nOption Rule:\n- excludeScope: Not a rule, used for configuration.\n- ignoreNamePattern: Not a rule, used for configuration.\n- scope: Not a rule, used for configuration.\n- tokens: Not a rule, used for configuration.\n\nExplanation:\nThe rule JavadocVariable enforces that each variable has a Javadoc comment, except for serialVersionUID fields. The Description provides the mandatory rule for this CheckStyle. The Options are used for configuration purposes and do not represent rules to be parsed. The generated Basic Rule enforces the presence of Javadoc comments for variables.",
    "NoEnumTrailingComma": "Final RuleSet Representation:\nBasic Rule:\n{{tokens}} does not have [TrailingComma] \n\nExplanation:\nThe rule \"NoEnumTrailingComma\" enforces that enum definitions do not contain a trailing comma. The rationale behind this rule is to maintain a consistent coding style as per the Java Language Specification (JLS), which allows trailing commas in arrays and enumerations but not in other locations. The rule ensures that there should not be any comma after the last constant in an enum definition.\n\nOption Rule:\nexcludeScope option:\nMandatory: [Javadoc] of {{tokens}} is not [Null]\n\nignoreNamePattern option:\nMandatory: [Javadoc] of {{tokens}} is not [Null]\n\nscope option:\nMandatory: [Javadoc] of {{tokens}} is not [Null]\n\ntokens option:\nMandatory: [Javadoc] of {{tokens}} is not [Null]\n\nExplanation:\nThe options provided for the \"NoEnumTrailingComma\" rule are not rules themselves but configurations to specify the behavior of the rule. The rule itself enforces the absence of trailing commas in enum definitions, and the options allow customization of the rule's behavior based on the specified configurations. Each option is mandatory as they are essential for defining the scope and behavior of the rule.",
    "UniqueProperties": "Based on the provided CheckStyle Rule for UniqueProperties, let's analyze and parse it using the given Grammar:\n\n1. Description Analysis:\n- The Description states the purpose of the rule, which is to detect duplicated keys in properties files. This is a mandatory rule as it defines the primary objective of the CheckStyle rule.\n- The Rationale explains the reason behind the rule, emphasizing the confusion that can arise from having different values for duplicated properties. This is also a mandatory rule as it provides context for the rule.\n\n2. Option Analysis:\n- fileExtensions is a configurable term that specifies the file extensions of the files to process. This is not a rule but a configurable option to customize the behavior of the CheckStyle rule.\n\n3. Rule Generation:\nBased on the grammar provided, we can generate the rule for the UniqueProperties CheckStyle rule:\n\nBasic Rule:\n- Mandatory: [properties file] has [unique keys]\n\nOption Rule:\n- fileExtensions option:\n  - Default: Mandatory: [file] of [properties file] is [properties]\n\nExplanation:\nThe basic rule enforces that a properties file should have unique keys, ensuring that there are no duplicated keys within the file. The fileExtensions option allows users to specify the file extensions of the files to be processed. By default, the rule expects the files to have a .properties extension.\n\nThis rule helps maintain consistency and clarity in properties files by preventing the presence of duplicate keys, which can lead to confusion and errors in the application configuration.",
    "JavadocTagContinuationIndentation": "Final RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n\nExplanation:\nThe CheckStyle rule \"NeedBraces\" is designed to check for the presence of braces around code blocks. The basic rule states that the specified tokens should have braces. The options provided allow customization of the behavior based on whether empty loop bodies are allowed and whether single-line statements without braces are allowed. \n\nFor the \"allowEmptyLoopBody\" option, when set to false, it is mandatory that the body of the specified tokens is not null, meaning it should have content. When set to true, it is optional for the body of the tokens to be null, indicating that empty loop bodies are allowed.\n\nRegarding the \"allowSingleLineStatement\" option, when set to false, it is mandatory that the number of statements in the body of the tokens is 1, and in that case, the tokens should have braces. When set to true, it is optional for the number of statements in the body of the tokens to be 1, and in that case, the tokens should not have braces.\n\nThese rules and options provide flexibility in enforcing coding standards related to brace usage in code blocks.",
    "LambdaParameterName": "Based on the provided CheckStyle Rule for LambdaParameterName, let's analyze and parse it using the given Grammar:\n\n1. Description Analysis:\n- The description states that the rule checks lambda parameter names. This is a mandatory rule as it defines the purpose of the CheckStyle rule.\n\n2. Option Analysis:\n- The only option provided is \"format\" which sets the pattern to match valid identifiers. This option is a configurable term and not a rule, as it does not define a specific condition to be enforced but rather a pattern to be used for validation.\n\n3. Rule Generation:\nBased on the grammar provided, we can generate the rule for the LambdaParameterName CheckStyle rule:\n\nRuleSet:\n- Mandatory: LambdaParameterName\n\nRule:\n- Optional: 'format' of JavaTerm is \"^[a-z][a-zA-Z0-9]*$\"\n\nExplanation:\n- The rule ensures that lambda parameter names match the pattern \"^[a-z][a-zA-Z0-9]*$\", where the first character should be a lowercase letter followed by alphanumeric characters.\n\nThis rule is important for maintaining consistency and readability in codebases where lambda expressions are used.\n\nOverall, the LambdaParameterName CheckStyle rule enforces a specific naming convention for lambda parameters, ensuring that they adhere to a defined pattern."
}