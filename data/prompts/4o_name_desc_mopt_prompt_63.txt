Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.8.3.2 No C-style array declarations
The square brackets form a part of the type, not the variable: String[] args, not String args[].

CheckStyle Rules:
[Rule]
ArrayTypeStyle
[Description]
Checks the style of array type definitions. Some like Java style:
public static void main(String[] args) and some like
C style: public static void main(String args[]).


By default, the Check enforces Java style.


This check strictly enforces only Java style for method return types
regardless of the value for 'javaStyle'. For example, byte[] getData().
This is because C doesn't compile methods with array declarations on the name.
[Options]
javaStyle, Control whether to enforce Java style (true) or C style (false).
[Rule]
NoArrayTrailingComma
[Description]
Checks that array initialization do not contain a trailing comma.
Rationale: JLS allows trailing commas in arrays and enumerations, but does not allow
them in other locations. To unify the coding style, the use of trailing commas should
be prohibited.



int[] foo = new int[] {
1,
2
};


The check demands that there should not be any comma after the last element of an array.



String[] foo = new String[] {
"FOO",
"BAR", //violation
}
[Options]
[Rule]
UnusedLocalVariable
[Description]
Checks that a local variable is declared and/or assigned, but not used.
Doesn't support pattern variables yet.
Doesn't check array components as array
components are classified as different kind of variables by JLS.
[Options]
[Rule]
InnerAssignment
[Description]
Checks for assignments in subexpressions, such as in
String s = Integer.toString(i = 2);.


Rationale: Except for the loop idioms,
all assignments should occur in their own top-level statement
to increase readability. With inner assignments like the one given above, it is difficult
to see all places where a variable is set.


Note: Check allows usage of the popular assignments in loops:



String line;
while ((line = bufferedReader.readLine()) != null) { // OK
// process the line
}

for (;(line = bufferedReader.readLine()) != null;) { // OK
// process the line
}

do {
// process the line
}
while ((line = bufferedReader.readLine()) != null); // OK


Assignment inside a condition is not a problem here, as the assignment is surrounded by
an extra pair of parentheses. The comparison is != null and there is no
chance that intention was to write line == reader.readLine().
[Options]
[Rule]
ParameterAssignment
[Description]
Disallows assignment of parameters.

Rationale: Parameter assignment is often considered poor programming
practice. Forcing developers to declare parameters as final is often
onerous. Having a check ensure that parameters are never assigned
would give the best of both worlds.
[Options]
[Rule]
ArrayTrailingComma
[Description]
Checks that array initialization contains a trailing comma.



int[] a = new int[]
{
1,
2,
3,
};


By default, the check demands a comma at the end if neither left nor right curly braces
are on the same line as the last element of the array.



return new int[] { 0 };
return new int[] { 0
};
return new int[] {
0 };


Rationale: Putting this comma in makes it easier to change the order
of the elements or add new elements on the end. Main benefit of a trailing
comma is that when you add new entry to an array, no surrounding lines are changed.



{
100000000000000000000,
200000000000000000000, // OK
}

{
100000000000000000000,
200000000000000000000,
300000000000000000000,  // Just this line added, no other changes
}


If closing brace is on the same line as trailing comma, this benefit is gone
(as the check does not demand a certain location of curly braces the following
two cases will not produce a violation):



{100000000000000000000,
200000000000000000000,} // Trailing comma not needed, line needs to be modified anyway

{100000000000000000000,
200000000000000000000, // Modified line
300000000000000000000,} // Added line


If opening brace is on the same line as trailing comma there's also (more arguable)
problem:



{100000000000000000000, // Line cannot be just duplicated to slightly modify entry
}

{100000000000000000000,
100000000000000000001, // More work needed to duplicate
}
[Options]
alwaysDemandTrailingComma, Control whether to always check for a trailing comma, even when an array is inline.
[Rule]
StringLiteralEquality
[Description]
Checks that string literals are not used with == or
!=.
Since == will compare the object references,
not the actual value of the strings,
String.equals() should be used.
More information can be found

in this article.


Rationale: Novice Java programmers often use code like:



if (x == "something")

when they mean


if ("something".equals(x))
[Options]
[Rule]
MultipleVariableDeclarations
[Description]
Checks that each variable declaration is in its own statement and on
its own line.


Rationale:

the Java code conventions chapter 6.1 recommends that
declarations should be one per line/statement.
[Options]
[Rule]
NoFinalizer
[Description]
Checks that there is no method finalize with zero parameters.

See
Object.finalize()


Rationale: Finalizers are unpredictable, often dangerous, and generally unnecessary.
Their use can cause erratic behavior, poor performance, and portability problems.
For more information for the finalize method and its issues, see Effective Java:
Programming Language Guide Third Edition by Joshua Bloch, ¡ì8.
[Options]
[Rule]
AvoidStaticImport
[Description]
Checks that there are no static import statements.


Rationale: Importing static members can lead to naming
conflicts between class' members. It may lead to poor code
readability since it may no longer be clear what class a
member resides in (without looking at the import statement).
[Options]
excludes, Control whether to allow for certain classes via a star notation to be excluded such as java.lang.Math.* or specific static members to be excluded like java.lang.System.out for a variable or java.lang.Math.random for a method. See notes section for details.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
