[
    {
        "title": "About",
        "belongs to": "About",
        "cases": [
            {
                "description": "This document contains style decisions intended to unify and provide standard\nguidance, explanations, and examples for the advice given by the Go readability\nmentors.\nThis document is not exhaustive and will grow over time. In cases where the core style guide contradicts the advice given here, the style\nguide takes precedence , and this document should be updated accordingly.\nSee the Overview for the full\nset of Go Style documents.\nThe following sections have moved from style decisions to another part of the\nguide:\nMixedCaps : see guide#mixed-caps \n\n\n\n\n\n\nFormatting : see guide#formatting \n\n\n\n\n\n\nLine Length : see guide#line-length"
            }
        ]
    },
    {
        "title": "Naming",
        "belongs to": "Naming",
        "cases": [
            {
                "description": "See the naming section within the core style guide for\noverarching guidance on naming. The following sections provide further\nclarification on specific areas within naming."
            }
        ]
    },
    {
        "title": "Underscores",
        "belongs to": "Naming/Underscores",
        "cases": [
            {
                "description": "Names in Go should in general not contain underscores. There are three\nexceptions to this principle:\nPackage names that are only imported by generated code may contain\nunderscores. See package names for more detail around how\nto choose multi-word package names. \nTest, Benchmark and Example function names within `*_test.go`files may\ninclude underscores. \nLow-level libraries that interoperate with the operating system or cgo may\nreuse identifiers, as is done in \n`syscall`\n. This is expected to be very\nrare in most codebases."
            }
        ]
    },
    {
        "title": "Package names",
        "belongs to": "Naming/Package names",
        "cases": [
            {
                "description": "Go package names should be short and contain only lowercase letters. A package\nname composed of multiple words should be left unbroken in all lowercase. For\nexample, the package \n`tabwriter`\nis not named `tabWriter`, `TabWriter`, or `tab_writer`.\nAvoid selecting package names that are likely to be shadowed by commonly used\nlocal variable names. For example, `usercount`is a better package name than `count`, since `count`is a commonly used variable name.\nGo package names should not have underscores. If you need to import a package\nthat does have one in its name (usually from generated or third party code), it\nmust be renamed at import time to a name that is suitable for use in Go code.\nAn exception to this is that package names that are only imported by generated\ncode may contain underscores. Specific examples include:\nUsing the `_test`suffix for an external test package, for example an\nintegration test \n\n\nUsing the `_test`suffix for package-level documentation examples\nAvoid uninformative package names like `util`, `utility`, `common`, `helper`,\nand so on. See more about so-called “utility packages” .\nWhen an imported package is renamed (e.g. `importfoopb\"path/to/foo_go_proto\"`), the local name for the package must comply with the\nrules above, as the local name dictates how the symbols in the package are\nreferenced in the file. If a given import is renamed in multiple files,\nparticularly in the same or nearby packages, the same local name should be used\nwherever possible for consistency.\nSee also: Go blog post about package names ."
            }
        ]
    },
    {
        "title": "Receiver names",
        "belongs to": "Naming/Receiver names",
        "cases": [
            {
                "description": "Receiver variable names must be:\nShort (usually one or two letters in length) \nAbbreviations for the type itself \nApplied consistently to every receiver for that type\nLong Name \nBetter Name \n\n\n\n\n\n`func(trayTray)`\n\n\n`func(tTray)`\n\n\n\n\n`func(info*ResearchInfo)`\n\n\n`func(ri*ResearchInfo)`\n\n\n\n\n`func(this*ReportWriter)`\n\n\n`func(w*ReportWriter)`\n\n\n\n\n`func(self*Scanner)`\n\n\n`func(s*Scanner)`"
            }
        ]
    },
    {
        "title": "Constant names",
        "belongs to": "Naming/Constant names",
        "cases": [
            {
                "description": "Constant names must use MixedCaps like all other names in Go. ( Exported constants start with uppercase, while unexported constants start with\nlowercase.) This applies even when it breaks conventions in other languages.\nConstant names should not be a derivative of their values and should instead\nexplain what the value denotes.",
                "example": "// Good:\nconst MaxPacketSize = 512\n\nconst (\n    ExecuteBit = 1 << iota\n    WriteBit\n    ReadBit\n)\n"
            },
            {
                "description": "Do not use non-MixedCaps constant names or constants with a `K`prefix.",
                "example": "// Bad:\nconst MAX_PACKET_SIZE = 512\nconst kMaxBufferSize = 1024\nconst KMaxUsersPergroup = 500\n"
            },
            {
                "description": "Name constants based on their role, not their values. If a constant does not\nhave a role apart from its value, then it is unnecessary to define it as a\nconstant.",
                "example": "// Bad:\nconst Twelve = 12\n\nconst (\n    UserNameColumn = \"username\"\n    GroupColumn    = \"group\"\n)\n"
            }
        ]
    },
    {
        "title": "Initialisms",
        "belongs to": "Naming/Initialisms",
        "cases": [
            {
                "description": "Words in names that are initialisms or acronyms (e.g., `URL`and `NATO`) should\nhave the same case. `URL`should appear as `URL`or `url`(as in `urlPony`, or `URLPony`), never as `Url`. This also applies to `ID`when it is short for\n“identifier”; write `appID`instead of `appId`.\nIn names with multiple initialisms (e.g. `XMLAPI`because it contains `XML`and `API`), each letter within a given initialism should have the same case,\nbut each initialism in the name does not need to have the same case. \nIn names with an initialism containing a lowercase letter (e.g. `DDoS`, `iOS`, `gRPC`), the initialism should appear as it would in standard prose,\nunless you need to change the first letter for the sake of exportedness .\nIn these cases, the entire initialism should be the same case (e.g. `ddos`, `IOS`, `GRPC`).\nInitialism(s) \nScope \nCorrect \nIncorrect \n\n\n\n\nXML API \nExported \n\n`XMLAPI`\n\n\n`XmlApi`, `XMLApi`, `XmlAPI`, `XMLapi`\n\n\n\nXML API \nUnexported \n\n`xmlAPI`\n\n\n`xmlapi`, `xmlApi`\n\n\n\niOS \nExported \n\n`IOS`\n\n\n`Ios`, `IoS`\n\n\n\niOS \nUnexported \n\n`iOS`\n\n\n`ios`\n\n\n\ngRPC \nExported \n\n`GRPC`\n\n\n`Grpc`\n\n\n\ngRPC \nUnexported \n\n`gRPC`\n\n\n`grpc`\n\n\n\nDDoS \nExported \n\n`DDoS`\n\n\n`DDOS`, `Ddos`\n\n\n\nDDoS \nUnexported \n\n`ddos`\n\n\n`dDoS`, `dDOS`"
            }
        ]
    },
    {
        "title": "Getters",
        "belongs to": "Naming/Getters",
        "cases": [
            {
                "description": "Function and method names should not use a `Get`or `get`prefix, unless the\nunderlying concept uses the word “get” (e.g. an HTTP GET). Prefer starting the\nname with the noun directly, for example use `Counts`over `GetCounts`.\nIf the function involves performing a complex computation or executing a remote\ncall, a different word like `Compute`or `Fetch`can be used in place of `Get`,\nto make it clear to a reader that the function call may take time and could\nblock or fail."
            }
        ]
    },
    {
        "title": "Variable names",
        "belongs to": "Naming/Variable names",
        "cases": [
            {
                "description": "The general rule of thumb is that the length of a name should be proportional to\nthe size of its scope and inversely proportional to the number of times that it\nis used within that scope. A variable created at file scope may require multiple\nwords, whereas a variable scoped to a single inner block may be a single word or\neven just a character or two, to keep the code clear and avoid extraneous\ninformation.\nHere is a rough baseline. These numeric guidelines are not strict rules. Apply\njudgement based on context, clarity , and concision .\nA small scope is one in which one or two small operations are performed, say\n1-7 lines. \nA medium scope is a few small or one large operation, say 8-15 lines. \nA large scope is one or a few large operations, say 15-25 lines. \nA very large scope is anything that spans more than a page (say, more than\n25 lines).\nA name that might be perfectly clear (e.g., `c`for a counter) within a small\nscope could be insufficient in a larger scope and would require clarification to\nremind the reader of its purpose further along in the code. A scope in which\nthere are many variables, or variables that represent similar values or\nconcepts, may necessitate longer variable names than the scope suggests.\nThe specificity of the concept can also help to keep a variable’s name concise.\nFor example, assuming there is only a single database in use, a short variable\nname like `db`that might normally be reserved for very small scopes may remain\nperfectly clear even if the scope is very large. In this case, a single word `database`is likely acceptable based on the size of the scope, but is not\nrequired as `db`is a very common shortening for the word with few alternate\ninterpretations.\nThe name of a local variable should reflect what it contains and how it is being\nused in the current context, rather than where the value originated. For\nexample, it is often the case that the best local variable name is not the same\nas the struct or protocol buffer field name.\nIn general:\nSingle-word names like `count`or `options`are a good starting point. \nAdditional words can be added to disambiguate similar names, for example `userCount`and `projectCount`. \nDo not simply drop letters to save typing. For example `Sandbox`is\npreferred over `Sbx`, particularly for exported names. \nOmit types and type-like words from most variable names. \nFor a number, `userCount`is a better name than `numUsers`or `usersInt`. \nFor a slice, `users`is a better name than `userSlice`. \nIt is acceptable to include a type-like qualifier if there are two\nversions of a value in scope, for example you might have an input stored\nin `ageString`and use `age`for the parsed value. \n\n\nOmit words that are clear from the surrounding context . For example, in\nthe implementation of a `UserCount`method, a local variable called `userCount`is probably redundant; `count`, `users`, or even `c`are just as\nreadable."
            }
        ]
    },
    {
        "title": "Single-letter variable names",
        "belongs to": "Naming/Variable names/Single-letter variable names",
        "cases": [
            {
                "description": "Single-letter variable names can be a useful tool to minimize repetition , but can also make code needlessly opaque. Limit their\nuse to instances where the full word is obvious and where it would be repetitive\nfor it to appear in place of the single-letter variable.\nIn general:\nFor a method receiver variable , a one-letter or two-letter name is\npreferred. \nUsing familiar variable names for common types is often helpful: \n\n`r`for an `io.Reader`or `*http.Request`\n\n\n`w`for an `io.Writer`or `http.ResponseWriter`\n\n\n\nSingle-letter identifiers are acceptable as integer loop variables,\nparticularly for indices (e.g., `i`) and coordinates (e.g., `x`and `y`). \nAbbreviations can be acceptable loop identifiers when the scope is short,\nfor example `for_,n:=rangenodes{...}`."
            }
        ]
    },
    {
        "title": "Repetition",
        "belongs to": "Naming/Variable names/Repetition",
        "cases": [
            {
                "description": "A piece of Go source code should avoid unnecessary repetition. One common source\nof this is repetitive names, which often include unnecessary words or repeat\ntheir context or type. Code itself can also be unnecessarily repetitive if the\nsame or a similar code segment appears multiple times in close proximity.\nRepetitive naming can come in many forms, including:"
            }
        ]
    },
    {
        "title": "Package vs. exported symbol name",
        "belongs to": "Naming/Variable names/Repetition/Package vs. exported symbol name",
        "cases": [
            {
                "description": "When naming exported symbols, the name of the package is always visible outside\nyour package, so redundant information between the two should be reduced or\neliminated. If a package exports only one type and it is named after the package\nitself, the canonical name for the constructor is `New`if one is required.\nExamples: Repetitive Name -> Better Name \n\n\n`widget.NewWidget`-> `widget.New`\n\n\n`widget.NewWidgetWithName`-> `widget.NewWithName`\n\n\n`db.LoadFromDatabase`-> `db.Load`\n\n\n`goatteleportutil.CountGoatsTeleported`-> `gtutil.CountGoatsTeleported`or `goatteleport.Count`\n\n\n`myteampb.MyTeamMethodRequest`-> `mtpb.MyTeamMethodRequest`or `myteampb.MethodRequest`"
            }
        ]
    },
    {
        "title": "Variable name vs. type",
        "belongs to": "Naming/Variable names/Repetition/Variable name vs. type",
        "cases": [
            {
                "description": "The compiler always knows the type of a variable, and in most cases it is also\nclear to the reader what type a variable is by how it is used. It is only\nnecessary to clarify the type of a variable if its value appears twice in the\nsame scope.\nRepetitive Name \nBetter Name \n\n\n\n\n\n`varnumUsersint`\n\n\n`varusersint`\n\n\n\n\n`varnameStringstring`\n\n\n`varnamestring`\n\n\n\n\n`varprimaryProject*Project`\n\n\n`varprimary*Project`\nIf the value appears in multiple forms, this can be clarified either with an\nextra word like `raw`and `parsed`or with the underlying representation:",
                "example": "// Good:\nlimitStr := r.FormValue(\"limit\")\nlimit, err := strconv.Atoi(limitStr)\n\n// Good:\nlimitRaw := r.FormValue(\"limit\")\nlimit, err := strconv.Atoi(limitRaw)\n"
            }
        ]
    },
    {
        "title": "External context vs. local names",
        "belongs to": "Naming/Variable names/Repetition/External context vs. local names",
        "cases": [
            {
                "description": "Names that include information from their surrounding context often create extra\nnoise without benefit. The package name, method name, type name, function name,\nimport path, and even filename can all provide context that automatically\nqualifies all names within.",
                "example": "// Bad:\n// In package \"ads/targeting/revenue/reporting\"\ntype AdsTargetingRevenueReport struct{}\n\nfunc (p *Project) ProjectName() string\n\n// Good:\n// In package \"ads/targeting/revenue/reporting\"\ntype Report struct{}\n\nfunc (p *Project) Name() string\n\n// Bad:\n// In package \"sqldb\"\ntype DBConnection struct{}\n\n// Good:\n// In package \"sqldb\"\ntype Connection struct{}\n\n// Bad:\n// In package \"ads/targeting\"\nfunc Process(in *pb.FooProto) *Report {\n    adsTargetingID := in.GetAdsTargetingID()\n}\n\n// Good:\n// In package \"ads/targeting\"\nfunc Process(in *pb.FooProto) *Report {\n    id := in.GetAdsTargetingID()\n}\n"
            },
            {
                "description": "Repetition should generally be evaluated in the context of the user of the\nsymbol, rather than in isolation. For example, the following code has lots of\nnames that may be fine in some circumstances, but redundant in context:",
                "example": "// Bad:\nfunc (db *DB) UserCount() (userCount int, err error) {\n    var userCountInt64 int64\n    if dbLoadError := db.LoadFromDatabase(\"count(distinct users)\", &userCountInt64); dbLoadError != nil {\n        return 0, fmt.Errorf(\"failed to load user count: %s\", dbLoadError)\n    }\n    userCount = int(userCountInt64)\n    return userCount, nil\n}\n"
            },
            {
                "description": "Instead, information about names that are clear from context or usage can often\nbe omitted:",
                "example": "// Good:\nfunc (db *DB) UserCount() (int, error) {\n    var count int64\n    if err := db.Load(\"count(distinct users)\", &count); err != nil {\n        return 0, fmt.Errorf(\"failed to load user count: %s\", err)\n    }\n    return int(count), nil\n}\n"
            }
        ]
    },
    {
        "title": "Commentary",
        "belongs to": "Commentary",
        "cases": [
            {
                "description": "The conventions around commentary (which include what to comment, what style to\nuse, how to provide runnable examples, etc.) are intended to support the\nexperience of reading the documentation of a public API. See Effective Go for more\ninformation.\nThe best practices document’s section on documentation conventions discusses\nthis further.\nBest Practice: Use doc preview during development and code review to see\nwhether the documentation and runnable examples are useful and are presented the\nway you expect them to be.\nTip: Godoc uses very little special formatting; lists and code snippets\nshould usually be indented to avoid linewrapping. Apart from indentation,\ndecoration should generally be avoided."
            }
        ]
    },
    {
        "title": "Comment line length",
        "belongs to": "Commentary/Comment line length",
        "cases": [
            {
                "description": "Ensure that commentary is readable from source even on narrow screens.\nWhen a comment gets too long, it is recommended to wrap it into multiple\nsingle-line comments. When possible, aim for comments that will read well on an\n80-column wide terminal, however this is not a hard cut-off; there is no fixed\nline length limit for comments in Go. The standard library, for example, often\nchooses to break a comment based on punctuation, which sometimes leaves the\nindividual lines closer to the 60-70 character mark.\nThere is plenty of existing code in which comments exceed 80 characters in\nlength. This guidance should not be used as a justification to change such code\nas part of a readability review (see consistency ), though\nteams are encouraged to opportunistically update comments to follow this\nguideline as a part of other refactors. The primary goal of this guideline is to\nensure that all Go readability mentors make the same recommendation when and if\nrecommendations are made.\nSee this post from The Go Blog on documentation for more on commentary.",
                "example": "# Good:\n// This is a comment paragraph.\n// The length of individual lines doesn't matter in Godoc;\n// but the choice of wrapping makes it easy to read on narrow screens.\n//\n// Don't worry too much about the long URL:\n// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/\n//\n// Similarly, if you have other information that is made awkward\n// by too many line breaks, use your judgment and include a long line\n// if it helps rather than hinders.\n"
            },
            {
                "description": "Avoid comments that will wrap repeatedly on small screens, which is a poor\nreader experience.",
                "example": "# Bad:\n// This is a comment paragraph. The length of individual lines doesn't matter in\nGodoc;\n// but the choice of wrapping causes jagged lines on narrow screens or in code\nreview,\n// which can be annoying, especially when in a comment block that will wrap\nrepeatedly.\n//\n// Don't worry too much about the long URL:\n// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/\n"
            }
        ]
    },
    {
        "title": "Doc comments",
        "belongs to": "Commentary/Doc comments",
        "cases": [
            {
                "description": "All top-level exported names must have doc comments, as should unexported type\nor function declarations with unobvious behavior or meaning. These comments\nshould be full sentences that begin with the name of the object being\ndescribed. An article (“a”, “an”, “the”) can precede the name to make it read\nmore naturally.",
                "example": "// Good:\n// A Request represents a request to run a command.\ntype Request struct { ...\n\n// Encode writes the JSON encoding of req to w.\nfunc Encode(w io.Writer, req *Request) { ...\n"
            },
            {
                "description": "Doc comments appear in Godoc and are surfaced by IDEs,\nand therefore should be written for anyone using the package.\nA documentation comment applies to the following symbol, or the group of fields\nif it appears in a struct.",
                "example": "// Good:\n// Options configure the group management service.\ntype Options struct {\n    // General setup:\n    Name  string\n    Group *FooGroup\n\n    // Dependencies:\n    DB *sql.DB\n\n    // Customization:\n    LargeGroupThreshold int // optional; default: 10\n    MinimumMembers      int // optional; default: 2\n}\n"
            },
            {
                "description": "Best Practice: If you have doc comments for unexported code, follow the same\ncustom as if it were exported (namely, starting the comment with the unexported\nname). This makes it easy to export it later by simply replacing the unexported\nname with the newly-exported one across both comments and code."
            }
        ]
    },
    {
        "title": "Comment sentences",
        "belongs to": "Commentary/Comment sentences",
        "cases": [
            {
                "description": "Comments that are complete sentences should be capitalized and punctuated like\nstandard English sentences. (As an exception, it is okay to begin a sentence\nwith an uncapitalized identifier name if it is otherwise clear. Such cases are\nprobably best done only at the beginning of a paragraph.)\nComments that are sentence fragments have no such requirements for punctuation\nor capitalization.\nDocumentation comments should always be complete sentences, and as such should\nalways be capitalized and punctuated. Simple end-of-line comments (especially\nfor struct fields) can be simple phrases that assume the field name is the\nsubject.",
                "example": "// Good:\n// A Server handles serving quotes from the collected works of Shakespeare.\ntype Server struct {\n    // BaseDir points to the base directory under which Shakespeare's works are stored.\n    //\n    // The directory structure is expected to be the following:\n    //   {BaseDir}/manifest.json\n    //   {BaseDir}/{name}/{name}-part{number}.txt\n    BaseDir string\n\n    WelcomeMessage  string // displayed when user logs in\n    ProtocolVersion string // checked against incoming requests\n    PageLength      int    // lines per page when printing (optional; default: 20)\n}\n"
            }
        ]
    },
    {
        "title": "Examples",
        "belongs to": "Commentary/Examples",
        "cases": [
            {
                "description": "Packages should clearly document their intended usage. Try to provide a runnable example ; examples show up in Godoc. Runnable examples belong in the\ntest file, not the production source file. See this example ( Godoc , source ).\nIf it isn’t feasible to provide a runnable example, example code can be provided\nwithin code comments. As with other code and command-line snippets in comments,\nit should follow standard formatting conventions."
            }
        ]
    },
    {
        "title": "Named result parameters",
        "belongs to": "Commentary/Named result parameters",
        "cases": [
            {
                "description": "When naming parameters, consider how function signatures appear in Godoc. The\nname of the function itself and the type of the result parameters are often\nsufficiently clear.",
                "example": "// Good:\nfunc (n *Node) Parent1() *Node\nfunc (n *Node) Parent2() (*Node, error)\n"
            },
            {
                "description": "If a function returns two or more parameters of the same type, adding names can\nbe useful.",
                "example": "// Good:\nfunc (n *Node) Children() (left, right *Node, err error)\n"
            },
            {
                "description": "If the caller must take action on particular result parameters, naming them can\nhelp suggest what the action is:",
                "example": "// Good:\n// WithTimeout returns a context that will be canceled no later than d duration\n// from now.\n//\n// The caller must arrange for the returned cancel function to be called when\n// the context is no longer needed to prevent a resource leak.\nfunc WithTimeout(parent Context, d time.Duration) (ctx Context, cancel func())\n"
            },
            {
                "description": "In the code above, cancellation is a particular action a caller must take.\nHowever, were the result parameters written as `(Context,func())`alone, it\nwould be unclear what is meant by “cancel function”.\nDon’t use named result parameters when the names produce unnecessary repetition .",
                "example": "// Bad:\nfunc (n *Node) Parent1() (node *Node)\nfunc (n *Node) Parent2() (node *Node, err error)\n"
            },
            {
                "description": "Don’t name result parameters in order to avoid declaring a variable inside the\nfunction. This practice results in unnecessary API verbosity at the cost of\nminor implementation brevity.\nNaked returns are acceptable only in a small function. Once it’s a\nmedium-sized function, be explicit with your returned values. Similarly, do not\nname result parameters just because it enables you to use naked returns. Clarity is always more important than saving a few lines in\nyour function.\nIt is always acceptable to name a result parameter if its value must be changed\nin a deferred closure.\nTip: Types can often be clearer than names in function signatures. GoTip #38: Functions as Named Types demonstrates this. \nIn, \n`WithTimeout`\nabove, the real code uses a \n`CancelFunc`\ninstead of a\nraw `func()`in the result parameter list and requires little effort to\ndocument."
            }
        ]
    },
    {
        "title": "Package comments",
        "belongs to": "Commentary/Package comments",
        "cases": [
            {
                "description": "Package comments must appear immediately above the package clause with no blank\nline between the comment and the package name. Example:",
                "example": "// Good:\n// Package math provides basic constants and mathematical functions.\n//\n// This package does not guarantee bit-identical results across architectures.\npackage math\n"
            },
            {
                "description": "There must be a single package comment per package. If a package is composed of\nmultiple files, exactly one of the files should have a package comment.\nComments for `main`packages have a slightly different form, where the name of\nthe `go_binary`rule in the BUILD file takes the place of the package name.",
                "example": "// Good:\n// The seed_generator command is a utility that generates a Finch seed file\n// from a set of JSON study configs.\npackage main\n"
            },
            {
                "description": "Other styles of comment are fine as long as the name of the binary is exactly as\nwritten in the BUILD file. When the binary name is the first word, capitalizing\nit is required even though it does not strictly match the spelling of the\ncommand-line invocation.",
                "example": "// Good:\n// Binary seed_generator ...\n// Command seed_generator ...\n// Program seed_generator ...\n// The seed_generator command ...\n// The seed_generator program ...\n// Seed_generator ...\n"
            },
            {
                "description": "Tips:\nExample command-line invocations and API usage can be useful documentation.\nFor Godoc formatting, indent the comment lines containing code. \n\n\nIf there is no obvious primary file or if the package comment is\nextraordinarily long, it is acceptable to put the doc comment in a file\nnamed `doc.go`with only the comment and the package clause. \n\n\nMultiline comments can be used instead of multiple single-line comments.\nThis is primarily useful if the documentation contains sections which may be\nuseful to copy and paste from the source file, as with sample command-lines\n(for binaries) and template examples.",
                "example": "// Good:\n/*\nThe seed_generator command is a utility that generates a Finch seed file\nfrom a set of JSON study configs.\n\n    seed_generator *.json | base64 > finch-seed.base64\n*/\npackage template\n",
                "appendix": "Comments intended for maintainers and that apply to the whole file are\ntypically placed after import declarations. These are not surfaced in Godoc\nand are not subject to the rules above on package comments."
            }
        ]
    },
    {
        "title": "Imports",
        "belongs to": "Imports",
        "cases": []
    },
    {
        "title": "Import renaming",
        "belongs to": "Imports/Import renaming",
        "cases": [
            {
                "description": "Imports should only be renamed to avoid a name collision with other imports. (A\ncorollary of this is that good package names should not\nrequire renaming.) In the event of a name collision, prefer to rename the most\nlocal or project-specific import. Local names (aliases) for packages must follow the guidance around package naming , including the prohibition\non the use of underscores and capital letters.\nGenerated protocol buffer packages must be renamed to remove underscores from\ntheir names, and their aliases must have a `pb`suffix. See proto and stub best practices for more information.",
                "example": "// Good:\nimport (\n    fspb \"path/to/package/foo_service_go_proto\"\n)\n"
            },
            {
                "description": "Imports that have package names with no useful identifying information (e.g. `packagev1`) should be renamed to include the previous path component. The\nrename must be consistent with other local files importing the same package and\nmay include the version number.\nNote: It is preferred to rename the package to conform with good package names , but that is often not feasible for\npackages in vendored directories.",
                "example": "// Good:\nimport (\n    core \"github.com/kubernetes/api/core/v1\"\n    meta \"github.com/kubernetes/apimachinery/pkg/apis/meta/v1beta1\"\n)\n"
            },
            {
                "description": "If you need to import a package whose name collides with a common local variable\nname that you want to use (e.g. `url`, `ssh`) and you wish to rename the\npackage, the preferred way to do so is with the `pkg`suffix (e.g. `urlpkg`).\nNote that it is possible to shadow a package with a local variable; this rename\nis only necessary if the package still needs to be used when such a variable is\nin scope."
            }
        ]
    },
    {
        "title": "Import grouping",
        "belongs to": "Imports/Import grouping",
        "cases": [
            {
                "description": "Imports should be organized in two groups:\nStandard library packages \n\n\nOther (project and vendored) packages",
                "example": "// Good:\npackage main\n\nimport (\n    \"fmt\"\n    \"hash/adler32\"\n    \"os\"\n\n    \"github.com/dsnet/compress/flate\"\n    \"golang.org/x/text/encoding\"\n    \"google.golang.org/protobuf/proto\"\n    foopb \"myproj/foo/proto/proto\"\n    _ \"myproj/rpc/protocols/dial\"\n    _ \"myproj/security/auth/authhooks\"\n)\n"
            },
            {
                "description": "It is acceptable to split the project packages into multiple groups if you want\na separate group, as long as the groups have some meaning. Common reasons to do\nthis:\nrenamed imports \npackages imported for their side-effects\nExample:",
                "example": "// Good:\npackage main\n\nimport (\n    \"fmt\"\n    \"hash/adler32\"\n    \"os\"\n\n\n    \"github.com/dsnet/compress/flate\"\n    \"golang.org/x/text/encoding\"\n    \"google.golang.org/protobuf/proto\"\n\n    foopb \"myproj/foo/proto/proto\"\n\n    _ \"myproj/rpc/protocols/dial\"\n    _ \"myproj/security/auth/authhooks\"\n)\n"
            },
            {
                "description": "Note: Maintaining optional groups - splitting beyond what is necessary for\nthe mandatory separation between standard library and Google imports - is not\nsupported by the goimports tool. Additional import subgroups require attention\non the part of both authors and reviewers to maintain in a conforming state.\nGoogle programs that are also AppEngine apps should have a separate group for\nAppEngine imports.\nGofmt takes care of sorting each group by import path. However, it does not\nautomatically separate imports into groups. The popular goimports tool\ncombines Gofmt and import management, separating imports into groups based on\nthe decision above. It is permissible to let goimports manage import\narrangement entirely, but as a file is revised its import list must remain\ninternally consistent."
            }
        ]
    },
    {
        "title": "Import “blank” (\n    \n     import _\n    \n    )",
        "belongs to": "Imports/Import “blank” (\n    \n     import _\n    \n    )",
        "cases": [
            {
                "description": "Packages that are imported only for their side effects (using the syntax `import_\"package\"`) may only be imported in a main package, or in tests that require\nthem.\nSome examples of such packages include:\ntime/tzdata \n\n\n\n\nimage/jpeg in image processing code\nAvoid blank imports in library packages, even if the library indirectly depends\non them. Constraining side-effect imports to the main package helps control\ndependencies, and makes it possible to write tests that rely on a different\nimport without conflict or wasted build costs.\nThe following are the only exceptions to this rule:\nYou may use a blank import to bypass the check for disallowed imports in the nogo static checker . \n\n\nYou may use a blank import of the embed package\nin a source file which uses the `//go:embed`compiler directive.\nTip: If you create a library package that indirectly depends on a\nside-effect import in production, document the intended usage."
            }
        ]
    },
    {
        "title": "Import “dot” (\n    \n     import .\n    \n    )",
        "belongs to": "Imports/Import “dot” (\n    \n     import .\n    \n    )",
        "cases": [
            {
                "description": "The `import.`form is a language feature that allows bringing identifiers\nexported from another package to the current package without qualification. See\nthe language spec for more.\nDo not use this feature in the Google codebase; it makes it harder to tell\nwhere the functionality is coming from.",
                "example": "// Bad:\npackage foo_test\n\nimport (\n    \"bar/testutil\" // also imports \"foo\"\n    . \"foo\"\n)\n\nvar myThing = Bar() // Bar defined in package foo; no qualification needed.\n\n// Good:\npackage foo_test\n\nimport (\n    \"bar/testutil\" // also imports \"foo\"\n    \"foo\"\n)\n\nvar myThing = foo.Bar()\n"
            }
        ]
    },
    {
        "title": "Errors",
        "belongs to": "Errors",
        "cases": []
    },
    {
        "title": "Returning errors",
        "belongs to": "Errors/Returning errors",
        "cases": [
            {
                "description": "Use `error`to signal that a function can fail. By convention, `error`is the\nlast result parameter.",
                "example": "// Good:\nfunc Good() error { /* ... */ }\n"
            },
            {
                "description": "Returning a `nil`error is the idiomatic way to signal a successful operation\nthat could otherwise fail. If a function returns an error, callers must treat\nall non-error return values as unspecified unless explicitly documented\notherwise. Commonly, the non-error return values are their zero values, but this\ncannot be assumed.",
                "example": "// Good:\nfunc GoodLookup() (*Result, error) {\n    // ...\n    if err != nil {\n        return nil, err\n    }\n    return res, nil\n}\n"
            },
            {
                "description": "Exported functions that return errors should return them using the `error`type.\nConcrete error types are susceptible to subtle bugs: a concrete `nil`pointer\ncan get wrapped into an interface and thus become a non-nil value (see the Go FAQ entry on the topic ).",
                "example": "// Bad:\nfunc Bad() *os.PathError { /*...*/ }\n"
            },
            {
                "description": "Tip : A function that takes a `context.Context`argument should usually\nreturn an `error`so that the caller can determine if the context was cancelled\nwhile the function was running."
            }
        ]
    },
    {
        "title": "Error strings",
        "belongs to": "Errors/Error strings",
        "cases": [
            {
                "description": "Error strings should not be capitalized (unless beginning with an exported name,\na proper noun or an acronym) and should not end with punctuation. This is\nbecause error strings usually appear within other context before being printed\nto the user.",
                "example": "// Bad:\nerr := fmt.Errorf(\"Something bad happened.\")\n\n// Good:\nerr := fmt.Errorf(\"something bad happened\")\n"
            },
            {
                "description": "On the other hand, the style for the full displayed message (logging, test\nfailure, API response, or other UI) depends, but should typically be\ncapitalized.",
                "example": "// Good:\nlog.Infof(\"Operation aborted: %v\", err)\nlog.Errorf(\"Operation aborted: %v\", err)\nt.Errorf(\"Op(%q) failed unexpectedly; err=%v\", args, err)\n"
            }
        ]
    },
    {
        "title": "Handle errors",
        "belongs to": "Errors/Handle errors",
        "cases": [
            {
                "description": "Code that encounters an error should make a deliberate choice about how to\nhandle it. It is not usually appropriate to discard errors using `_`variables.\nIf a function returns an error, do one of the following:\nHandle and address the error immediately. \nReturn the error to the caller. \nIn exceptional situations, call \n`log.Fatal`\nor (if absolutely necessary) `panic`.\nNote: \n`log.Fatalf`is not the standard library log. See [#logging].\nIn the rare circumstance where it is appropriate to ignore or discard an error\n(for example a call to \n`(*bytes.Buffer).Write`\nthat is documented to never\nfail), an accompanying comment should explain why this is safe.",
                "example": "// Good:\nvar b *bytes.Buffer\n\nn, _ := b.Write(p) // never returns a non-nil error\n"
            },
            {
                "description": "For more discussion and examples of error handling, see Effective Go and best practices ."
            }
        ]
    },
    {
        "title": "In-band errors",
        "belongs to": "Errors/In-band errors",
        "cases": [
            {
                "description": "In C and similar languages, it is common for functions to return values like -1,\nnull, or the empty string to signal errors or missing results. This is known as\nin-band error handling.",
                "example": "// Bad:\n// Lookup returns the value for key or -1 if there is no mapping for key.\nfunc Lookup(key string) int\n"
            },
            {
                "description": "Failing to check for an in-band error value can lead to bugs and can attribute\nerrors to the wrong function.",
                "example": "// Bad:\n// The following line returns an error that Parse failed for the input value,\n// whereas the failure was that there is no mapping for missingKey.\nreturn Parse(Lookup(missingKey))\n"
            },
            {
                "description": "Go’s support for multiple return values provides a better solution (see the Effective Go section on multiple returns ). Instead of requiring clients to\ncheck for an in-band error value, a function should return an additional value\nto indicate whether its other return values are valid. This return value may be\nan error or a boolean when no explanation is needed, and should be the final\nreturn value.",
                "example": "// Good:\n// Lookup returns the value for key or ok=false if there is no mapping for key.\nfunc Lookup(key string) (value string, ok bool)\n"
            },
            {
                "description": "This API prevents the caller from incorrectly writing `Parse(Lookup(key))`which\ncauses a compile-time error, since `Lookup(key)`has 2 outputs.\nReturning errors in this way encourages more robust and explicit error handling:",
                "example": "// Good:\nvalue, ok := Lookup(key)\nif !ok {\n    return fmt.Errorf(\"no value for %q\", key)\n}\nreturn Parse(value)\n"
            },
            {
                "description": "Some standard library functions, like those in package `strings`, return in-band\nerror values. This greatly simplifies string-manipulation code at the cost of\nrequiring more diligence from the programmer. In general, Go code in the Google\ncodebase should return additional values for errors."
            }
        ]
    },
    {
        "title": "Indent error flow",
        "belongs to": "Errors/Indent error flow",
        "cases": [
            {
                "description": "Handle errors before proceeding with the rest of your code. This improves the\nreadability of the code by enabling the reader to find the normal path quickly.\nThis same logic applies to any block which tests a condition then ends in a\nterminal condition (e.g., `return`, `panic`, `log.Fatal`).\nCode that runs if the terminal condition is not met should appear after the `if`block, and should not be indented in an `else`clause.",
                "example": "// Good:\nif err != nil {\n    // error handling\n    return // or continue, etc.\n}\n// normal code\n\n// Bad:\nif err != nil {\n    // error handling\n} else {\n    // normal code that looks abnormal due to indentation\n}\n"
            },
            {
                "description": "Tip: If you are using a variable for more than a few lines of code, it is\ngenerally not worth using the `if`-with-initializer style. In these cases, it\nis usually better to move the declaration out and use a standard `if`statement:",
                "example": "// Good:\nx, err := f()\nif err != nil {\n  // error handling\n  return\n}\n// lots of code that uses x\n// across multiple lines\n\n// Bad:\nif x, err := f(); err != nil {\n  // error handling\n  return\n} else {\n  // lots of code that uses x\n  // across multiple lines\n}\n"
            },
            {
                "description": "See Go Tip #1: Line of Sight and TotT: Reduce Code Complexity by Reducing Nesting for more details."
            }
        ]
    },
    {
        "title": "Language",
        "belongs to": "Language",
        "cases": []
    },
    {
        "title": "Literal formatting",
        "belongs to": "Language/Literal formatting",
        "cases": [
            {
                "description": "Go has an exceptionally powerful composite literal syntax , with which it is\npossible to express deeply-nested, complicated values in a single expression.\nWhere possible, this literal syntax should be used instead of building values\nfield-by-field. The `gofmt`formatting for literals is generally quite good, but\nthere are some additional rules for keeping these literals readable and\nmaintainable."
            }
        ]
    },
    {
        "title": "Field names",
        "belongs to": "Language/Literal formatting/Field names",
        "cases": [
            {
                "description": "Struct literals must specify field names for types defined outside the\ncurrent package.\nInclude field names for types from other packages.",
                "example": "// Good:\n// https://pkg.go.dev/encoding/csv#Reader\nr := csv.Reader{\n  Comma: ',',\n  Comment: '#',\n  FieldsPerRecord: 4,\n}\n"
            },
            {
                "description": "The position of fields in a struct and the full set of fields (both of which\nare necessary to get right when field names are omitted) are not usually\nconsidered to be part of a struct’s public API; specifying the field name is\nneeded to avoid unnecessary coupling.",
                "example": "// Bad:\nr := csv.Reader{',', '#', 4, false, false, false, false}\n"
            },
            {
                "description": "For package-local types, field names are optional.",
                "example": "// Good:\nokay := Type{42}\nalso := internalType{4, 2}\n"
            },
            {
                "description": "Field names should still be used if it makes the code clearer, and it is\nvery common to do so. For example, a struct with a large number of fields\nshould almost always be initialized with field names. \nTODO: Maybe a better example here that doesn't have many fields.",
                "example": "// Good:\nokay := StructWithLotsOfFields{\n  field1: 1,\n  field2: \"two\",\n  field3: 3.14,\n  field4: true,\n}\n"
            }
        ]
    },
    {
        "title": "Matching braces",
        "belongs to": "Language/Literal formatting/Matching braces",
        "cases": [
            {
                "description": "The closing half of a brace pair should always appear on a line with the same\namount of indentation as the opening brace. One-line literals necessarily have\nthis property. When the literal spans multiple lines, maintaining this property\nkeeps the brace matching for literals the same as brace matching for common Go\nsyntactic constructs like functions and `if`statements.\nThe most common mistake in this area is putting the closing brace on the same\nline as a value in a multi-line struct literal. In these cases, the line should\nend with a comma and the closing brace should appear on the next line.",
                "example": "// Good:\ngood := []*Type{{Key: \"value\"}}\n\n// Good:\ngood := []*Type{\n    {Key: \"multi\"},\n    {Key: \"line\"},\n}\n\n// Bad:\nbad := []*Type{\n    {Key: \"multi\"},\n    {Key: \"line\"}}\n\n// Bad:\nbad := []*Type{\n    {\n        Key: \"value\"},\n}\n"
            }
        ]
    },
    {
        "title": "Cuddled braces",
        "belongs to": "Language/Literal formatting/Cuddled braces",
        "cases": [
            {
                "description": "Dropping whitespace between braces (aka “cuddling” them) for slice and array\nliterals is only permitted when both of the following are true.\nThe indentation matches \n\nThe inner values are also literals or proto builders (i.e. not a variable or\nother expression)",
                "example": "// Good:\ngood := []*Type{\n    { // Not cuddled\n        Field: \"value\",\n    },\n    {\n        Field: \"value\",\n    },\n}\n\n// Good:\ngood := []*Type{{ // Cuddled correctly\n    Field: \"value\",\n}, {\n    Field: \"value\",\n}}\n\n// Good:\ngood := []*Type{\n    first, // Can't be cuddled\n    {Field: \"second\"},\n}\n\n// Good:\nokay := []*pb.Type{pb.Type_builder{\n    Field: \"first\", // Proto Builders may be cuddled to save vertical space\n}.Build(), pb.Type_builder{\n    Field: \"second\",\n}.Build()}\n\n// Bad:\nbad := []*Type{\n    first,\n    {\n        Field: \"second\",\n    }}\n"
            }
        ]
    },
    {
        "title": "Repeated type names",
        "belongs to": "Language/Literal formatting/Repeated type names",
        "cases": [
            {
                "description": "Repeated type names may be omitted from slice and map literals. This can be\nhelpful in reducing clutter. A reasonable occasion for repeating the type names\nexplicitly is when dealing with a complex type that is not common in your\nproject, when the repetitive type names are on lines that are far apart and can\nremind the reader of the context.",
                "example": "// Good:\ngood := []*Type{\n    {A: 42},\n    {A: 43},\n}\n\n// Bad:\nrepetitive := []*Type{\n    &Type{A: 42},\n    &Type{A: 43},\n}\n\n// Good:\ngood := map[Type1]*Type2{\n    {A: 1}: {B: 2},\n    {A: 3}: {B: 4},\n}\n\n// Bad:\nrepetitive := map[Type1]*Type2{\n    Type1{A: 1}: &Type2{B: 2},\n    Type1{A: 3}: &Type2{B: 4},\n}\n"
            },
            {
                "description": "Tip: If you want to remove repetitive type names in struct literals, you can\nrun `gofmt-s`."
            }
        ]
    },
    {
        "title": "Zero-value fields",
        "belongs to": "Language/Literal formatting/Zero-value fields",
        "cases": [
            {
                "description": "Zero-value fields may be omitted from struct literals when clarity is not lost\nas a result.\nWell-designed APIs often employ zero-value construction for enhanced\nreadability. For example, omitting the three zero-value fields from the\nfollowing struct draws attention to the only option that is being specified.",
                "example": "// Bad:\nimport (\n  \"github.com/golang/leveldb\"\n  \"github.com/golang/leveldb/db\"\n)\n\nldb := leveldb.Open(\"/my/table\", &db.Options{\n    BlockSize: 1<<16,\n    ErrorIfDBExists: true,\n\n    // These fields all have their zero values.\n    BlockRestartInterval: 0,\n    Comparer: nil,\n    Compression: nil,\n    FileSystem: nil,\n    FilterPolicy: nil,\n    MaxOpenFiles: 0,\n    WriteBufferSize: 0,\n    VerifyChecksums: false,\n})\n\n// Good:\nimport (\n  \"github.com/golang/leveldb\"\n  \"github.com/golang/leveldb/db\"\n)\n\nldb := leveldb.Open(\"/my/table\", &db.Options{\n    BlockSize: 1<<16,\n    ErrorIfDBExists: true,\n})\n"
            },
            {
                "description": "Structs within table-driven tests often benefit from explicit field names ,\nespecially when the test struct is not trivial. This allows the author to omit\nthe zero-valued fields entirely when the fields in question are not related to\nthe test case. For example, successful test cases should omit any error-related\nor failure-related fields. In cases where the zero value is necessary to\nunderstand the test case, such as testing for zero or `nil`inputs, the field\nnames should be specified.\nConcise",
                "example": "tests := []struct {\n    input      string\n    wantPieces []string\n    wantErr    error\n}{\n    {\n        input:      \"1.2.3.4\",\n        wantPieces: []string{\"1\", \"2\", \"3\", \"4\"},\n    },\n    {\n        input:   \"hostname\",\n        wantErr: ErrBadHostname,\n    },\n}\n"
            },
            {
                "description": "Explicit",
                "example": "tests := []struct {\n    input    string\n    wantIPv4 bool\n    wantIPv6 bool\n    wantErr  bool\n}{\n    {\n        input:    \"1.2.3.4\",\n        wantIPv4: true,\n        wantIPv6: false,\n    },\n    {\n        input:    \"1:2::3:4\",\n        wantIPv4: false,\n        wantIPv6: true,\n    },\n    {\n        input:    \"hostname\",\n        wantIPv4: false,\n        wantIPv6: false,\n        wantErr:  true,\n    },\n}\n"
            }
        ]
    },
    {
        "title": "Nil slices",
        "belongs to": "Language/Literal formatting/Nil slices",
        "cases": [
            {
                "description": "For most purposes, there is no functional difference between `nil`and the empty\nslice. Built-in functions like `len`and `cap`behave as expected on `nil`slices.",
                "example": "// Good:\nimport \"fmt\"\n\nvar s []int         // nil\n\nfmt.Println(s)      // []\nfmt.Println(len(s)) // 0\nfmt.Println(cap(s)) // 0\nfor range s {...}   // no-op\n\ns = append(s, 42)\nfmt.Println(s)      // [42]\n"
            },
            {
                "description": "If you declare an empty slice as a local variable (especially if it can be the\nsource of a return value), prefer the nil initialization to reduce the risk of\nbugs by callers.",
                "example": "// Good:\nvar t []string\n\n// Bad:\nt := []string{}\n"
            },
            {
                "description": "Do not create APIs that force their clients to make distinctions between nil and\nthe empty slice.",
                "example": "// Good:\n// Ping pings its targets.\n// Returns hosts that successfully responded.\nfunc Ping(hosts []string) ([]string, error) { ... }\n\n// Bad:\n// Ping pings its targets and returns a list of hosts\n// that successfully responded. Can be empty if the input was empty.\n// nil signifies that a system error occurred.\nfunc Ping(hosts []string) []string { ... }\n"
            },
            {
                "description": "When designing interfaces, avoid making a distinction between a `nil`slice and\na non- `nil`, zero-length slice, as this can lead to subtle programming errors.\nThis is typically accomplished by using `len`to check for emptiness, rather\nthan `==nil`.\nThis implementation accepts both `nil`and zero-length slices as “empty”:",
                "example": "// Good:\n// describeInts describes s with the given prefix, unless s is empty.\nfunc describeInts(prefix string, s []int) {\n    if len(s) == 0 {\n        return\n    }\n    fmt.Println(prefix, s)\n}\n"
            },
            {
                "description": "Instead of relying on the distinction as a part of the API:",
                "example": "// Bad:\nfunc maybeInts() []int { /* ... */ }\n\n// describeInts describes s with the given prefix; pass nil to skip completely.\nfunc describeInts(prefix string, s []int) {\n  // The behavior of this function unintentionally changes depending on what\n  // maybeInts() returns in 'empty' cases (nil or []int{}).\n  if s == nil {\n    return\n  }\n  fmt.Println(prefix, s)\n}\n\ndescribeInts(\"Here are some ints:\", maybeInts())\n"
            },
            {
                "description": "See in-band errors for further discussion."
            }
        ]
    },
    {
        "title": "Indentation confusion",
        "belongs to": "Language/Literal formatting/Indentation confusion",
        "cases": [
            {
                "description": "Avoid introducing a line break if it would align the rest of the line with an\nindented code block. If this is unavoidable, leave a space to separate the code\nin the block from the wrapped line.",
                "example": "// Bad:\nif longCondition1 && longCondition2 &&\n    // Conditions 3 and 4 have the same indentation as the code within the if.\n    longCondition3 && longCondition4 {\n    log.Info(\"all conditions met\")\n}\n"
            },
            {
                "description": "See the following sections for specific guidelines and examples:\nFunction formatting \n\n\nConditionals and loops \n\n\nLiteral formatting"
            }
        ]
    },
    {
        "title": "Function formatting",
        "belongs to": "Language/Literal formatting/Function formatting",
        "cases": [
            {
                "description": "The signature of a function or method declaration should remain on a single line\nto avoid indentation confusion .\nFunction argument lists can make some of the longest lines in a Go source file.\nHowever, they precede a change in indentation, and therefore it is difficult to\nbreak the line in a way that does not make subsequent lines look like part of\nthe function body in a confusing way:",
                "example": "// Bad:\nfunc (r *SomeType) SomeLongFunctionName(foo1, foo2, foo3 string,\n    foo4, foo5, foo6 int) {\n    foo7 := bar(foo1)\n    // ...\n}\n"
            },
            {
                "description": "See best practices for a few options for shortening\nthe call sites of functions that would otherwise have many arguments.\nLines can often be shortened by factoring out local variables.",
                "example": "// Good:\nlocal := helper(some, parameters, here)\ngood := foo.Call(list, of, parameters, local)\n"
            },
            {
                "description": "Similarly, function and method calls should not be separated based solely on\nline length.",
                "example": "// Good:\ngood := foo.Call(long, list, of, parameters, all, on, one, line)\n\n// Bad:\nbad := foo.Call(long, list, of, parameters,\n    with, arbitrary, line, breaks)\n"
            },
            {
                "description": "Avoid adding inline comments to specific function arguments where possible.\nInstead, use an option struct or add more\ndetail to the function documentation.",
                "example": "// Good:\ngood := server.New(ctx, server.Options{Port: 42})\n\n// Bad:\nbad := server.New(\n    ctx,\n    42, // Port\n)\n"
            },
            {
                "description": "If the API cannot be changed or if the local call is unusual (whether or not the\ncall is too long), it is always permissible to add line breaks if it aids in\nunderstanding the call.",
                "example": "// Good:\ncanvas.RenderCube(cube,\n    x0, y0, z0,\n    x0, y0, z1,\n    x0, y1, z0,\n    x0, y1, z1,\n    x1, y0, z0,\n    x1, y0, z1,\n    x1, y1, z0,\n    x1, y1, z1,\n)\n"
            },
            {
                "description": "Note that the lines in the above example are not wrapped at a specific column\nboundary but are grouped based on co-ordinate triples.\nLong string literals within functions should not be broken for the sake of line\nlength. For functions that include such strings, a line break can be added after\nthe string format, and the arguments can be provided on the next or subsequent\nlines. The decision about where the line breaks should go is best made based on\nsemantic groupings of inputs, rather than based purely on line length.",
                "example": "// Good:\nlog.Warningf(\"Database key (%q, %d, %q) incompatible in transaction started by (%q, %d, %q)\",\n    currentCustomer, currentOffset, currentKey,\n    txCustomer, txOffset, txKey)\n\n// Bad:\nlog.Warningf(\"Database key (%q, %d, %q) incompatible in\"+\n    \" transaction started by (%q, %d, %q)\",\n    currentCustomer, currentOffset, currentKey, txCustomer,\n    txOffset, txKey)\n"
            }
        ]
    },
    {
        "title": "Conditionals and loops",
        "belongs to": "Language/Literal formatting/Conditionals and loops",
        "cases": [
            {
                "description": "An `if`statement should not be line broken; multi-line `if`clauses can lead to indentation confusion .",
                "example": "// Bad:\n// The second if statement is aligned with the code within the if block, causing\n// indentation confusion.\nif db.CurrentStatusIs(db.InTransaction) &&\n    db.ValuesEqual(db.TransactionKey(), row.Key()) {\n    return db.Errorf(db.TransactionError, \"query failed: row (%v): key does not match transaction key\", row)\n}\n"
            },
            {
                "description": "If the short-circuit behavior is not required, the boolean operands can be\nextracted directly:",
                "example": "// Good:\ninTransaction := db.CurrentStatusIs(db.InTransaction)\nkeysMatch := db.ValuesEqual(db.TransactionKey(), row.Key())\nif inTransaction && keysMatch {\n    return db.Error(db.TransactionError, \"query failed: row (%v): key does not match transaction key\", row)\n}\n"
            },
            {
                "description": "There may also be other locals that can be extracted, especially if the\nconditional is already repetitive:",
                "example": "// Good:\nuid := user.GetUniqueUserID()\nif db.UserIsAdmin(uid) || db.UserHasPermission(uid, perms.ViewServerConfig) || db.UserHasPermission(uid, perms.CreateGroup) {\n    // ...\n}\n\n// Bad:\nif db.UserIsAdmin(user.GetUniqueUserID()) || db.UserHasPermission(user.GetUniqueUserID(), perms.ViewServerConfig) || db.UserHasPermission(user.GetUniqueUserID(), perms.CreateGroup) {\n    // ...\n}\n"
            },
            {
                "description": "`if`statements that contain closures or multi-line struct literals should\nensure that the braces match to avoid indentation confusion .",
                "example": "// Good:\nif err := db.RunInTransaction(func(tx *db.TX) error {\n    return tx.Execute(userUpdate, x, y, z)\n}); err != nil {\n    return fmt.Errorf(\"user update failed: %s\", err)\n}\n\n// Good:\nif _, err := client.Update(ctx, &upb.UserUpdateRequest{\n    ID:   userID,\n    User: user,\n}); err != nil {\n    return fmt.Errorf(\"user update failed: %s\", err)\n}\n"
            },
            {
                "description": "Similarly, don’t try inserting artificial linebreaks into `for`statements. You\ncan always let the line simply be long if there is no elegant way to refactor\nit:",
                "example": "// Good:\nfor i, max := 0, collection.Size(); i < max && !collection.HasPendingWriters(); i++ {\n    // ...\n}\n"
            },
            {
                "description": "Often, though, there is:",
                "example": "// Good:\nfor i, max := 0, collection.Size(); i < max; i++ {\n    if collection.HasPendingWriters() {\n        break\n    }\n    // ...\n}\n"
            },
            {
                "description": "`switch`and `case`statements should also remain on a single line.",
                "example": "// Good:\nswitch good := db.TransactionStatus(); good {\ncase db.TransactionStarting, db.TransactionActive, db.TransactionWaiting:\n    // ...\ncase db.TransactionCommitted, db.NoTransaction:\n    // ...\ndefault:\n    // ...\n}\n\n// Bad:\nswitch bad := db.TransactionStatus(); bad {\ncase db.TransactionStarting,\n    db.TransactionActive,\n    db.TransactionWaiting:\n    // ...\ncase db.TransactionCommitted,\n    db.NoTransaction:\n    // ...\ndefault:\n    // ...\n}\n"
            },
            {
                "description": "If the line is excessively long, indent all cases and separate them with a blank\nline to avoid indentation confusion :",
                "example": "// Good:\nswitch db.TransactionStatus() {\ncase\n    db.TransactionStarting,\n    db.TransactionActive,\n    db.TransactionWaiting,\n    db.TransactionCommitted:\n\n    // ...\ncase db.NoTransaction:\n    // ...\ndefault:\n    // ...\n}\n"
            },
            {
                "description": "In conditionals comparing a variable to a constant, place the variable value on\nthe left hand side of the equality operator:",
                "example": "// Good:\nif result == \"foo\" {\n  // ...\n}\n"
            },
            {
                "description": "Instead of the less clear phrasing where the constant comes first\n( “Yoda style conditionals” ):",
                "example": "// Bad:\nif \"foo\" == result {\n  // ...\n}\n"
            }
        ]
    },
    {
        "title": "Copying",
        "belongs to": "Language/Literal formatting/Copying",
        "cases": [
            {
                "description": "To avoid unexpected aliasing and similar bugs, be careful when copying a struct\nfrom another package. For example, synchronization objects such as `sync.Mutex`must not be copied.\nThe `bytes.Buffer`type contains a `[]byte`slice and, as an optimization for\nsmall strings, a small byte array to which the slice may refer. If you copy a `Buffer`, the slice in the copy may alias the array in the original, causing\nsubsequent method calls to have surprising effects.\nIn general, do not copy a value of type `T`if its methods are associated with\nthe pointer type, `*T`.",
                "example": "// Bad:\nb1 := bytes.Buffer{}\nb2 := b1\n"
            },
            {
                "description": "Invoking a method that takes a value receiver can hide the copy. When you author\nan API, you should generally take and return pointer types if your structs\ncontain fields that should not be copied.\nThese are acceptable:",
                "example": "// Good:\ntype Record struct {\n  buf bytes.Buffer\n  // other fields omitted\n}\n\nfunc New() *Record {...}\n\nfunc (r *Record) Process(...) {...}\n\nfunc Consumer(r *Record) {...}\n"
            },
            {
                "description": "But these are usually wrong:",
                "example": "// Bad:\ntype Record struct {\n  buf bytes.Buffer\n  // other fields omitted\n}\n\n\nfunc (r Record) Process(...) {...} // Makes a copy of r.buf\n\nfunc Consumer(r Record) {...} // Makes a copy of r.buf\n"
            },
            {
                "description": "This guidance also applies to copying `sync.Mutex`."
            }
        ]
    },
    {
        "title": "Don’t panic",
        "belongs to": "Language/Literal formatting/Don’t panic",
        "cases": [
            {
                "description": "Do not use `panic`for normal error handling. Instead, use `error`and multiple\nreturn values. See the Effective Go section on errors .\nWithin `packagemain`and initialization code, consider \n`log.Exit`\nfor errors\nthat should terminate the program (e.g., invalid configuration), as in many of\nthese cases a stack trace will not help the reader. Please note that \n`log.Exit`\ncalls \n`os.Exit`\nand any deferred functions will not be run.\nFor errors that indicate “impossible” conditions, namely bugs that should always\nbe caught during code review and/or testing, a function may reasonably return an\nerror or call \n`log.Fatal`\n.\nNote: \n`log.Fatalf`is not the standard library log. See [#logging]."
            }
        ]
    },
    {
        "title": "Must functions",
        "belongs to": "Language/Literal formatting/Must functions",
        "cases": [
            {
                "description": "Setup helper functions that stop the program on failure follow the naming\nconvention `MustXYZ`(or `mustXYZ`). In general, they should only be called\nearly on program startup, not on things like user input where normal Go error\nhandling is preferred.\nThis often comes up for functions called to initialize package-level variables\nexclusively at package initialization time (e.g. template.Must and regexp.MustCompile ).",
                "example": "// Good:\nfunc MustParse(version string) *Version {\n    v, err := Parse(version)\n    if err != nil {\n        panic(fmt.Sprintf(\"MustParse(%q) = _, %v\", version, err))\n    }\n    return v\n}\n\n// Package level \"constant\". If we wanted to use `Parse`, we would have had to\n// set the value in `init`.\nvar DefaultVersion = MustParse(\"1.2.3\")\n"
            },
            {
                "description": "The same convention may be used in test helpers that only stop the current test\n(using `t.Fatal`). Such helpers are often convenient in creating test values,\nfor example in struct fields of table driven tests , as\nfunctions that return errors cannot be directly assigned to a struct field.",
                "example": "// Good:\nfunc mustMarshalAny(t *testing.T, m proto.Message) *anypb.Any {\n  t.Helper()\n  any, err := anypb.New(m)\n  if err != nil {\n    t.Fatalf(\"mustMarshalAny(t, m) = %v; want %v\", err, nil)\n  }\n  return any\n}\n\nfunc TestCreateObject(t *testing.T) {\n  tests := []struct{\n    desc string\n    data *anypb.Any\n  }{\n    {\n      desc: \"my test case\",\n      // Creating values directly within table driven test cases.\n      data: mustMarshalAny(t, mypb.Object{}),\n    },\n    // ...\n  }\n  // ...\n}\n"
            },
            {
                "description": "In both of these cases, the value of this pattern is that the helpers can be\ncalled in a “value” context. These helpers should not be called in places where\nit’s difficult to ensure an error would be caught or in a context where an error\nshould be checked (e.g., in many request handlers). For\nconstant inputs, this allows tests to easily ensure that the `Must`arguments\nare well-formed, and for non-constant inputs it permits tests to validate that\nerrors are properly handled or propagated .\nWhere `Must`functions are used in a test, they should generally be marked as a test helper and call `t.Fatal`on error (see error handling in test helpers for\nmore considerations of using that).\nThey should not be used when ordinary error handling is possible (including\nwith some refactoring):",
                "example": "// Bad:\nfunc Version(o *servicepb.Object) (*version.Version, error) {\n    // Return error instead of using Must functions.\n    v := version.MustParse(o.GetVersionString())\n    return dealiasVersion(v)\n}\n"
            }
        ]
    },
    {
        "title": "Goroutine lifetimes",
        "belongs to": "Language/Literal formatting/Goroutine lifetimes",
        "cases": [
            {
                "description": "When you spawn goroutines, make it clear when or whether they exit.\nGoroutines can leak by blocking on channel sends or receives. The garbage\ncollector will not terminate a goroutine blocked on a channel even if no other\ngoroutine has a reference to the channel.\nEven when goroutines do not leak, leaving them in-flight when they are no longer\nneeded can cause other subtle and hard-to-diagnose problems. Sending on a\nchannel that has been closed causes a panic.",
                "example": "// Bad:\nch := make(chan int)\nch <- 42\nclose(ch)\nch <- 13 // panic\n"
            },
            {
                "description": "Modifying still-in-use inputs “after the result isn’t needed” can lead to data\nraces. Leaving goroutines in-flight for arbitrarily long can lead to\nunpredictable memory usage.\nConcurrent code should be written such that the goroutine lifetimes are obvious.\nTypically this will mean keeping synchronization-related code constrained within\nthe scope of a function and factoring out the logic into synchronous functions . If the concurrency is still not obvious, it is\nimportant to document when and why the goroutines exit.\nCode that follows best practices around context usage often helps make this\nclear. It is conventionally managed with a `context.Context`:",
                "example": "// Good:\nfunc (w *Worker) Run(ctx context.Context) error {\n    // ...\n    for item := range w.q {\n        // process returns at latest when the context is cancelled.\n        go process(ctx, item)\n    }\n    // ...\n}\n"
            },
            {
                "description": "There are other variants of the above that use raw signal channels like `chanstruct{}`, synchronized variables, condition variables , and\nmore. The important part is that the goroutine’s end is evident for subsequent\nmaintainers.\nIn contrast, the following code is careless about when its spawned goroutines\nfinish:",
                "example": "// Bad:\nfunc (w *Worker) Run() {\n    // ...\n    for item := range w.q {\n        // process returns when it finishes, if ever, possibly not cleanly\n        // handling a state transition or termination of the Go program itself.\n        go process(item)\n    }\n    // ...\n}\n"
            },
            {
                "description": "This code may look OK, but there are several underlying problems:\nThe code probably has undefined behavior in production, and the program may\nnot terminate cleanly, even if the operating system releases the resources. \n\n\nThe code is difficult to test meaningfully due to the code’s indeterminate\nlifecycle. \n\n\nThe code may leak resources as described above.\nSee also:\nNever start a goroutine without knowing how it will stop \n\nRethinking Classical Concurrency Patterns: slides , video \n\n\nWhen Go programs end"
            }
        ]
    },
    {
        "title": "Interfaces",
        "belongs to": "Language/Literal formatting/Interfaces",
        "cases": [
            {
                "description": "Go interfaces generally belong in the package that consumes values of the\ninterface type, not a package that implements the interface type. The\nimplementing package should return concrete (usually pointer or struct) types.\nThat way, new methods can be added to implementations without requiring\nextensive refactoring. See GoTip #49: Accept Interfaces, Return Concrete Types for more details.\nDo not export a test double implementation of an interface from\nan API that consumes it. Instead, design the API so that it can be tested using\nthe public API of the real implementation . See GoTip #42: Authoring a Stub for Testing for more details. Even when it is not\nfeasible to use the real implementation, it may not be necessary to introduce an\ninterface fully covering all methods in the real type; the consumer can create\nan interface containing only the methods it needs, as demonstrated in GoTip #78: Minimal Viable Interfaces .\nTo test packages that use Stubby RPC clients, use a real client connection. If a\nreal server cannot be run in the test, Google’s internal practice is to obtain a\nreal client connection to a local test double using the internal rpctest\npackage (coming soon!).\nDo not define interfaces before they are used (see TotT: Code Health: Eliminate YAGNI Smells ). Without a realistic\nexample of usage, it is too difficult to see whether an interface is even\nnecessary, let alone what methods it should contain.\nDo not use interface-typed parameters if the users of the package do not need to\npass different types for them.\nDo not export interfaces that the users of the package do not need.\nTODO: Write a more in-depth doc on interfaces and link to it here.",
                "example": "// Good:\npackage consumer // consumer.go\n\ntype Thinger interface { Thing() bool }\n\nfunc Foo(t Thinger) string { ... }\n\n// Good:\npackage consumer // consumer_test.go\n\ntype fakeThinger struct{ ... }\nfunc (t fakeThinger) Thing() bool { ... }\n...\nif Foo(fakeThinger{...}) == \"x\" { ... }\n\n// Bad:\npackage producer\n\ntype Thinger interface { Thing() bool }\n\ntype defaultThinger struct{ ... }\nfunc (t defaultThinger) Thing() bool { ... }\n\nfunc NewThinger() Thinger { return defaultThinger{ ... } }\n\n// Good:\npackage producer\n\ntype Thinger struct{ ... }\nfunc (t Thinger) Thing() bool { ... }\n\nfunc NewThinger() Thinger { return Thinger{ ... } }\n"
            }
        ]
    },
    {
        "title": "Generics",
        "belongs to": "Language/Literal formatting/Generics",
        "cases": [
            {
                "description": "Generics (formally called “ Type Parameters ”) are allowed where they fulfill\nyour business requirements. In many applications, a conventional approach using\nexisting language features (slices, maps, interfaces, and so on) works just as\nwell without the added complexity, so be wary of premature use. See the\ndiscussion on least mechanism .\nWhen introducing an exported API that uses generics, make sure it is suitably\ndocumented. It’s highly encouraged to include motivating runnable examples .\nDo not use generics just because you are implementing an algorithm or data\nstructure that does not care about the type of its member elements. If there is\nonly one type being instantiated in practice, start by making your code work on\nthat type without using generics at all. Adding polymorphism later will be\nstraightforward compared to removing abstraction that is found to be\nunnecessary.\nDo not use generics to invent domain-specific languages (DSLs). In particular,\nrefrain from introducing error-handling frameworks that might put a significant\nburden on readers. Instead prefer established error handling practices. For testing, be especially wary of introducing assertion libraries or frameworks that result in less useful test failures .\nIn general:\nWrite code, don’t design types . From a GopherCon talk by Robert Griesemer\nand Ian Lance Taylor. \nIf you have several types that share a useful unifying interface, consider\nmodeling the solution using that interface. Generics may not be needed. \nOtherwise, instead of relying on the `any`type and excessive type switching , consider generics.\nSee also:\nUsing Generics in Go , talk by Ian Lance Taylor \n\n\n\nGenerics tutorial on Go’s webpage"
            }
        ]
    },
    {
        "title": "Pass values",
        "belongs to": "Language/Literal formatting/Pass values",
        "cases": [
            {
                "description": "Do not pass pointers as function arguments just to save a few bytes. If a\nfunction reads its argument `x`only as `*x`throughout, then the argument\nshouldn’t be a pointer. Common instances of this include passing a pointer to a\nstring ( `*string`) or a pointer to an interface value ( `*io.Reader`). In both\ncases, the value itself is a fixed size and can be passed directly.\nThis advice does not apply to large structs, or even small structs that may\nincrease in size. In particular, protocol buffer messages should generally be\nhandled by pointer rather than by value. The pointer type satisfies the `proto.Message`interface (accepted by `proto.Marshal`, `protocmp.Transform`,\netc.), and protocol buffer messages can be quite large and often grow larger\nover time."
            }
        ]
    },
    {
        "title": "Receiver type",
        "belongs to": "Language/Literal formatting/Receiver type",
        "cases": [
            {
                "description": "A method receiver can be passed either as a value or a pointer, just as if it\nwere a regular function parameter. The choice between the two is based on which method set(s) the method should be a part of.\nCorrectness wins over speed or simplicity. There are cases where you must\nuse a pointer value. In other cases, pick pointers for large types or as\nfuture-proofing if you don’t have a good sense of how the code will grow, and\nuse values for simple plain old data .\nThe list below spells out each case in further detail:\nIf the receiver is a slice and the method doesn’t reslice or reallocate the\nslice, use a value rather than a pointer.",
                "example": "// Good:\ntype Buffer []byte\n\nfunc (b Buffer) Len() int { return len(b) }\n"
            },
            {
                "description": "If the method needs to mutate the receiver, the receiver must be a pointer.",
                "example": "// Good:\ntype Counter int\n\nfunc (c *Counter) Inc() { *c++ }\n\n// See https://pkg.go.dev/container/heap.\ntype Queue []Item\n\nfunc (q *Queue) Push(x Item) { *q = append([]Item{x}, *q...) }\n"
            },
            {
                "description": "If the receiver is a struct containing fields that cannot safely be copied , use a pointer receiver. Common examples\nare \n`sync.Mutex`\nand other synchronization types.",
                "example": "// Good:\ntype Counter struct {\n    mu    sync.Mutex\n    total int\n}\n\nfunc (c *Counter) Inc() {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n    c.total++\n}\n"
            },
            {
                "description": "Tip: Check the type’s Godoc for information about whether it is safe\nor unsafe to copy. \n\n\nIf the receiver is a “large” struct or array, a pointer receiver may be more\nefficient. Passing a struct is equivalent to passing all of its fields or\nelements as arguments to the method. If that seems too large to pass by value , a pointer is a good choice. \n\n\nFor methods that will call or run concurrently with other functions that\nmodify the receiver, use a value if those modifications should not be\nvisible to your method; otherwise use a pointer. \n\n\nIf the receiver is a struct or array, any of whose elements is a pointer to\nsomething that may be mutated, prefer a pointer receiver to make the\nintention of mutability clear to the reader.",
                "example": "// Good:\ntype Counter struct {\n    m *Metric\n}\n\nfunc (c *Counter) Inc() {\n    c.m.Add(1)\n}\n"
            },
            {
                "description": "If the receiver is a built-in type , such as an integer or a string, that\ndoes not need to be modified, use a value.",
                "example": "// Good:\ntype User string\n\nfunc (u User) String() { return string(u) }\n"
            },
            {
                "description": "If the receiver is a map, function, or channel, use a value rather than a\npointer.",
                "example": "// Good:\n// See https://pkg.go.dev/net/http#Header.\ntype Header map[string][]string\n\nfunc (h Header) Add(key, value string) { /* omitted */ }\n"
            },
            {
                "description": "If the receiver is a “small” array or struct that is naturally a value type\nwith no mutable fields and no pointers, a value receiver is usually the\nright choice.",
                "example": "// Good:\n// See https://pkg.go.dev/time#Time.\ntype Time struct { /* omitted */ }\n\nfunc (t Time) Add(d Duration) Time { /* omitted */ }\n",
                "appendix": "When in doubt, use a pointer receiver."
            },
            {
                "description": "As a general guideline, prefer to make the methods for a type either all pointer\nmethods or all value methods.\nNote: There is a lot of misinformation about whether passing a value or a\npointer to a function can affect performance. The compiler can choose to pass\npointers to values on the stack as well as copying values on the stack, but\nthese considerations should not outweigh the readability and correctness of the\ncode in most circumstances. When the performance does matter, it is important to\nprofile both approaches with a realistic benchmark before deciding that one\napproach outperforms the other."
            }
        ]
    },
    {
        "title": "switch\n    \n    and\n    \n     break",
        "belongs to": "Language/Literal formatting/switch\n    \n    and\n    \n     break",
        "cases": [
            {
                "description": "Do not use `break`statements without target labels at the ends of `switch`clauses; they are redundant. Unlike in C and Java, `switch`clauses in Go\nautomatically break, and a `fallthrough`statement is needed to achieve the\nC-style behavior. Use a comment rather than `break`if you want to clarify the\npurpose of an empty clause.",
                "example": "// Good:\nswitch x {\ncase \"A\", \"B\":\n    buf.WriteString(x)\ncase \"C\":\n    // handled outside of the switch statement\ndefault:\n    return fmt.Errorf(\"unknown value: %q\", x)\n}\n\n// Bad:\nswitch x {\ncase \"A\", \"B\":\n    buf.WriteString(x)\n    break // this break is redundant\ncase \"C\":\n    break // this break is redundant\ndefault:\n    return fmt.Errorf(\"unknown value: %q\", x)\n}\n"
            },
            {
                "description": "Note: If a `switch`clause is within a `for`loop, using `break`within `switch`does not exit the enclosing `for`loop.",
                "example": "for {\n  switch x {\n  case \"A\":\n     break // exits the switch, not the loop\n  }\n}\n"
            },
            {
                "description": "To escape the enclosing loop, use a label on the `for`statement:",
                "example": "loop:\n  for {\n    switch x {\n    case \"A\":\n       break loop // exits the loop\n    }\n  }\n"
            }
        ]
    },
    {
        "title": "Synchronous functions",
        "belongs to": "Language/Literal formatting/Synchronous functions",
        "cases": [
            {
                "description": "Synchronous functions return their results directly and finish any callbacks or\nchannel operations before returning. Prefer synchronous functions over\nasynchronous functions.\nSynchronous functions keep goroutines localized within a call. This helps to\nreason about their lifetimes, and avoid leaks and data races. Synchronous\nfunctions are also easier to test, since the caller can pass an input and check\nthe output without the need for polling or synchronization.\nIf necessary, the caller can add concurrency by calling the function in a\nseparate goroutine. However, it is quite difficult (sometimes impossible) to\nremove unnecessary concurrency at the caller side.\nSee also:\n“Rethinking Classical Concurrency Patterns”, talk by Bryan Mills: slides , video"
            }
        ]
    },
    {
        "title": "Type aliases",
        "belongs to": "Language/Literal formatting/Type aliases",
        "cases": [
            {
                "description": "Use a type definition , `typeT1T2`, to define a new type. Use a \ntype alias \n, `typeT1=T2`, to refer to an existing type without defining a\nnew type. Type aliases are rare; their primary use is to aid migrating packages\nto new source code locations. Don’t use type aliasing when it is not needed."
            }
        ]
    },
    {
        "title": "Use %q",
        "belongs to": "Language/Literal formatting/Use %q",
        "cases": [
            {
                "description": "Go’s format functions ( `fmt.Printf`etc.) have a `%q`verb which prints strings\ninside double-quotation marks.",
                "example": "// Good:\nfmt.Printf(\"value %q looks like English text\", someText)\n"
            },
            {
                "description": "Prefer using `%q`over doing the equivalent manually, using `%s`:",
                "example": "// Bad:\nfmt.Printf(\"value \\\"%s\\\" looks like English text\", someText)\n// Avoid manually wrapping strings with single-quotes too:\nfmt.Printf(\"value '%s' looks like English text\", someText)\n"
            },
            {
                "description": "Using `%q`is recommended in output intended for humans where the input value\ncould possibly be empty or contain control characters. It can be very hard to\nnotice a silent empty string, but `\"\"`stands out clearly as such."
            }
        ]
    },
    {
        "title": "Use any",
        "belongs to": "Language/Literal formatting/Use any",
        "cases": [
            {
                "description": "Go 1.18 introduces an `any`type as an alias to `interface{}`. Because it is\nan alias, `any`is equivalent to `interface{}`in many situations and in others\nit is easily interchangeable via an explicit conversion. Prefer to use `any`in\nnew code."
            }
        ]
    },
    {
        "title": "Common libraries",
        "belongs to": "Common libraries",
        "cases": []
    },
    {
        "title": "Flags",
        "belongs to": "Common libraries/Flags",
        "cases": [
            {
                "description": "Go programs in the Google codebase use an internal variant of the standard `flag`package . It has a similar interface but interoperates well\nwith internal Google systems. Flag names in Go binaries should prefer to use\nunderscores to separate words, though the variables that hold a flag’s value\nshould follow the standard Go name style ( mixed caps ). Specifically, the flag\nname should be in snake case, and the variable name should be the equivalent\nname in camel case.",
                "example": "// Good:\nvar (\n    pollInterval = flag.Duration(\"poll_interval\", time.Minute, \"Interval to use for polling.\")\n)\n\n// Bad:\nvar (\n    poll_interval = flag.Int(\"pollIntervalSeconds\", 60, \"Interval to use for polling in seconds.\")\n)\n"
            },
            {
                "description": "Flags must only be defined in `packagemain`or equivalent.\nGeneral-purpose packages should be configured using Go APIs, not by punching\nthrough to the command-line interface; don’t let importing a library export new\nflags as a side effect. That is, prefer explicit function arguments or struct\nfield assignment or much less frequently and under the strictest of scrutiny\nexported global variables. In the extremely rare case that it is necessary to\nbreak this rule, the flag name must clearly indicate the package that it\nconfigures.\nIf your flags are global variables, place them in their own `var`group,\nfollowing the imports section.\nThere is additional discussion around best practices for creating complex CLIs with subcommands.\nSee also:\nTip of the Week #45: Avoid Flags, Especially in Library Code \n\n\nGo Tip #10: Configuration Structs and Flags \n\n\nGo Tip #80: Dependency Injection Principles"
            }
        ]
    },
    {
        "title": "Logging",
        "belongs to": "Common libraries/Logging",
        "cases": [
            {
                "description": "Go programs in the Google codebase use a variant of the standard \n`log`\npackage. It has a similar but more powerful interface and interoperates well\nwith internal Google systems. An open source version of this library is\navailable as package `glog`\n, and open source Google projects may use that, but\nthis guide refers to it as `log`throughout.\nNote: For abnormal program exits, this library uses `log.Fatal`to abort\nwith a stacktrace, and `log.Exit`to stop without one. There is no `log.Panic`function as in the standard library.\nTip: \n`log.Info(v)`is equivalent `log.Infof(\"%v\",v)`, and the same goes for\nother logging levels. Prefer the non-formatting version when you have no\nformatting to do.\nSee also:\nBest practices on logging errors and custom verbosily levels \n\nWhen and how to use the log package to stop the program"
            }
        ]
    },
    {
        "title": "Contexts",
        "belongs to": "Common libraries/Contexts",
        "cases": [
            {
                "description": "Values of the \n`context.Context`\ntype carry security credentials, tracing\ninformation, deadlines, and cancellation signals across API and process\nboundaries. Unlike C++ and Java, which in the Google codebase use thread-local\nstorage, Go programs pass contexts explicitly along the entire function call\nchain from incoming RPCs and HTTP requests to outgoing requests.\nWhen passed to a function or method, `context.Context`is always the first\nparameter.",
                "example": "func F(ctx context.Context /* other arguments */) {}\n"
            },
            {
                "description": "Exceptions are:\nIn an HTTP handler, where the context comes from \n`req.Context()`\n. \n\nIn streaming RPC methods, where the context comes from the stream. \nCode using gRPC streaming accesses a context from a `Context()`method in\nthe generated server type, which implements `grpc.ServerStream`. See gRPC Generated Code documentation . \n\n\nIn entrypoint functions (see below for examples of such functions), use \n`context.Background()`\n. \n\nIn binary targets: `main`\n\nIn general purpose code and libraries: `init`\n\nIn tests: `TestXXX`, `BenchmarkXXX`, `FuzzXXX`\nNote : It is very rare for code in the middle of a callchain to require\ncreating a base context of its own using `context.Background()`. Always prefer\ntaking a context from your caller, unless it’s the wrong context. \nYou may come across server libraries (the implementation of Stubby, gRPC, or\nHTTP in Google’s server framework for Go) that construct a fresh context\nobject per request. These contexts are immediately filled with information\nfrom the incoming request, so that when passed to the request handler, the\ncontext’s attached values have been propagated to it across the network\nboundary from the client caller. Moreover, these contexts’ lifetimes are\nscoped to that of the request: when the request is finished, the context is\ncancelled. \nUnless you are implementing a server framework, you shouldn’t create contexts\nwith `context.Background()`in library code. Instead, prefer using context\ndetachment, which is mentioned below, if there is an existing context\navailable. If you think you do need `context.Background()`outside of\nentrypoint functions, discuss it with the Google Go style mailing list before\ncommitting to an implementation.\nThe convention that `context.Context`comes first in functions also applies to\ntest helpers.",
                "example": "// Good:\nfunc readTestFile(ctx context.Context, t *testing.T, path string) string {}\n"
            },
            {
                "description": "Do not add a context member to a struct type. Instead, add a context parameter\nto each method on the type that needs to pass it along. The one exception is for\nmethods whose signature must match an interface in the standard library or in a\nthird party library outside Google’s control. Such cases are very rare, and\nshould be discussed with the Google Go style mailing list before implementation\nand readability review.\nCode in the Google codebase that must spawn background operations which can run\nafter the parent context has been cancelled can use an internal package for\ndetachment. Follow issue #40221 for\ndiscussions on an open source alternative.\nSince contexts are immutable, it is fine to pass the same context to multiple\ncalls that share the same deadline, cancellation signal, credentials, parent\ntrace, and so on.\nSee also:\nContexts and structs"
            }
        ]
    },
    {
        "title": "Custom contexts",
        "belongs to": "Common libraries/Contexts/Custom contexts",
        "cases": [
            {
                "description": "Do not create custom context types or use interfaces other than `context.Context`in function signatures. There are no exceptions to this rule.\nImagine if every team had a custom context. Every function call from package `p`to package `q`would have to determine how to convert a `p.Context`to a `q.Context`, for all pairs of packages `p`and `q`. This is impractical and\nerror-prone for humans, and it makes automated refactorings that add context\nparameters nearly impossible.\nIf you have application data to pass around, put it in a parameter, in the\nreceiver, in globals, or in a `Context`value if it truly belongs there.\nCreating your own context type is not acceptable since it undermines the ability\nof the Go team to make Go programs work properly in production."
            }
        ]
    },
    {
        "title": "crypto/rand",
        "belongs to": "Common libraries/Contexts/crypto/rand",
        "cases": [
            {
                "description": "Do not use package `math/rand`to generate keys, even throwaway ones. If\nunseeded, the generator is completely predictable. Seeded with `time.Nanoseconds()`, there are just a few bits of entropy. Instead, use `crypto/rand`’s Reader, and if you need text, print to hexadecimal or base64.",
                "example": "// Good:\nimport (\n    \"crypto/rand\"\n    // \"encoding/base64\"\n    // \"encoding/hex\"\n    \"fmt\"\n\n    // ...\n)\n\nfunc Key() string {\n    buf := make([]byte, 16)\n    if _, err := rand.Read(buf); err != nil {\n        log.Fatalf(\"Out of randomness, should never happen: %v\", err)\n    }\n    return fmt.Sprintf(\"%x\", buf)\n    // or hex.EncodeToString(buf)\n    // or base64.StdEncoding.EncodeToString(buf)\n}\n"
            },
            {
                "description": "Note: \n`log.Fatalf`is not the standard library log. See [#logging]."
            }
        ]
    },
    {
        "title": "Useful test failures",
        "belongs to": "Useful test failures",
        "cases": [
            {
                "description": "It should be possible to diagnose a test’s failure without reading the test’s\nsource. Tests should fail with helpful messages detailing:\nWhat caused the failure \nWhat inputs resulted in an error \nThe actual result \nWhat was expected\nSpecific conventions for achieving this goal are outlined below."
            }
        ]
    },
    {
        "title": "Assertion libraries",
        "belongs to": "Useful test failures/Assertion libraries",
        "cases": [
            {
                "description": "Do not create “assertion libraries” as helpers for testing.\nAssertion libraries are libraries that attempt to combine the validation and\nproduction of failure messages within a test (though the same pitfalls can apply\nto other test helpers as well). For more on the distinction between test helpers\nand assertion libraries, see best practices .",
                "example": "// Bad:\nvar obj BlogPost\n\nassert.IsNotNil(t, \"obj\", obj)\nassert.StringEq(t, \"obj.Type\", obj.Type, \"blogPost\")\nassert.IntEq(t, \"obj.Comments\", obj.Comments, 2)\nassert.StringNotEq(t, \"obj.Body\", obj.Body, \"\")\n"
            },
            {
                "description": "Assertion libraries tend to either stop the test early (if `assert`calls `t.Fatalf`or `panic`) or omit relevant information about what the test got\nright:",
                "example": "// Bad:\npackage assert\n\nfunc IsNotNil(t *testing.T, name string, val any) {\n    if val == nil {\n        t.Fatalf(\"Data %s = nil, want not nil\", name)\n    }\n}\n\nfunc StringEq(t *testing.T, name, got, want string) {\n    if got != want {\n        t.Fatalf(\"Data %s = %q, want %q\", name, got, want)\n    }\n}\n"
            },
            {
                "description": "Complex assertion functions often do not provide useful failure messages and\ncontext that exists within the test function. Too many assertion functions and\nlibraries lead to a fragmented developer experience: which assertion library\nshould I use, what style of output format should it emit, etc.? Fragmentation\nproduces unnecessary confusion, especially for library maintainers and authors\nof large-scale changes, who are responsible for fixing potential downstream\nbreakages. Instead of creating a domain-specific language for testing, use Go\nitself.\nAssertion libraries often factor out comparisons and equality checks. Prefer\nusing standard libraries such as \n`cmp`\nand \n`fmt`\ninstead:",
                "example": "// Good:\nvar got BlogPost\n\nwant := BlogPost{\n    Comments: 2,\n    Body:     \"Hello, world!\",\n}\n\nif !cmp.Equal(got, want) {\n    t.Errorf(\"Blog post = %v, want = %v\", got, want)\n}\n"
            },
            {
                "description": "For more domain-specific comparison helpers, prefer returning a value or an\nerror that can be used in the test’s failure message instead of passing `*testing.T`and calling its error reporting methods:",
                "example": "// Good:\nfunc postLength(p BlogPost) int { return len(p.Body) }\n\nfunc TestBlogPost_VeritableRant(t *testing.T) {\n    post := BlogPost{Body: \"I am Gunnery Sergeant Hartman, your senior drill instructor.\"}\n\n    if got, want := postLength(post), 60; got != want {\n        t.Errorf(\"Length of post = %v, want %v\", got, want)\n    }\n}\n"
            },
            {
                "description": "Best Practice: Were `postLength`non-trivial, it would make sense to test it\ndirectly, independently of any tests that use it.\nSee also:\nEquality comparison and diffs \n\n\nPrint diffs \n\nFor more on the distinction between test helpers and assertion helpers, see best practices"
            }
        ]
    },
    {
        "title": "Identify the function",
        "belongs to": "Useful test failures/Identify the function",
        "cases": [
            {
                "description": "In most tests, failure messages should include the name of the function that\nfailed, even though it seems obvious from the name of the test function.\nSpecifically, your failure message should be `YourFunc(%v)=%v,want%v`instead of just `got%v,want%v`."
            }
        ]
    },
    {
        "title": "Identify the input",
        "belongs to": "Useful test failures/Identify the input",
        "cases": [
            {
                "description": "In most tests, failure messages should include the function inputs if they are\nshort. If the relevant properties of the inputs are not obvious (for example,\nbecause the inputs are large or opaque), you should name your test cases with a\ndescription of what’s being tested and print the description as part of your\nerror message."
            }
        ]
    },
    {
        "title": "Got before want",
        "belongs to": "Useful test failures/Got before want",
        "cases": [
            {
                "description": "Test outputs should include the actual value that the function returned before\nprinting the value that was expected. A standard format for printing test\noutputs is `YourFunc(%v)=%v,want%v`. Where you would write “actual” and\n“expected”, prefer using the words “got” and “want”, respectively.\nFor diffs, directionality is less apparent, and as such it is important to\ninclude a key to aid in interpreting the failure. See the section on printing diffs . Whichever diff order you use in your failure\nmessages, you should explicitly indicate it as a part of the failure message,\nbecause existing code is inconsistent about the ordering."
            }
        ]
    },
    {
        "title": "Full structure comparisons",
        "belongs to": "Useful test failures/Full structure comparisons",
        "cases": [
            {
                "description": "If your function returns a struct (or any data type with multiple fields such as\nslices, arrays, and maps), avoid writing test code that performs a hand-coded\nfield-by-field comparison of the struct. Instead, construct the data that you’re\nexpecting your function to return, and compare directly using a deep comparison .\nNote: This does not apply if your data contains irrelevant fields that\nobscure the intention of the test.\nIf your struct needs to be compared for approximate (or equivalent kind of\nsemantic) equality or it contains fields that cannot be compared for equality\n(e.g., if one of the fields is an `io.Reader`), tweaking a \n`cmp.Diff`\nor \n`cmp.Equal`\ncomparison with \n`cmpopts`\noptions such as \n`cmpopts.IgnoreInterfaces`\nmay meet your needs\n( example ).\nIf your function returns multiple return values, you don’t need to wrap those in\na struct before comparing them. Just compare the return values individually and\nprint them.",
                "example": "// Good:\nval, multi, tail, err := strconv.UnquoteChar(`\\\"Fran & Freddie's Diner\\\"`, '\"')\nif err != nil {\n  t.Fatalf(...)\n}\nif val != `\"` {\n  t.Errorf(...)\n}\nif multi {\n  t.Errorf(...)\n}\nif tail != `Fran & Freddie's Diner\"` {\n  t.Errorf(...)\n}\n"
            }
        ]
    },
    {
        "title": "Compare stable results",
        "belongs to": "Useful test failures/Compare stable results",
        "cases": [
            {
                "description": "Avoid comparing results that may depend on output stability of a package that\nyou do not own. Instead, the test should compare on semantically relevant\ninformation that is stable and resistant to changes in dependencies. For\nfunctionality that returns a formatted string or serialized bytes, it is\ngenerally not safe to assume that the output is stable.\nFor example, \n`json.Marshal`\ncan change (and has changed in the past) the\nspecific bytes that it emits. Tests that perform string equality on the JSON\nstring may break if the `json`package changes how it serializes the bytes.\nInstead, a more robust test would parse the contents of the JSON string and\nensure that it is semantically equivalent to some expected data structure."
            }
        ]
    },
    {
        "title": "Keep going",
        "belongs to": "Useful test failures/Keep going",
        "cases": [
            {
                "description": "Tests should keep going for as long as possible, even after a failure, in order\nto print out all of the failed checks in a single run. This way, a developer who\nis fixing the failing test doesn’t have to re-run the test after fixing each bug\nto find the next bug.\nPrefer calling `t.Error`over `t.Fatal`for reporting a mismatch. When comparing\nseveral different properties of a function’s output, use `t.Error`for each of\nthose comparisons.\nCalling `t.Fatal`is primarily useful for reporting an unexpected error\ncondition, when subsequent comparison failures are not going to be meaningful.\nFor table-driven test, consider using subtests and use `t.Fatal`rather than `t.Error`and `continue`. See also GoTip #25: Subtests: Making Your Tests Lean .\nBest practice: For more discussion about when `t.Fatal`should be used, see best practices ."
            }
        ]
    },
    {
        "title": "Equality comparison and diffs",
        "belongs to": "Useful test failures/Equality comparison and diffs",
        "cases": [
            {
                "description": "The `==`operator evaluates equality using language-defined comparisons .\nScalar values (numbers, booleans, etc) are compared based on their values, but\nonly some structs and interfaces can be compared in this way. Pointers are\ncompared based on whether they point to the same variable, rather than based on\nthe equality of the values to which they point.\nThe \n`cmp`\npackage can compare more complex data structures not appropriately\nhandled by `==`, such as slices. Use \n`cmp.Equal`\nfor equality comparison and \n`cmp.Diff`\nto obtain a human-readable diff between objects.",
                "example": "// Good:\nwant := &Doc{\n    Type:     \"blogPost\",\n    Comments: 2,\n    Body:     \"This is the post body.\",\n    Authors:  []string{\"isaac\", \"albert\", \"emmy\"},\n}\nif !cmp.Equal(got, want) {\n    t.Errorf(\"AddPost() = %+v, want %+v\", got, want)\n}\n"
            },
            {
                "description": "As a general-purpose comparison library, `cmp`may not know how to compare\ncertain types. For example, it can only compare protocol buffer messages if\npassed the \n`protocmp.Transform`\noption.",
                "example": "// Good:\nif diff := cmp.Diff(want, got, protocmp.Transform()); diff != \"\" {\n    t.Errorf(\"Foo() returned unexpected difference in protobuf messages (-want +got):\\n%s\", diff)\n}\n"
            },
            {
                "description": "Although the `cmp`package is not part of the Go standard library, it is\nmaintained by the Go team and should produce stable equality results over time.\nIt is user-configurable and should serve most comparison needs.\nExisting code may make use of the following older libraries, and may continue\nusing them for consistency:\n`pretty`\nproduces aesthetically pleasing difference reports. However, it\nquite deliberately considers values that have the same visual representation\nas equal. In particular, `pretty`does not catch differences between nil\nslices and empty ones, is not sensitive to different interface\nimplementations with identical fields, and it is possible to use a nested\nmap as the basis for comparison with a struct value. It also serializes the\nentire value into a string before producing a diff, and as such is not a\ngood choice for comparing large values. By default, it compares unexported\nfields, which makes it sensitive to changes in implementation details in\nyour dependencies. For this reason, it is not appropriate to use `pretty`on\nprotobuf messages.\nPrefer using `cmp`for new code, and it is worth considering updating older code\nto use `cmp`where and when it is practical to do so.\nOlder code may use the standard library `reflect.DeepEqual`function to compare\ncomplex structures. `reflect.DeepEqual`should not be used for checking\nequality, as it is sensitive to changes in unexported fields and other\nimplementation details. Code that is using `reflect.DeepEqual`should be updated\nto one of the above libraries.\nNote: The `cmp`package is designed for testing, rather than production use.\nAs such, it may panic when it suspects that a comparison is performed\nincorrectly to provide instruction to users on how to improve the test to be\nless brittle. Given cmp’s propensity towards panicking, it makes it unsuitable\nfor code that is used in production as a spurious panic may be fatal."
            }
        ]
    },
    {
        "title": "Level of detail",
        "belongs to": "Useful test failures/Level of detail",
        "cases": [
            {
                "description": "The conventional failure message, which is suitable for most Go tests, is `YourFunc(%v)=%v,want%v`. However, there are cases that may call for more or\nless detail:\nTests performing complex interactions should describe the interactions too.\nFor example, if the same `YourFunc`is called several times, identify which\ncall failed the test. If it’s important to know any extra state of the\nsystem, include that in the failure output (or at least in the logs). \nIf the data is a complex struct with significant boilerplate, it is\nacceptable to describe only the important parts in the message, but do not\noverly obscure the data. \nSetup failures do not require the same level of detail. If a test helper\npopulates a Spanner table but Spanner was down, you probably don’t need to\ninclude which test input you were going to store in the database. `t.Fatalf(\"Setup:Failedtosetuptestdatabase:%s\",err)`is usually\nhelpful enough to resolve the issue.\nTip: Make your failure mode trigger during development. Review what the\nfailure message looks like and whether a maintainer can effectively deal with\nthe failure.\nThere are some techniques for reproducing test inputs and outputs clearly:\nWhen printing string data, \n`%q`is often useful to\nemphasize that the value is important and to more easily spot bad values. \nWhen printing (small) structs, `%+v`can be more useful than `%v`. \nWhen validation of larger values fails, printing a diff can\nmake it easier to understand the failure."
            }
        ]
    },
    {
        "title": "Print diffs",
        "belongs to": "Useful test failures/Print diffs",
        "cases": [
            {
                "description": "If your function returns large output then it can be hard for someone reading\nthe failure message to find the differences when your test fails. Instead of\nprinting both the returned value and the wanted value, make a diff.\nTo compute diffs for such values, `cmp.Diff`is preferred, particularly for new\ntests and new code, but other tools may be used. See types of equality for\nguidance regarding the strengths and weaknesses of each function.\n`cmp.Diff`\n\n\n\n\n\n\n`pretty.Compare`\nYou can use the \n`diff`\npackage to compare multi-line strings or lists of\nstrings. You can use this as a building block for other kinds of diffs.\nAdd some text to your failure message explaining the direction of the diff.\nSomething like `diff(-want+got)`is good when you’re using the `cmp`, `pretty`, and `diff`packages (if you pass `(want,got)`to the function),\nbecause the `-`and `+`that you add to your format string will match the `-`and `+`that actually appear at the beginning of the diff lines. If you\npass `(got,want)`to your function, the correct key would be `(-got+want)`instead. \n\n\nThe `messagediff`package uses a different output format, so the message `diff(want->got)`is appropriate when you’re using it (if you pass `(want,got)`to the function), because the direction of the arrow will\nmatch the direction of the arrow in the “modified” lines.\nThe diff will span multiple lines, so you should print a newline before you\nprint the diff."
            }
        ]
    },
    {
        "title": "Test error semantics",
        "belongs to": "Useful test failures/Test error semantics",
        "cases": [
            {
                "description": "When a unit test performs string comparisons or uses a vanilla `cmp`to check\nthat particular kinds of errors are returned for particular inputs, you may find\nthat your tests are brittle if any of those error messages are reworded in the\nfuture. Since this has the potential to turn your unit test into a change\ndetector (see TotT: Change-Detector Tests Considered Harmful ),\ndon’t use string comparison to check what type of error your function returns.\nHowever, it is permissible to use string comparisons to check that error\nmessages coming from the package under test satisfy certain properties, for\nexample, that it includes the parameter name.\nError values in Go typically have a component intended for human eyes and a\ncomponent intended for semantic control flow. Tests should seek to only test\nsemantic information that can be reliably observed, rather than display\ninformation that is intended for human debugging, as this is often subject to\nfuture changes. For guidance on constructing errors with semantic meaning see best-practices regarding errors . If an error\nwith insufficient semantic information is coming from a dependency outside your\ncontrol, consider filing a bug against the owner to help improve the API, rather\nthan relying on parsing the error message.\nWithin unit tests, it is common to only care whether an error occurred or not.\nIf so, then it is sufficient to only test whether the error was non-nil when you\nexpected an error. If you would like to test that the error semantically matches\nsome other error, then consider using \n`errors.Is`\nor `cmp`with \n`cmpopts.EquateErrors`\n.\nNote: If a test uses \n`cmpopts.EquateErrors`\nbut all of its `wantErr`values are either `nil`or `cmpopts.AnyError`, then using `cmp`is unnecessary mechanism . Simplify the code by making\nthe want field a `bool`. You can then use a simple comparison with `!=`.",
                "example": "// Good:\nerr := f(test.input)\ngotErr := err != nil\nif gotErr != test.wantErr {\n    t.Errorf(\"f(%q) = %v, want error presence = %v\", test.input, err, test.wantErr)\n}\n"
            },
            {
                "description": "See also GoTip #13: Designing Errors for Checking ."
            }
        ]
    },
    {
        "title": "Test structure",
        "belongs to": "Test structure",
        "cases": []
    },
    {
        "title": "Subtests",
        "belongs to": "Test structure/Subtests",
        "cases": [
            {
                "description": "The standard Go testing library offers a facility to define subtests . This\nallows flexibility in setup and cleanup, controlling parallelism, and test\nfiltering. Subtests can be useful (particularly for table-driven tests), but\nusing them is not mandatory. See also the Go blog post about subtests .\nSubtests should not depend on the execution of other cases for success or\ninitial state, because subtests are expected to be able to be run individually\nwith using `gotest-run`flags or with Bazel test filter expressions."
            }
        ]
    },
    {
        "title": "Subtest names",
        "belongs to": "Test structure/Subtests/Subtest names",
        "cases": [
            {
                "description": "Name your subtest such that it is readable in test output and useful on the\ncommand line for users of test filtering. When you use `t.Run`to create a\nsubtest, the first argument is used as a descriptive name for the test. To\nensure that test results are legible to humans reading the logs, choose subtest\nnames that will remain useful and readable after escaping. Think of subtest\nnames more like a function identifier than a prose description. The test runner\nreplaces spaces with underscores, and escapes non-printing characters. If your\ntest data benefits from a longer description, consider putting the description\nin a separate field (perhaps to be printed using `t.Log`or alongside failure\nmessages).\nSubtests may be run individually using flags to the Go test runner or Bazel test filter , so choose descriptive names that are also easy to type.\nWarning: Slash characters are particularly unfriendly in subtest names,\nsince they have special meaning for test filters .",
                "example": "# Bad:\n# Assuming TestTime and t.Run(\"America/New_York\", ...)\nbazel test :mytest --test_filter=\"Time/New_York\"    # Runs nothing!\nbazel test :mytest --test_filter=\"Time//New_York\"   # Correct, but awkward.\n"
            },
            {
                "description": "To identify the inputs of the function, include them in the test’s failure\nmessages, where they won’t be escaped by the test runner.",
                "example": "// Good:\nfunc TestTranslate(t *testing.T) {\n    data := []struct {\n        name, desc, srcLang, dstLang, srcText, wantDstText string\n    }{\n        {\n            name:        \"hu=en_bug-1234\",\n            desc:        \"regression test following bug 1234. contact: cleese\",\n            srcLang:     \"hu\",\n            srcText:     \"cigarettát és egy öngyújtót kérek\",\n            dstLang:     \"en\",\n            wantDstText: \"cigarettes and a lighter please\",\n        }, // ...\n    }\n    for _, d := range data {\n        t.Run(d.name, func(t *testing.T) {\n            got := Translate(d.srcLang, d.dstLang, d.srcText)\n            if got != d.wantDstText {\n                t.Errorf(\"%s\\nTranslate(%q, %q, %q) = %q, want %q\",\n                    d.desc, d.srcLang, d.dstLang, d.srcText, got, d.wantDstText)\n            }\n        })\n    }\n}\n"
            },
            {
                "description": "Here are a few examples of things to avoid:",
                "example": "// Bad:\n// Too wordy.\nt.Run(\"check that there is no mention of scratched records or hovercrafts\", ...)\n// Slashes cause problems on the command line.\nt.Run(\"AM/PM confusion\", ...)\n"
            },
            {
                "description": "See also Go Tip #117: Subtest Names ."
            }
        ]
    },
    {
        "title": "Table-driven tests",
        "belongs to": "Test structure/Subtests/Table-driven tests",
        "cases": [
            {
                "description": "Use table-driven tests when many different test cases can be tested using\nsimilar testing logic.\nWhen testing whether the actual output of a function is equal to the\nexpected output. For example, the many tests of `fmt.Sprintf`\nor the\nminimal snippet below. \nWhen testing whether the outputs of a function always conform to the same\nset of invariants. For example, tests for `net.Dial`\n.\nHere is the minimal structure of a table-driven test. If needed, you may use\ndifferent names or add extra facilities such as subtests or setup and cleanup\nfunctions. Always keep useful test failures in mind.",
                "example": "// Good:\nfunc TestCompare(t *testing.T) {\n    compareTests := []struct {\n        a, b string\n        want int\n    }{\n        {\"\", \"\", 0},\n        {\"a\", \"\", 1},\n        {\"\", \"a\", -1},\n        {\"abc\", \"abc\", 0},\n        {\"ab\", \"abc\", -1},\n        {\"abc\", \"ab\", 1},\n        {\"x\", \"ab\", 1},\n        {\"ab\", \"x\", -1},\n        {\"x\", \"a\", 1},\n        {\"b\", \"x\", -1},\n        // test runtime·memeq's chunked implementation\n        {\"abcdefgh\", \"abcdefgh\", 0},\n        {\"abcdefghi\", \"abcdefghi\", 0},\n        {\"abcdefghi\", \"abcdefghj\", -1},\n    }\n\n    for _, test := range compareTests {\n        got := Compare(test.a, test.b)\n        if got != test.want {\n            t.Errorf(\"Compare(%q, %q) = %v, want %v\", test.a, test.b, got, test.want)\n        }\n    }\n}\n"
            },
            {
                "description": "Note : The failure messages in this example above fulfill the guidance to identify the function and identify the input . There’s no need to identify the row numerically .\nWhen some test cases need to be checked using different logic from other test\ncases, it is more appropriate to write multiple test functions, as explained in GoTip #50: Disjoint Table Tests . The logic of your test code can get difficult\nto understand when each entry in a table has its own different conditional logic\nto check each output for its inputs. If test cases have different logic but\nidentical setup, a sequence of subtests within a single test\nfunction might make sense.\nYou can combine table-driven tests with multiple test functions. For example,\nwhen testing that a function’s output exactly matches the expected output and\nthat the function returns a non-nil error for an invalid input, then writing two\nseparate table-driven test functions is the best approach: one for normal\nnon-error outputs, and one for error outputs."
            }
        ]
    },
    {
        "title": "Data-driven test cases",
        "belongs to": "Test structure/Subtests/Table-driven tests/Data-driven test cases",
        "cases": [
            {
                "description": "Table test rows can sometimes become complicated, with the row values dictating\nconditional behavior inside the test case. The extra clarity from the\nduplication between the test cases is necessary for readability.",
                "example": "// Good:\ntype decodeCase struct {\n    name   string\n    input  string\n    output string\n    err    error\n}\n\nfunc TestDecode(t *testing.T) {\n    // setupCodex is slow as it creates a real Codex for the test.\n    codex := setupCodex(t)\n\n    var tests []decodeCase // rows omitted for brevity\n\n    for _, test := range tests {\n        t.Run(test.name, func(t *testing.T) {\n            output, err := Decode(test.input, codex)\n            if got, want := output, test.output; got != want {\n                t.Errorf(\"Decode(%q) = %v, want %v\", test.input, got, want)\n            }\n            if got, want := err, test.err; !cmp.Equal(got, want) {\n                t.Errorf(\"Decode(%q) err %q, want %q\", test.input, got, want)\n            }\n        })\n    }\n}\n\nfunc TestDecodeWithFake(t *testing.T) {\n    // A fakeCodex is a fast approximation of a real Codex.\n    codex := newFakeCodex()\n\n    var tests []decodeCase // rows omitted for brevity\n\n    for _, test := range tests {\n        t.Run(test.name, func(t *testing.T) {\n            output, err := Decode(test.input, codex)\n            if got, want := output, test.output; got != want {\n                t.Errorf(\"Decode(%q) = %v, want %v\", test.input, got, want)\n            }\n            if got, want := err, test.err; !cmp.Equal(got, want) {\n                t.Errorf(\"Decode(%q) err %q, want %q\", test.input, got, want)\n            }\n        })\n    }\n}\n"
            },
            {
                "description": "In the counterexample below, note how hard it is to distinguish between which\ntype of `Codex`is used per test case in the case setup. (The highlighted parts\nrun afoul of the advice from TotT: Data Driven Traps! .)",
                "example": "// Bad:\ntype decodeCase struct {\n  name   string\n  input  string\n  codex  testCodex\n  output string\n  err    error\n}\n\ntype testCodex int\n\nconst (\n  fake testCodex = iota\n  prod\n)\n\nfunc TestDecode(t *testing.T) {\n  var tests []decodeCase // rows omitted for brevity\n\n  for _, test := tests {\n    t.Run(test.name, func(t *testing.T) {\n      var codex Codex\n      switch test.codex {\n      case fake:\n        codex = newFakeCodex()\n      case prod:\n        codex = setupCodex(t)\n      default:\n        t.Fatalf(\"Unknown codex type: %v\", codex)\n      }\n      output, err := Decode(test.input, codex)\n      if got, want := output, test.output; got != want {\n        t.Errorf(\"Decode(%q) = %q, want %q\", test.input, got, want)\n      }\n      if got, want := err, test.err; !cmp.Equal(got, want) {\n        t.Errorf(\"Decode(%q) err %q, want %q\", test.input, got, want)\n      }\n    })\n  }\n}\n"
            }
        ]
    },
    {
        "title": "Identifying the row",
        "belongs to": "Test structure/Subtests/Table-driven tests/Identifying the row",
        "cases": [
            {
                "description": "Do not use the index of the test in the test table as a substitute for naming\nyour tests or printing the inputs. Nobody wants to go through your test table\nand count the entries in order to figure out which test case is failing.",
                "example": "// Bad:\ntests := []struct {\n    input, want string\n}{\n    {\"hello\", \"HELLO\"},\n    {\"wORld\", \"WORLD\"},\n}\nfor i, d := range tests {\n    if strings.ToUpper(d.input) != d.want {\n        t.Errorf(\"Failed on case #%d\", i)\n    }\n}\n"
            },
            {
                "description": "Add a test description to your test struct and print it along failure messages.\nWhen using subtests, your subtest name should be effective in identifying the\nrow.\nImportant: Even though `t.Run`scopes the output and execution, you must\nalways identify the input . The table test row names must follow the subtest naming guidance."
            }
        ]
    },
    {
        "title": "Test helpers",
        "belongs to": "Test structure/Subtests/Table-driven tests/Test helpers",
        "cases": [
            {
                "description": "A test helper is a function that performs a setup or cleanup task. All failures\nthat occur in test helpers are expected to be failures of the environment (not\nfrom the code under test) — for example when a test database cannot be started\nbecause there are no more free ports on this machine.\nIf you pass a `*testing.T`, call \n`t.Helper`\nto attribute failures in the test\nhelper to the line where the helper is called. This parameter should come after\na context parameter, if present, and before any remaining\nparameters.",
                "example": "// Good:\nfunc TestSomeFunction(t *testing.T) {\n    golden := readFile(t, \"testdata/golden-result.txt\")\n    // ... tests against golden ...\n}\n\n// readFile returns the contents of a data file.\n// It must only be called from the same goroutine as started the test.\nfunc readFile(t *testing.T, filename string) string {\n    t.Helper()\n    contents, err := runfiles.ReadFile(filename)\n    if err != nil {\n        t.Fatal(err)\n    }\n    return string(contents)\n}\n"
            },
            {
                "description": "Do not use this pattern when it obscures the connection between a test failure\nand the conditions that led to it. Specifically, the guidance about assert libraries still applies, and \n`t.Helper`\nshould not be used\nto implement such libraries.\nTip: For more on the distinction between test helpers and assertion helpers,\nsee best practices .\nAlthough the above refers to `*testing.T`, much of the advice stays the same for\nbenchmark and fuzz helpers."
            }
        ]
    },
    {
        "title": "Test package",
        "belongs to": "Test structure/Subtests/Table-driven tests/Test package",
        "cases": []
    },
    {
        "title": "Tests in the same package",
        "belongs to": "Test structure/Subtests/Table-driven tests/Test package/Tests in the same package",
        "cases": [
            {
                "description": "Tests may be defined in the same package as the code being tested.\nTo write a test in the same package:\nPlace the tests in a `foo_test.go`file \nUse `packagefoo`for the test file \nDo not explicitly import the package to be tested",
                "example": "# Good:\ngo_library(\n    name = \"foo\",\n    srcs = [\"foo.go\"],\n    deps = [\n        ...\n    ],\n)\n\ngo_test(\n    name = \"foo_test\",\n    size = \"small\",\n    srcs = [\"foo_test.go\"],\n    library = \":foo\",\n    deps = [\n        ...\n    ],\n)\n"
            },
            {
                "description": "A test in the same package can access unexported identifiers in the package.\nThis may enable better test coverage and more concise tests. Be aware that any examples declared in the test will not have the package names that a user will\nneed in their code."
            }
        ]
    },
    {
        "title": "Tests in a different package",
        "belongs to": "Test structure/Subtests/Table-driven tests/Test package/Tests in a different package",
        "cases": [
            {
                "description": "It is not always appropriate or even possible to define a test in the same\npackage as the code being tested. In these cases, use a package name with the `_test`suffix. This is an exception to the “no underscores” rule to package names . For example:\nIf an integration test does not have an obvious library that it belongs to",
                "example": "// Good:\npackage gmailintegration_test\n\nimport \"testing\"\n"
            },
            {
                "description": "If defining the tests in the same package results in circular dependencies",
                "example": "// Good:\npackage fireworks_test\n\nimport (\n  \"fireworks\"\n  \"fireworkstestutil\" // fireworkstestutil also imports fireworks\n)\n"
            }
        ]
    },
    {
        "title": "Use package\n    \n     testing",
        "belongs to": "Test structure/Subtests/Table-driven tests/Test package/Use package\n    \n     testing",
        "cases": [
            {
                "description": "The Go standard library provides the \n`testing`package . This is the only\ntesting framework permitted for Go code in the Google codebase. In particular, assertion libraries and third-party testing frameworks are not\nallowed.\nThe `testing`package provides a minimal but complete set of functionality for\nwriting good tests:\nTop-level tests \nBenchmarks \n\nRunnable examples \n\nSubtests \nLogging \nFailures and fatal failures\nThese are designed to work cohesively with core language features like composite literal and if-with-initializer syntax to enable test authors to\nwrite [clear, readable, and maintainable tests]."
            }
        ]
    },
    {
        "title": "Non-decisions",
        "belongs to": "Non-decisions",
        "cases": [
            {
                "description": "A style guide cannot enumerate positive prescriptions for all matters, nor can\nit enumerate all matters about which it does not offer an opinion. That said,\nhere are a few things where the readability community has previously debated and\nhas not achieved consensus about.\nLocal variable initialization with zero value . `variint`and `i:=0`are equivalent. See also initialization best practices . \n\nEmpty composite literal vs. `new`or `make`\n. `&File{}`and `new(File)`are equivalent. So are `map[string]bool{}`and `make(map[string]bool)`. See\nalso composite declaration best practices . \n\ngot, want argument ordering in cmp.Diff calls . Be locally consistent,\nand include a legend in your failure message. \n\n\n`errors.New`vs `fmt.Errorf`on non-formatted strings . `errors.New(\"foo\")`and `fmt.Errorf(\"foo\")`may be used interchangeably.\nIf there are special circumstances where they come up again, the readability\nmentor might make an optional comment, but in general the author is free to pick\nthe style they prefer in the given situation.\nNaturally, if anything not covered by the style guide does need more discussion,\nauthors are welcome to ask – either in the specific review, or on internal\nmessage boards.\nThis site is open source. Improve this page ."
            }
        ]
    }
]