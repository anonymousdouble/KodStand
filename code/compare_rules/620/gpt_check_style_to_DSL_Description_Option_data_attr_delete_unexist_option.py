import os,json
import re
import shutil

import util

from openai import OpenAI
from retry import retry
from code.compare_rules.gpt_agent import GPTAgent
# rule=rule_description, DSL_Syntax=dsl
def preprocess_promt(rule: str, DSL_Syntax: str, style="CheckStyle Rule",grammar="Grammar",example="",options="Answer about Options are data specifications or not",Options_Answer=None):
    #then determine formal term of Java for objects of style and determine the appropriate operators between terms. Pay attention to
    prompt = '''Analyze the following {{Style}} and DSL representation parsed using given grammar, please delete unexisted OptionName. 

1. Analyze whether each sentence of descriptions of {{Style}} is a rule or not. If it is a rule, parsing it as a rule using the given {{grammar}}. If terms of rule refer to options that are data specifications, pay attention to using {{OptionName}} to represent the term. Otherwise, skip it. If the rule is subjective, skip it too. 
2. For each option that is not data specification, for each value, please parse it as a rule using giving {{grammar}}. If terms of rule are options refer to are data specifications, pay attention to using {{OptionName}} to represent the term.
3. For each option that is data specification, please provide the option type, value range, default value. 
4. When parsing a rule using the given {{grammar}}, pay attention to map to suitable formal Java term and select appropriate real operator characters. 

{{Style}}:
{{Description}}

{{Options}}
{{Options_Answer}}

{{grammar}}:
{{Syntax}}

{{Example}}

Response Format:
If there is no option, you only give basic rule
Final RuleSet Representation:
Basic Rule:
...

Otherwise,
Final RuleSet Representation:
Basic Rule:
...

Option Rule:
...

Options that are data specifications:
...
'''
    # '''

    prompt = prompt.replace("{{Example}}", example)
    prompt = prompt.replace("{{Style}}", style)
    prompt = prompt.replace("{{Syntax}}", DSL_Syntax)
    prompt = prompt.replace("{{Description}}", rule)
    prompt = prompt.replace("{{Options_Answer}}", Options_Answer)
    prompt = prompt.replace("{{Options}}", options)
    prompt = prompt.replace("{{grammar}}", grammar)

    return prompt

'''
class GPTAgent:

    def __init__(self) -> None:
        self.client = OpenAI(
            api_key="sk-proj-vrNPSb5ttqXsOV39pl7FT3BlbkFJ93LlRultIv7DLd7Pwe8e"

        )
        # self.client = OpenAI(
        #     base_url="https://api.xty.app/v1",
        #     api_key="sk-proj-vrNPSb5ttqXsOV39pl7FT3BlbkFJ93LlRultIv7DLd7Pwe8e",
        #     http_client=httpx.Client(
        #             base_url="https://api.xty.app/v1",
        #             follow_redirects=True,
        #     ),
        # )

    @retry(delay=0, tries=6, backoff=1, max_delay=120)
    def ask(self, content):
        messages = []
        messages.append({"role": "user", "content": content})
        completion = self.client.chat.completions.create(
            model="gpt-3.5-turbo-0125",
            messages=messages,
            temperature=0,
            response_format={"type": "json_object"}
        )
        # print(completion)
        return completion.choices[0].message.content

    def get_response(self, prompt):
        
        # Answer: You respond with Yes or No for whether exists an ESLint configuration for the given style convention
        # Configuration:
        # rule-name: ['error', {
        #   option1: value1,
        #   ...
        #   optionn: valuen
        # }]
        
        answer = self.ask(prompt)
        return answer
        # if len(eslint_rules_simple) > 0:
        #     # question = "Given a rule:\n\n"
        #     # question += rule
        #     # question += "Can you find a corresponding rule in the following rule set?\n\n"
        #     # question += eslint_rules_simple
        #     answer = self.wrapper.ask(prompt)
        #     print(answer)
'''
def get_all_gpt_res_for_java_checkstyle(rule_list,dsl, examples=None,style="Google Java Style Guide",model="gpt-4o",options="Options are data specifications",Options_Answer=None):
    '''
    1. parse each rule of style guide as a string
    2. parse all rules of style tool as a string
    3. get and save GPT results
    '''

    agent = GPTAgent()

    # generated by /Users/zhangzejunzhangzejun/PycharmProjects/KodStand-main/code/extract_googlestyle_rules.py
    # rule_list = util.load_json(util.data_root +"rule/google_java_style/","google_java_style")
    data_dir = util.data_root + "rule/google/"

    # all_rules = util.load_csv(data_dir + "javaguide_refine.csv")
    # all_rules = util.load_csv(util.data_root + "GoogleJavaStyle/googlejavastyle 2.csv")

    # html
    '''
    GPT results_rule_name_descr_options
    GPT results_rule_name_descr	
    GPT results_html
    '''
    # util.save_json(util.data_root + "style_tool_rules/", "checkstyle_name_des_options", all_checkstyle_details)

    # generated by /Users/zhangzejunzhangzejun/PycharmProjects/KodStand-main/code/extract_checkstyle_rules_infor_process_to_control_length_gpt.py
    # check_style_rule_list = util.load_json(util.data_root + "style_tool_rules/", "checkstyle_name_des_options_process_control_length")
    # check_style_rule_list = ["\n".join(["Rulename", rule_name, description, options]) if options else "\n".join(
    #     ["Rulename", rule_name, description]) for url, rule_name, description, options in check_style_rule_list]
    # checkstyle_str = "\n".join(check_style_rule_list)
    # print(">>>>checkstyle_str: ",checkstyle_str)
    # util.save_json(util.data_root + "style_tool_rules/", "checkstyle_name_des_options", all_checkstyle_details)
    # print(">>>all_rules: ", len(all_rules))
    # for ind,each in enumerate(examples):
    #     examples[ind][0] = preprocess_promt(rule=each[0], DSL_Syntax=dsl, style=style)
        # checkstyle_str = "\n".join(check_style_rule_list)

    for ind, rule_description in enumerate(rule_list[:]):
        # if ind!=180:#169 109, 2, 180, 3, 71, 134  164 EmptyLineSeparator 118voidStarImport 146 58 IllegalTokenText  FileTabCharacter
        # if ind not in [3, 10,183]:#95:
        #     continue
        # if ind not in [58,2,3, 71,95,109,134,164,169,180]:#95:
        #     continue
        # if ind!=180:#95:
        #     continue
        # if ind > 10:
        #     # continue
        #     break
        # rule_description = "\n".join([rule_name, description])
        # print("")
        print(">>>>>>rule: ", rule_description)

        # break
        prompt= preprocess_promt(rule=rule_description,example=examples,DSL_Syntax=dsl, style=style,options="Options are data specifications",Options_Answer=Options_Answer[ind][str(ind)])
        # print(">>>>>prompt: ",prompt)
        answer = agent.get_response(prompt, model=model)
        print(">>>>>>answer: ", ind,answer)
        # util.save_json(util.data_root + gpt_answer_dir, str(ind), {ind: answer})
        util.save_json(gpt_answer_dir, str(ind), {ind: answer})

        # break

if __name__ == "__main__":
    checkstyle_options_classify = util.load_json(util.data_root+"gpt_dsl_answer/","checkstyle_options_classify_3_check_nooption")

    gpt_answer_dir=util.data_root + "gpt_dsl_answer/gpt_check_style_to_DSL_Description_Option_3_check_nooption/"
    check_style_rule_list = util.load_json(util.data_root + "style_tool_rules/",
                                           "checkstyle_name_completedes_options_3_process")
    rule_list = ["\n".join(["Rulename", rule_name, description, "Options",options]) if options else "\n".join(
        ["Rulename", rule_name, description]) for url, rule_name, description, options in check_style_rule_list]
    '''Rulename
IllegalTokenText
Description

Checks specified tokens text for matching an illegal pattern.
By default, no tokens are specified.
Options

format, Define the RegExp for illegal pattern., Pattern, "^$"
ignoreCase, Control whether to ignore case when matching., boolean, false
message, Define the message which is used to notify about violations; if empty then the default message is used., String, ""
tokens, tokens to check, subset of tokens

NUM_DOUBLE
,
NUM_FLOAT
,
NUM_INT
,
NUM_LONG
,
IDENT
,
COMMENT_CONTENT
,
STRING_LITERAL
,
CHAR_LITERAL
,
TEXT_BLOCK_CONTENT
,
STRING_TEMPLATE_CONTENT
.
, empty
    '''
    '''Rulename
AvoidStaticImport
Description

Checks that there are no static import statements.


Rationale: Importing static members can lead to naming
conflicts between class' members. It may lead to poor code
readability since it may no longer be clear what class a
member resides in (without looking at the import statement).
Options

excludes, Control whether to allow for certain classes via a star notation to be excluded such as java.lang.Math.* or specific static members to be excluded like java.lang.System.out for a variable or java.lang.Math.random for a method. See notes section for details., String[], {}
    '''
    '''Rulename
IllegalInstantiation
Description

Checks for illegal instantiations where a factory method is
preferred.


Rationale: Depending on the project, for some classes it might be
preferable to create instances through factory methods rather than
calling the constructor.


A simple example is the java.lang.Boolean
class. For performance reasons, it is preferable to
use the predefined constants  TRUE and
FALSE. Constructor invocations should be
replaced by calls to Boolean.valueOf().


Some extremely performance sensitive projects may require the use of
factory methods for other classes as well, to enforce the usage of
number caches or object pools.
Options

classes, Specify fully qualified class names that should not be instantiated., String[], {}
    '''
    # all_rules = util.load_csv(util.data_root + "GoogleJavaStyle/javastyle_myanalyze.csv")
    # rule_list = ["\n".join([rule_name, description]) for ind, (url, rule_name, description,*remain) in enumerate(all_rules) if ind>0]
    dsl = '''RuleSet ::= Rule [And|OR Rule]*
Rule ::= [Term* | Number | Name | Order] operator Term* [operator Term*]* 
Modifier ::= some | each | all | except | first | last | ...
Operator ::= —> | of | have | not have | is | is not | start | end | before | after | between| > |  < | = | != | ...
Term :: = JavaTerm | Modifier* Term* 
(Note JavaTerm is formal term description in Java)
'''
    dsl = '''RuleSet ::= Rule [And|Or Rule]*
Rule ::= OrderRule | NumberRule | ValueRule | SequenceRule | InclusionRule | ConditionRule
OrderRule ::= 'Order ' valueOperator TermList
NumberRule ::= 'Number of' TermList numberOperator TermList
SequenceRule ::= TermList positionOperator TermList
ValueRule ::= TermList valueOperator TermList
InclusionRule ::= TermList inclusionOperator TermList
ConditionRule ::= Rule '—>' Rule  # means if Rule then Rule
numberOperator ::=  '>=' | '<=' | '=' | '!='
positionOperator ::=  'before' | 'after' | 'between' | 'not before' | 'not after' | 'not between'
inclusionOperator ::=  'have' | 'not have'
valueOperator ::=  'is' | 'is not'
TermList ::=  Term [, Term]*
Modifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...
Term :: = JavaTerm | Modifier* Term | Term of Term
JavaTerm :: = formal term description in Java
    '''
    dsl = '''RuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups
Rule ::= 'Optional'| 'Mandatory' [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1 
ExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule
Operator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'
TermList ::= Term [, Term]*
Modifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...
Term :: = JavaTerm | Modifier* Term | Term of Term
JavaTerm means the formal expression using such format [XXX] "XXX" represent a JavaTerm
'''
    dsl = '''RuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups
Rule ::= 'Optional:'| 'Mandatory:' [ 'No' TermList | ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means applying Rule2 under the premise of Rule1, 'No' TermList means TermList not allowed
ExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule
Operator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'at end of'｜ 'not at end of'｜ 'at begin of'｜ 'not at begin of' ｜'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'
TermList ::= Term [, Term]*
Modifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...
Term :: = JavaTerm | Modifier* Term | Term of Term
JavaTerm means the formal expression using such format [XXX] "XXX" represent a JavaTerm
    '''
#     dsl = '''RuleSet ::= Rule [And|OR Rule]*
# Rule ::= [Number | Name | Order] of modifier* Term* operator modifier* Term*  [operator modifier* Term*]*
# modifier ::= some | each | all | except | first | last | ...
# Operator ::= —> | of | have | not have | is | is not | start | end | before | after | between| > |  < | = | != | ...
# Term :: = JavaTerm
# (Note JavaTerm is formal term description in Java)
# '''
#     dsl = '''RuleSet ::= Rule [And|OR Rule]*
# Rule ::= modifier* Term* operator modifier* Term*  [operator modifier* Term*]*
# modifier ::= some | each | all | except | first | last | ...
# Operator ::= —> | of | have | not have | is | is not | start | end | before | after | between| > |  < | = | != | ...
# Term :: = Number | Name| Order| JavaTerm
# (Note JavaTerm is formal term description in Java)
#     '''
    examples='''For Example, respond like: 
Final RuleSet Representation:
Basic Rule:
Mandatory: Order of [import groups] is {{customImportOrderRules}}
And
Mandatory: {{customImportOrderRules}} not have [an import group] -> [the import group] at end of [import groups]

Option Rule:
separateLineBetweenGroups option:
true: Mandatory: [empty line] between [import groups]
false: Optional: [empty line] not between [import groups]

sortImportsInGroupAlphabetically option:
true: Mandatory: Order of [imports] of [import group] is [ASCII sort order]
false: Optional: Order of [imports] of [import group] is not [ASCII sort order]

Options that are data specifications:
{{customImportOrderRules}}: String[]; {STATIC, SAME_PACKAGE(n), SPECIAL_IMPORTS, STANDARD_JAVA_PACKAGE, THIRD_PARTY_PACKAGE}; {};
{{thirdPartyPackageRegExp}}: Pattern; RegExp; “.*”;

Final RuleSet Representation:
[block] of {{tokens}} have [Brace]

Option Rule:
allowEmptyLoopBody option:
false: Mandatory: [body] of [loop statement] is not [Null]
true: Optional: [body] of [loop statement] is [Null]

allowSingleLineStatement option:
false: Mandatory: Number of [statement] of [body] of {{tokens}} is 1 —> [body] of {{tokens}} have [Brace]
true: Optional: Number of [statement] of [body] of [{{tokens}} is 1 —> [body] of {{tokens}} not have [Brace]

Options that are data specifications:
tokens: String[]; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE, LITERAL_CASE, LITERAL_DEFAULT,LAMBDA}; {LITERAL_DO, LITERAL_ELSE, LITERAL_FOR, LITERAL_IF, LITERAL_WHILE};
'''
    # examples=''



    # get_all_gpt_res_for_java_checkstyle(rule_list,dsl,  examples=examples,style="CheckStyle Rule",model="gpt-4o",options="Options are data specifications",Options_Answer=checkstyle_options_classify)
    import copy
    all_rules = util.load_json(util.data_root + "style_tool_rules/",
                               "checkstyle_name_completedes_options_3_process")

    complete_info_checkstyle_to_dsl = []
    for ind in range(len(os.listdir(gpt_answer_dir))):
        gpt_dsl_rule_list = util.load_json(gpt_answer_dir, str(ind))
        # gpt_dsl_rule_list_original_answer = util.load_json(util.data_root + gpt_answer_dir, str(ind))
        # gpt_dsl_rule_list_original_answer = util.load_json(gpt_answer_dir, str(ind))
        if ind not in [58,2,3, 71,95,109,134,164,169,180]:#95:
            continue
        text = gpt_dsl_rule_list[str(ind)]
        print(text)
        ruleone = copy.deepcopy(all_rules[ind])
        # ruleone.insert(3, gpt_dsl_rule_list_original_answer[str(ind)])
        ruleone.insert(4, text)
        print(">>>: ", all_rules[ind][:2] + [text])
        complete_info_checkstyle_to_dsl.append(all_rules[ind][:4] + [text])
        # rule_list_add_gpt_result.append(ruleone)
        # rule_list_add_gpt_result[ind+1].insert
    # util.save_json(util.data_root + "gpt_dsl_answer/", "check_style_url_rulename_dsl_option", complete_info_checkstyle_to_dsl)
    # util.save_json(util.data_root + "GoogleJavaStyle/javastyle_myanalyze copy.csv", str(ind), {ind: answer})
    # util.save_csv(util.data_root + "GoogleJavaStyle/javastyle_myanalyze copy_add_GPT_DSL.csv",rule_list_add_gpt_result)
    # util.save_csv(util.data_root + "GoogleJavaStyle/javastyle_myanalyze copy_add_GPT_DSL_add_original_answer.csv",rule_list_add_gpt_result)
    # util.save_csv(util.data_root + "CheckStyle/CheckStyle_options_3_Simple_DSL_syntax_SplitSentence_example4_1_remove_repeat_option_add_GPT_answer.csv",rule_list_add_gpt_result)
    # util.save_csv(util.data_root + "CheckStyle/check_style_url_rulename_dsl_option_add_GPT_answer.csv",complete_info_checkstyle_to_dsl)
    # util.save_csv(util.data_root + "CheckStyle/check_style_url_rulename_dsl_option_add_GPT_answer.csv",complete_info_checkstyle_to_dsl)
    util.save_csv(util.data_root + "CheckStyle/check_style_url_rulename_dsl_option_add_GPT_answer_sample.csv",complete_info_checkstyle_to_dsl)

    # '''
    '''
    data_dir = util.data_root + "rule/google/"

    all_rules = util.load_csv(util.data_root + "GoogleJavaStyle/googlejavastyle.csv")
    gpt_answer_dir=util.data_root + "gpt_dsl_answer/GoogleJavaStyle_DSL/"
    '''
    '''
    csv_results=[]
    for index in range(len(os.listdir(gpt_answer_dir))):
    # for file_name in os.listdir(gpt_answer_dir):
    #     ind=file_name[:-5]
        ind=str(index)
        csv_results.append(all_rules[int(ind)])

        rule_dict = util.load_json(gpt_answer_dir,ind)
        answer_list=rule_dict[ind]
        try:
            json_object = json.loads(answer_list)
            print(answer_list)
            print(">>>>>>: ", json_object)
            y_or_n = json_object['Answer']
            csv_results[-1].append(y_or_n)
            configuration_list = json_object['Configuration']
            csv_results[-1].append("\n******\n".join(configuration_list))
        except:
            print(">>>>>>>exception")
            if "'Answer': 'Yes'" in answer_list:
                config=answer_list.split("'Configuration': [")[-1]
                config=config.split("']'")[0]
                config_str="\n******\n".join(["<module"+each_config for each_config in config.split("<module") ])
                csv_results[-1].append('Yes')
                csv_results[-1].append(config_str)
                # for each_config in config.split("<module"):
                #     new_config="<module"+each_config
                # print(">>>>config:",config.split("<module"))
                # json_object = json.loads(config)
            elif '"Answer": "Yes"' in answer_list:
                config = answer_list.split('"Configuration": [')[-1]
                config=config.split('"]"')[0]
                config_str = "\n******\n".join(["<module" + each_config for each_config in config.split("<module")])
                csv_results[-1].append('Yes')
                csv_results[-1].append(config_str)
                print(">>>>config:", config.split("<module"))
                # json_object = json.loads(config)
            else:
                csv_results[-1].append('No')

        # for config in configuration_list:
        #     print(">>>config: ",config)
        #     csv_results[-1].append("******\n".join(configuration_list))

        # for e_asw in answer_list:
        #     print(">>>e_asw: ",e_asw)
        # break

    util.save_csv(util.data_root + "gpt_direct_answer/csv/gpt_answergooglejavastyle_checkstyle_nocheckstyleRule.csv",csv_results,["url","rule_name","description","gpt_answer","gpt_configuration"])
    '''