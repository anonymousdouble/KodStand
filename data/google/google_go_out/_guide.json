[
    {
        "title": "Style principles",
        "belongs to": "Style principles",
        "cases": [
            {
                "description": "There are a few overarching principles that summarize how to think about writing\nreadable Go code. The following are attributes of readable code, in order of\nimportance:\nClarity \n: The code’s purpose and rationale is clear to the reader. \n\n\nSimplicity \n: The code accomplishes its goal in the simplest way\npossible. \n\n\nConcision \n: The code has a high signal-to-noise ratio. \n\n\nMaintainability \n: The code is written such that it can be easily\nmaintained. \n\n\nConsistency \n: The code is consistent with the broader Google codebase."
            }
        ]
    },
    {
        "title": "Clarity",
        "belongs to": "Style principles/Clarity",
        "cases": [
            {
                "description": "The core goal of readability is to produce code that is clear to the reader.\nClarity is primarily achieved with effective naming, helpful commentary, and\nefficient code organization.\nClarity is to be viewed through the lens of the reader, not the author of the\ncode. It is more important that code be easy to read than easy to write. Clarity\nin code has two distinct facets:\nWhat is the code actually doing? \n\n\nWhy is the code doing what it does?"
            }
        ]
    },
    {
        "title": "What is the code actually doing?",
        "belongs to": "Style principles/Clarity/What is the code actually doing?",
        "cases": [
            {
                "description": "Go is designed such that it should be relatively straightforward to see what the\ncode is doing. In cases of uncertainty or where a reader may require prior\nknowledge in order to understand the code, it is worth investing time in order\nto make the code’s purpose clearer for future readers. For example, it may help\nto:\nUse more descriptive variable names \nAdd additional commentary \nBreak up the code with whitespace and comments \nRefactor the code into separate functions/methods to make it more modular\nThere is no one-size-fits-all approach here, but it is important to prioritize\nclarity when developing Go code."
            }
        ]
    },
    {
        "title": "Why is the code doing what it does?",
        "belongs to": "Style principles/Clarity/Why is the code doing what it does?",
        "cases": [
            {
                "description": "The code’s rationale is often sufficiently communicated by the names of\nvariables, functions, methods, or packages. Where it is not, it is important to\nadd commentary. The “Why?” is especially important when the code contains\nnuances that a reader may not be familiar with, such as:\nA nuance in the language, e.g., a closure will be capturing a loop variable,\nbut the closure is many lines away \nA nuance of the business logic, e.g., an access control check that needs to\ndistinguish between the actual user and someone impersonating a user\nAn API might require care to use correctly. For example, a piece of code may be\nintricate and difficult to follow for performance reasons, or a complex sequence\nof mathematical operations may use type conversions in an unexpected way. In\nthese cases and many more, it is important that accompanying commentary and\ndocumentation explain these aspects so that future maintainers don’t make a\nmistake and so that readers can understand the code without needing to\nreverse-engineer it.\nIt is also important to be aware that some attempts to provide clarity (such as\nadding extra commentary) can actually obscure the code’s purpose by adding\nclutter, restating what the code already says, contradicting the code, or adding\nmaintenance burden to keep the comments up-to-date. Allow the code to speak for\nitself (e.g., by making the symbol names themselves self-describing) rather than\nadding redundant comments. It is often better for comments to explain why\nsomething is done, not what the code is doing.\nThe Google codebase is largely uniform and consistent. It is often the case that\ncode that stands out (e.g., by using an unfamiliar pattern) is doing so for a\ngood reason, typically for performance. Maintaining this property is important\nto make it clear to readers where they should focus their attention when reading\na new piece of code.\nThe standard library contains many examples of this principle in action. Among\nthem:\nMaintainer comments in \n`packagesort`\n. \nGood runnable examples in the same package ,\nwhich benefit both users (they show up in godoc ) and maintainers\n(they run as part of tests ). \n\n\n`strings.Cut`\nis only four lines of code,\nbut they improve the clarity and correctness of callsites ."
            }
        ]
    },
    {
        "title": "Simplicity",
        "belongs to": "Style principles/Clarity/Simplicity",
        "cases": [
            {
                "description": "Your Go code should be simple for those using, reading, and maintaining it.\nGo code should be written in the simplest way that accomplishes its goals, both\nin terms of behavior and performance. Within the Google Go codebase, simple\ncode:\nIs easy to read from top to bottom \nDoes not assume that you already know what it is doing \nDoes not assume that you can memorize all of the preceding code \nDoes not have unnecessary levels of abstraction \nDoes not have names that call attention to something mundane \nMakes the propagation of values and decisions clear to the reader \nHas comments that explain why, not what, the code is doing to avoid future\ndeviation \nHas documentation that stands on its own \nHas useful errors and useful test failures \nMay often be mutually exclusive with “clever” code\nTradeoffs can arise between code simplicity and API usage simplicity. For\nexample, it may be worthwhile to have the code be more complex so that the end\nuser of the API may more easily call the API correctly. In contrast, it may also\nbe worthwhile to leave a bit of extra work to the end user of the API so that\nthe code remains simple and easy to understand.\nWhen code needs complexity, the complexity should be added deliberately. This is\ntypically necessary if additional performance is required or where there are\nmultiple disparate customers of a particular library or service. Complexity may\nbe justified, but it should come with accompanying documentation so that clients\nand future maintainers are able to understand and navigate the complexity. This\nshould be supplemented with tests and examples that demonstrate its correct\nusage, especially if there is both a “simple” and a “complex” way to use the\ncode.\nThis principle does not imply that complex code cannot or should not be written\nin Go or that Go code is not allowed to be complex. We strive for a codebase\nthat avoids unnecessary complexity so that when complexity does appear, it\nindicates that the code in question requires care to understand and maintain.\nIdeally, there should be accompanying commentary that explains the rationale and\nidentifies the care that should be taken. This often arises when optimizing code\nfor performance; doing so often requires a more complex approach, like\npreallocating a buffer and reusing it throughout a goroutine lifetime. When a\nmaintainer sees this, it should be a clue that the code in question is\nperformance-critical, and that should influence the care that is taken when\nmaking future changes. If employed unnecessarily, on the other hand, this\ncomplexity is a burden on those who need to read or change the code in the\nfuture.\nIf code turns out to be very complex when its purpose should be simple, this is\noften a signal to revisit the implementation to see if there is a simpler way to\naccomplish the same thing."
            }
        ]
    },
    {
        "title": "Least mechanism",
        "belongs to": "Style principles/Clarity/Simplicity/Least mechanism",
        "cases": [
            {
                "description": "Where there are several ways to express the same idea, prefer the one that uses\nthe most standard tools. Sophisticated machinery often exists, but should not be\nemployed without reason. It is easy to add complexity to code as needed, whereas\nit is much harder to remove existing complexity after it has been found to be\nunnecessary.\nAim to use a core language construct (for example a channel, slice, map,\nloop, or struct) when sufficient for your use case. \nIf there isn’t one, look for a tool within the standard library (like an\nHTTP client or a template engine). \nFinally, consider whether there is a core library in the Google codebase\nthat is sufficient before introducing a new dependency or creating your own.\nAs an example, consider production code that contains a flag bound to a variable\nwith a default value which must be overridden in tests. Unless intending to test\nthe program’s command-line interface itself (say, with `os/exec`), it is simpler\nand therefore preferable to override the bound value directly rather than by\nusing `flag.Set`.\nSimilarly, if a piece of code requires a set membership check, a boolean-valued\nmap (e.g., `map[string]bool`) often suffices. Libraries that provide set-like\ntypes and functionality should only be used if more complicated operations are\nrequired that are impossible or overly complicated with a map."
            }
        ]
    },
    {
        "title": "Concision",
        "belongs to": "Style principles/Clarity/Simplicity/Concision",
        "cases": [
            {
                "description": "Concise Go code has a high signal-to-noise ratio. It is easy to discern the\nrelevant details, and the naming and structure guide the reader through these\ndetails.\nThere are many things that can get in the way of surfacing the most salient\ndetails at any given time:\nRepetitive code \nExtraneous syntax \n\nOpaque names \n\nUnnecessary abstraction \nWhitespace\nRepetitive code especially obscures the differences between each\nnearly-identical section, and requires a reader to visually compare similar\nlines of code to find the changes. Table-driven testing is a good example of a\nmechanism that can concisely factor out the common code from the important\ndetails of each repetition, but the choice of which pieces to include in the\ntable will have an impact on how easy the table is to understand.\nWhen considering multiple ways to structure code, it is worth considering which\nway makes important details the most apparent.\nUnderstanding and using common code constructions and idioms are also important\nfor maintaining a high signal-to-noise ratio. For example, the following code\nblock is very common in error handling , and the reader can quickly understand\nthe purpose of this block.",
                "example": "// Good:\nif err := doSomething(); err != nil {\n    // ...\n}\n"
            },
            {
                "description": "If code looks very similar to this but is subtly different, a reader may not\nnotice the change. In cases like this, it is worth intentionally “boosting” the signal of the error check by adding a comment to call attention to it.",
                "example": "// Good:\nif err := doSomething(); err == nil { // if NO error\n    // ...\n}\n"
            }
        ]
    },
    {
        "title": "Maintainability",
        "belongs to": "Style principles/Clarity/Simplicity/Maintainability",
        "cases": [
            {
                "description": "Code is edited many more times than it is written. Readable code not only makes\nsense to a reader who is trying to understand how it works, but also to the\nprogrammer who needs to change it. Clarity is key.\nMaintainable code:\nIs easy for a future programmer to modify correctly \nHas APIs that are structured so that they can grow gracefully \nIs clear about the assumptions that it makes and chooses abstractions that\nmap to the structure of the problem, not to the structure of the code \nAvoids unnecessary coupling and doesn’t include features that are not used \nHas a comprehensive test suite to ensure promised behaviors are maintained\nand important logic is correct, and the tests provide clear, actionable\ndiagnostics in case of failure\nWhen using abstractions like interfaces and types which by definition remove\ninformation from the context in which they are used, it is important to ensure\nthat they provide sufficient benefit. Editors and IDEs can connect directly to a\nmethod definition and show the corresponding documentation when a concrete type\nis used, but can only refer to an interface definition otherwise. Interfaces are\na powerful tool, but come with a cost, since the maintainer may need to\nunderstand the specifics of the underlying implementation in order to correctly\nuse the interface, which must be explained within the interface documentation or\nat the call-site.\nMaintainable code also avoids hiding important details in places that are easy\nto overlook. For example, in each of the following lines of code, the presence\nor lack of a single character is critical to understand the line:",
                "example": "// Bad:\n// The use of = instead of := can change this line completely.\nif user, err = db.UserByID(userID); err != nil {\n    // ...\n}\n\n// Bad:\n// The ! in the middle of this line is very easy to miss.\nleap := (year%4 == 0) && (!(year%100 == 0) || (year%400 == 0))\n"
            },
            {
                "description": "Neither of these are incorrect, but both could be written in a more explicit\nfashion, or could have an accompanying comment that calls attention to the\nimportant behavior:",
                "example": "// Good:\nu, err := db.UserByID(userID)\nif err != nil {\n    return fmt.Errorf(\"invalid origin user: %s\", err)\n}\nuser = u\n\n// Good:\n// Gregorian leap years aren't just year%4 == 0.\n// See https://en.wikipedia.org/wiki/Leap_year#Algorithm.\nvar (\n    leap4   = year%4 == 0\n    leap100 = year%100 == 0\n    leap400 = year%400 == 0\n)\nleap := leap4 && (!leap100 || leap400)\n"
            },
            {
                "description": "In the same way, a helper function that hides critical logic or an important\nedge-case could make it easy for a future change to fail to account for it\nproperly.\nPredictable names are another feature of maintainable code. A user of a package\nor a maintainer of a piece of code should be able to predict the name of a\nvariable, method, or function in a given context. Function parameters and\nreceiver names for identical concepts should typically share the same name, both\nto keep documentation understandable and to facilitate refactoring code with\nminimal overhead.\nMaintainable code minimizes its dependencies (both implicit and explicit).\nDepending on fewer packages means fewer lines of code that can affect behavior.\nAvoiding dependencies on internal or undocumented behavior makes code less\nlikely to impose a maintenance burden when those behaviors change in the future.\nWhen considering how to structure or write code, it is worth taking the time to\nthink through ways in which the code may evolve over time. If a given approach\nis more conducive to easier and safer future changes, that is often a good\ntrade-off, even if it means a slightly more complicated design."
            }
        ]
    },
    {
        "title": "Consistency",
        "belongs to": "Style principles/Clarity/Simplicity/Consistency",
        "cases": [
            {
                "description": "Consistent code is code that looks, feels, and behaves like similar code\nthroughout the broader codebase, within the context of a team or package, and\neven within a single file.\nConsistency concerns do not override any of the principles above, but if a tie\nmust be broken, it is often beneficial to break it in favor of consistency.\nConsistency within a package is often the most immediately important level of\nconsistency. It can be very jarring if the same problem is approached in\nmultiple ways throughout a package, or if the same concept has many names within\na file. However, even this should not override documented style principles or\nglobal consistency."
            }
        ]
    },
    {
        "title": "Core guidelines",
        "belongs to": "Core guidelines",
        "cases": [
            {
                "description": "These guidelines collect the most important aspects of Go style that all Go code\nis expected to follow. We expect that these principles be learned and followed\nby the time readability is granted. These are not expected to change frequently,\nand new additions will have to clear a high bar.\nThe guidelines below expand on the recommendations in Effective Go , which\nprovide a common baseline for Go code across the entire community."
            }
        ]
    },
    {
        "title": "Formatting",
        "belongs to": "Core guidelines/Formatting",
        "cases": [
            {
                "description": "All Go source files must conform to the format outputted by the `gofmt`tool.\nThis format is enforced by a presubmit check in the Google codebase. Generated code should generally also be formatted (e.g., by using \n`format.Source`\n), as it is also browsable in Code Search."
            }
        ]
    },
    {
        "title": "MixedCaps",
        "belongs to": "Core guidelines/MixedCaps",
        "cases": [
            {
                "description": "Go source code uses `MixedCaps`or `mixedCaps`(camel case) rather than\nunderscores (snake case) when writing multi-word names.\nThis applies even when it breaks conventions in other languages. For example, a\nconstant is `MaxLength`(not `MAX_LENGTH`) if exported and `maxLength`(not `max_length`) if unexported.\nLocal variables are considered unexported for the purpose of choosing the\ninitial capitalization."
            }
        ]
    },
    {
        "title": "Line length",
        "belongs to": "Core guidelines/Line length",
        "cases": [
            {
                "description": "There is no fixed line length for Go source code. If a line feels too long,\nprefer refactoring instead of splitting it. If it is already as short as it is\npractical for it to be, the line should be allowed to remain long.\nDo not split a line:\nBefore an indentation change (e.g.,\nfunction declaration, conditional) \nTo make a long string (e.g., a URL) fit into multiple shorter lines"
            }
        ]
    },
    {
        "title": "Naming",
        "belongs to": "Core guidelines/Naming",
        "cases": [
            {
                "description": "Naming is more art than science. In Go, names tend to be somewhat shorter than\nin many other languages, but the same general guidelines apply. Names should:\nNot feel repetitive when they are used \nTake the context into consideration \nNot repeat concepts that are already clear\nYou can find more specific guidance on naming in decisions ."
            }
        ]
    },
    {
        "title": "Local consistency",
        "belongs to": "Core guidelines/Local consistency",
        "cases": [
            {
                "description": "Where the style guide has nothing to say about a particular point of style,\nauthors are free to choose the style that they prefer, unless the code in close\nproximity (usually within the same file or package, but sometimes within a team\nor project directory) has taken a consistent stance on the issue.\nExamples of valid local style considerations:\nUse of `%s`or `%v`for formatted printing of errors \nUsage of buffered channels in lieu of mutexes\nExamples of invalid local style considerations:\nLine length restrictions for code \nUse of assertion-based testing libraries\nIf the local style disagrees with the style guide but the readability impact is\nlimited to one file, it will generally be surfaced in a code review for which a\nconsistent fix would be outside the scope of the CL in question. At that point,\nit is appropriate to file a bug to track the fix.\nIf a change would worsen an existing style deviation, expose it in more API\nsurfaces, expand the number of files in which the deviation is present, or\nintroduce an actual bug, then local consistency is no longer a valid\njustification for violating the style guide for new code. In these cases, it is\nappropriate for the author to clean up the existing codebase in the same CL,\nperform a refactor in advance of the current CL, or find an alternative that at\nleast does not make the local problem worse.\nThis site is open source. Improve this page ."
            }
        ]
    }
]