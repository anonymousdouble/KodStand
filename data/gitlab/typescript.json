[
    {
        "title": "History with GitLab",
        "belongs to": "History with GitLab",
        "cases": [
            {
                "description": "TypeScript has been considered , discussed, promoted, and rejected for years at GitLab. The general conclusion is that we are unable to integrate TypeScript into the main project because the costs outweigh the benefits.\nThe main project has a lot of pre-existing code that is not strongly typed. \nThe main contributors to the main project are not all familiar with TypeScript.\nApart from the main project, TypeScript has been profitably employed in a handful of satellite projects."
            }
        ]
    },
    {
        "title": "Projects using TypeScript",
        "belongs to": "Projects using TypeScript",
        "cases": [
            {
                "description": "The following GitLab projects use TypeScript:\ngitlab-web-ide \ngitlab-vscode-extension \ngitlab-language-server-for-code-suggestions \ngitlab-org/cluster-integration/javascript-client"
            }
        ]
    },
    {
        "title": "Recommendations",
        "belongs to": "Recommendations",
        "cases": []
    },
    {
        "title": "Setup ESLint and TypeScript configuration",
        "belongs to": "Recommendations/Setup ESLint and TypeScript configuration",
        "cases": [
            {
                "description": "When setting up a new TypeScript project, configure strict type-safety rules for ESLint and TypeScript. This ensures that the project remains as type-safe as possible.\nThe GitLab Workflow Extension project is a good model for a TypeScript project’s boilerplate and configuration. Consider copying the `tsconfig.json` and `.eslintrc.json` from there.\nFor `tsconfig.json` :\nUse \"strict\": true . This enforces the strongest type-checking capabilities in the project and prohibits overriding type-safety. \nUse \"skipLibCheck\": true . This improves compile time by only checking references `.d.ts` files as opposed to all `.d.ts` files in `node_modules` .\nFor `.eslintrc.json` (or `.eslintrc.js` ):\nMake sure that TypeScript-specific parsing and linting are placed in an `overrides` for `**/*.ts` files. This way, linting regular `.js` files remains unaffected by the TypeScript-specific rules. \nExtend from plugin:@typescript-eslint/recommended which has some very sensible defaults, such as: \n\"@typescript-eslint/no-explicit-any\": \"error\" \n\"@typescript-eslint/no-unsafe-assignment\": \"error\" \n\"@typescript-eslint/no-unsafe-return\": \"error\""
            }
        ]
    },
    {
        "title": "Avoid any",
        "belongs to": "Recommendations/Avoid any",
        "cases": [
            {
                "description": "Avoid `any` at all costs. This should already be configured in the project’s linter, but it’s worth calling out here.\nDevelopers commonly resort to `any` when dealing with data structures that cross domain boundaries, such as handling HTTP responses or interacting with untyped libraries. This appears convenient at first. However, opting for a well-defined type (or using `unknown` and employing type narrowing through predicates) carries substantial benefits.",
                "example": "// Bad :(\nfunction handleMessage(data: any) {\n  console.log(\"We don't know what data is. This could blow up!\", data.special.stuff);\n}\n\n// Good :)\nfunction handleMessage(data: unknown) {\n  console.log(\"Sometimes it's okay that it remains unknown.\", JSON.stringify(data));\n}\n\n// Also good :)\nfunction isFooMessage(data: unknown): data is { foo: string } {\n  return typeof data === 'object' && data && 'foo' in data;\n}\n\nfunction handleMessage(data: unknown) {\n  if (isFooMessage(data)) {\n    console.log(\"We know it's a foo now. This is safe!\", data.foo);\n  }\n}\n"
            }
        ]
    },
    {
        "title": "Avoid casting with <> or as",
        "belongs to": "Recommendations/Avoid casting with <> or as",
        "cases": [
            {
                "description": "Avoid casting with `<>` or `as` as much as possible.\nType casting explicitly circumvents type-safety. Consider using type predicates .",
                "example": "// Bad :(\nfunction handler(data: unknown) {\n  console.log((data as StuffContainer).stuff);\n}\n\n// Good :)\nfunction hasStuff(data: unknown): data is StuffContainer {\n  if (data && typeof data === 'object') {\n    return 'stuff' in data;\n  }\n\n  return false;\n}\n\nfunction handler(data: unknown) {\n  if (hasStuff(data)) {\n    // No casting needed :)\n    console.log(data.stuff);\n  }\n  throw new Error('Expected data to have stuff. Catastrophic consequences might follow...');\n}\n\n",
                "appendix": "There’s some rare cases this might be acceptable (consider this test utility ). However, 99% of the time, there’s a better way."
            }
        ]
    },
    {
        "title": "Prefer interface over type for new structures",
        "belongs to": "Recommendations/Prefer interface over type for new structures",
        "cases": [
            {
                "description": "Prefer declaring a new `interface` over declaring a new `type` alias when defining new structures.\nInterfaces and type aliases have a lot of cross-over, but only interfaces can be used with the `implements` keyword. A class is not able to `implement` a `type` (only an `interface` ), so using `type` would restrict the usability of the structure.",
                "example": "// Bad :(\ntype Fooer = {\n  foo: () => string;\n}\n\n// Good :)\ninterface Fooer {\n  foo: () => string;\n}\n",
                "appendix": "From the TypeScript guide :\nIf you would like a heuristic, use `interface` until you need to use features from `type` ."
            }
        ]
    },
    {
        "title": "Use type to define aliases for existing types",
        "belongs to": "Recommendations/Use type to define aliases for existing types",
        "cases": [
            {
                "description": "Use type to define aliases for existing types, classes or interfaces. Use the TypeScript Utility Types to provide transformations.",
                "example": "interface Config = {\n  foo: string;\n\n  isBad: boolean;\n}\n\n// Bad :(\ntype PartialConfig = {\n  foo?: string;\n\n  isBad?: boolean;\n}\n\n// Good :)\ntype PartialConfig = Partial<Config>;\n"
            }
        ]
    },
    {
        "title": "Use union types to improve inference",
        "belongs to": "Recommendations/Use union types to improve inference",
        "cases": [
            {
                "example": "// Bad :(\ninterface Foo { type: string }\ninterface FooBar extends Foo { bar: string }\ninterface FooZed extends Foo { zed: string }\n\nconst doThing = (foo: Foo) => {\n  if (foo.type === 'bar') {\n    // Casting bad :(\n    console.log((foo as FooBar).bar);\n  }\n}\n\n// Good :)\ninterface FooBar { type: 'bar', bar: string }\ninterface FooZed { type: 'zed', zed: string }\ntype Foo = FooBar | FooZed;\n\nconst doThing = (foo: Foo) => {\n  if (foo.type === 'bar') {\n    // No casting needed :) - TS knows we are FooBar now\n    console.log(foo.bar);\n  }\n}\n"
            }
        ]
    },
    {
        "title": "Future plans",
        "belongs to": "Future plans",
        "cases": [
            {
                "description": "Shared ESLint configuration to reuse across TypeScript projects."
            }
        ]
    },
    {
        "title": "Related topics",
        "belongs to": "Related topics",
        "cases": [
            {
                "description": "TypeScript Handbook \nTypeScript notes in GitLab Workflow Extension"
            }
        ]
    },
    {
        "title": "Privacy Preference Center",
        "belongs to": "Privacy Preference Center",
        "cases": []
    }
]