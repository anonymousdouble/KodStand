Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
3.3.3 Ordering and spacing
Imports are ordered as follows:
 All static imports in a single block. 
 All non-static imports in a single block.
 If there are both static and non-static imports, a single blank line separates the two blocks. There are no other blank lines between import statements.
 Within each block the imported names appear in ASCII sort order. ( Note: this is not the same as the import statements being in ASCII sort order, since '.' sorts before ';'.)

CheckStyle Rules:
[Rule]
ImportOrder
[Description]
Checks the ordering/grouping of imports. Features are:

groups type/static imports: ensures that groups of imports come in a
specific order (e.g., java. comes first, javax. comes second,
then everything else)
adds a separation between type import groups : ensures that a blank
line sit between each group
type/static import groups aren't separated internally: ensures that
each group aren't separated internally by blank line or comment
sorts type/static imports inside each group: ensures that imports
within each group are in lexicographic order

sorts according to case: ensures that the comparison
between imports is case-sensitive, in
ASCII sort order


arrange static imports: ensures the relative order between
type imports and static imports (see
ImportOrderOption)
[Rule]
RedundantImport
[Description]
Checks for redundant import statements. An import statement is
considered redundant if:



It is a duplicate of another import. This is, when a class is
imported more than once.


The class non-statically imported is from the java.lang
package, e.g. importing java.lang.String.


The class non-statically imported is from the same package as the current package.
[Rule]
AvoidStaticImport
[Description]
Checks that there are no static import statements.


Rationale: Importing static members can lead to naming
conflicts between class' members. It may lead to poor code
readability since it may no longer be clear what class a
member resides in (without looking at the import statement).
[Rule]
UnusedImports
[Description]
Checks for unused import statements. An
import statement is considered unused if:



It is not referenced in the file. The algorithm does not support
wild-card imports like import
java.io.*;. Most IDE's provide very sophisticated checks
for imports that handle wild-card imports.


The class imported is from the java.lang
package. For example importing java.lang.String.


The class imported is from the same package.


A static method is imported when used as method reference. In that case,
only the type needs to be imported and that's enough to resolve the method.


Optionally: it is referenced in Javadoc comments. This check
is on by default, but it is considered bad practice to introduce
a compile-time dependency for documentation purposes only.
As an example, the import java.util.List would be
considered referenced with the Javadoc comment
{@link List}. The alternative to avoid introducing a
compile-time dependency would be to write the Javadoc comment as
{@link java.util.List}.



The main limitation of this check is handling the cases where:



An imported type has the same name as a declaration, such as a member variable.


There are two or more static imports with the same method name
(javac can distinguish imports with same name but different parameters, but checkstyle
can not due to
limitation.)
[Rule]
DeclarationOrder
[Description]
Checks that the parts of a class, record, or interface declaration appear in the order
suggested by the

Code Conventions for the Java Programming Language.


According to

Code Conventions for the Java Programming Language , the parts
of a class or interface declaration should appear in the following
order:



Class (static) variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.


Instance variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.

Constructors
Methods


Purpose of ignore* option is to ignore related violations,
however it still impacts on other class members.


ATTENTION: the check skips class fields which have

forward references
from validation due to the fact that we have Checkstyle's limitations to clearly
detect user intention of fields location and grouping. For example:



public class A {
private double x = 1.0;
private double y = 2.0;
public double slope = x / y; // will be skipped from validation due to forward reference
}
[Rule]
CustomImportOrder
[Description]
Checks that the groups of import declarations appear in the order specified
by the user. If there is an import but its group is not specified in the
configuration such an import should be placed at the end of the import list.
[Rule]
EmptyLineSeparator
[Description]
Checks for empty line separators before package, all import declarations,
fields, constructors, methods, nested classes,
static initializers and instance initializers.


Checks for empty line separators before not only statements but
implementation and documentation comments and blocks as well.


ATTENTION: empty line separator is required between token siblings,
not after line where token is found.
If token does not have a sibling of the same type, then empty line
is required at its end (for example for CLASS_DEF it is after '}').
Also, trailing comments are skipped.
[Rule]
ModifierOrder
[Description]
Checks that the order of modifiers conforms to the suggestions in
the Java
Language specification, ¡ì 8.1.1, 8.3.1, 8.4.3 and

9.4. The correct order is:



public


protected


private


abstract


default


static


sealed


non-sealed


final


transient


volatile


synchronized


native


strictfp



In additional, modifiers are checked to ensure all annotations are
declared before all other modifiers.


Rationale: Code is easier to read if everybody follows a standard.


ATTENTION: We skip

type annotations from validation.
[Rule]
OneStatementPerLine
[Description]
Checks that there is only one statement per line.


Rationale: It's very difficult to read multiple statements on one line.


In the Java programming language, statements are the fundamental unit of
execution. All statements except blocks are terminated by a semicolon.
Blocks are denoted by open and close curly braces.


OneStatementPerLineCheck checks the following types of statements:
variable declaration statements, empty statements, import statements,
assignment statements, expression statements, increment statements,
object creation statements, 'for loop' statements, 'break' statements,
'continue' statements, 'return' statements, resources statements (optional).
[Rule]
AvoidStarImport
[Description]
Checks that there are no import statements that use the * notation.


Rationale: Importing all classes from a package or static
members from a class leads to tight coupling between packages
or classes and might lead to problems when a new version of a
library introduces name clashes.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
