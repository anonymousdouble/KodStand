{
    "PackageDeclaration": "Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\n1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. \n2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.\n3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nPackageDeclaration\nDescription\n\nEnsures that a class has a package declaration, and (optionally) whether\nthe package name matches the directory name for the source file.\n\n\nRationale: Classes that live in the null package cannot be\nimported. Many novice developers are not aware of this.\n\n\nPackages provide logical namespace to classes and should be stored in\nthe form of directory levels to provide physical grouping to your classes.\nThese directories are added to the classpath so that your classes\nare visible to JVM when it runs the code.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nmatchDirectoryStructure\nControl whether to check for directory and package name match.\nboolean\ntrue\n7.6.1\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means if Rule1 then Rule2\nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\nCheckStyle Rule:\nRulename:\nNeedBraces\n\nDescription\nChecks for braces around code blocks.\n\nOptions:\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n\nFinal RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n",
    "VisibilityModifier": "Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\n1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. \n2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.\n3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nVisibilityModifier\nDescription\n\nChecks visibility of class members. Only static final, immutable or annotated\nby specified annotation members may be public; other class members must be private\nunless the property protectedAllowed or packageAllowed is set.\n\n\nPublic members are not flagged if the name matches the public\nmember regular expression (contains \"^serialVersionUID$\" by default).\n\nNote that\nCheckstyle 2 used to include \"^f[A-Z][a-zA-Z0-9]*$\" in the default\npattern to allow names used in container-managed persistence for Enterprise JavaBeans\n(EJB) 1.1 with the default settings. With EJB 2.0 it is no longer necessary to have\npublic access for persistent fields, so the default has been changed.\n\n\nRationale: Enforce encapsulation.\n\n\nCheck also has options making it less strict:\n\n\nignoreAnnotationCanonicalNames - the list of annotations which ignore variables\nin consideration. If user want to provide short annotation name that type\nwill match to any named the same type without consideration of package.\n\n\nallowPublicFinalFields - which allows public final fields.\n\n\nallowPublicImmutableFields - which allows immutable fields to be declared as\npublic if defined in final class.\n\n\nField is known to be immutable if:\n\n\nIt's declared as final\n\nHas either a primitive type or instance of class user defined to be immutable\n(such as String, ImmutableCollection from Guava, etc.)\n\n\n\nClasses known to be immutable are listed in immutableClassCanonicalNames by their\ncanonical names.\n\n\nProperty Rationale: Forcing all fields of class to have private modifier by default is\ngood in most cases, but in some cases it drawbacks in too much boilerplate get/set code.\nOne of such cases are immutable classes.\n\n\nRestriction: Check doesn't check if class is immutable, there's no\nchecking if accessory methods are missing and all fields are immutable, we only check\nif current field is immutable or final. Under the flag\nallowPublicImmutableFields, the enclosing class must also be final, to encourage\nimmutability. Under the flag allowPublicFinalFields, the final modifier on\nthe enclosing class is optional.\n\n\nStar imports are out of scope of this Check. So if one of type imported via\nstar import collides with user specified one by its short name -\nthere won't be Check's violation.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nallowPublicFinalFields\nAllow final fields to be declared as public.\nboolean\nfalse\n7.0\n\n\nallowPublicImmutableFields\nAllow immutable fields to be declared as public if defined in final class.\nboolean\nfalse\n6.4\n\n\nignoreAnnotationCanonicalNames\nSpecify annotations canonical names which ignore variables in consideration.\nString[]\ncom.google.common.annotations.VisibleForTesting, org.junit.ClassRule, org.junit.Rule\n6.5\n\n\nimmutableClassCanonicalNames\nSpecify immutable classes canonical names.\nString[]\njava.io.File, java.lang.Boolean, java.lang.Byte, java.lang.Character, java.lang.Double, java.lang.Float, java.lang.Integer, java.lang.Long, java.lang.Short, java.lang.StackTraceElement, java.lang.String, java.math.BigDecimal, java.math.BigInteger, java.net.Inet4Address, java.net.Inet6Address, java.net.InetSocketAddress, java.net.URI, java.net.URL, java.util.Locale, java.util.UUID\n6.4.1\n\n\npackageAllowed\nControl whether package visible members are allowed.\nboolean\nfalse\n3.0\n\n\nprotectedAllowed\nControl whether protected members are allowed.\nboolean\nfalse\n3.0\n\n\npublicMemberPattern\nSpecify pattern for public members that should be ignored.\nPattern\n\"^serialVersionUID$\"\n3.0\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means if Rule1 then Rule2\nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\nCheckStyle Rule:\nRulename:\nNeedBraces\n\nDescription\nChecks for braces around code blocks.\n\nOptions:\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n\nFinal RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n",
    "Indentation": "Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\n1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. \n2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.\n3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nIndentation\nDescription\n\nChecks correct indentation of Java code.\n\n\nThe idea behind this is that while pretty printers are\nsometimes convenient for bulk reformats of legacy code, they often\neither aren't configurable enough or just can't anticipate how\nformat should be done. Sometimes this is personal preference, other\ntimes it is practical experience. In any case, this check should\njust ensure that a minimal set of indentation rules is followed.\n\n\nBasic offset indentation is used for indentation inside code blocks.\nFor any lines that span more than 1, line wrapping indentation is used for those\nlines after the first.\nBrace adjustment, case, and throws indentations are all used only if those specific\nidentifiers start the line. If, for example, a brace is used in the middle of the line,\nits indentation will not take effect.\nAll indentations have an accumulative/recursive effect when they are triggered. If\nduring a line wrapping, another code block is found and it doesn't end on that same\nline, then the subsequent lines afterwards, in that new code block, are increased on\ntop of the line wrap and any indentations above it.\n\nExample:\n\n\nif ((condition1 && condition2)\n|| (condition3 && condition4)    // line wrap with bigger indentation\n||!(condition5 && condition6)) { // line wrap with bigger indentation\nfield.doSomething()                    // basic offset\n.doSomething()                     // line wrap\n.doSomething( c -> {               // line wrap\nreturn c.doSome();               // basic offset\n});\n}\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\narrayInitIndent\nSpecify how far an array initialization should be indented when on next line.\nint\n4\n5.8\n\n\nbasicOffset\nSpecify how far new indentation level should be indented when on the next line.\nint\n4\n3.1\n\n\nbraceAdjustment\nSpecify how far a braces should be indented when on the next line.\nint\n0\n3.1\n\n\ncaseIndent\nSpecify how far a case label should be indented when on next line.\nint\n4\n3.1\n\n\nforceStrictCondition\nForce strict indent level in line wrapping case. If value is true, line wrap indent have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like.\nboolean\nfalse\n6.3\n\n\nlineWrappingIndentation\nSpecify how far continuation line should be indented when line-wrapping is present.\nint\n4\n5.9\n\n\nthrowsIndent\nSpecify how far a throws clause should be indented when on next line.\nint\n4\n5.7\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means if Rule1 then Rule2\nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\nCheckStyle Rule:\nRulename:\nNeedBraces\n\nDescription\nChecks for braces around code blocks.\n\nOptions:\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n\nFinal RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n",
    "OneTopLevelClass": "Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\n1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. \n2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.\n3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nOneTopLevelClass\nDescription\n\nChecks that each top-level class, interface, enum\nor annotation resides in a source file of its own.\nOfficial description of a 'top-level' term:\n7.6. Top Level Type Declarations.\nIf file doesn't contain public class, interface, enum or annotation,\ntop-level type is the first type in file.\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means if Rule1 then Rule2\nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\nCheckStyle Rule:\nRulename:\nNeedBraces\n\nDescription\nChecks for braces around code blocks.\n\nOptions:\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n\nFinal RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n",
    "MissingDeprecated": "Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\n1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. \n2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.\n3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nMissingDeprecated\nDescription\n\nVerifies that the annotation @Deprecated and the Javadoc tag\n@deprecated are both present when either of them is present.\n\n\nBoth ways of flagging deprecation serve their own purpose.\nThe @Deprecated annotation is used for compilers and development tools.\nThe @deprecated javadoc tag is used to document why something is deprecated\nand what, if any, alternatives exist.\n\n\nIn order to properly mark something as deprecated both forms of\ndeprecation should be present.\n\n\nPackage deprecation is an exception to the rule of always using the\njavadoc tag and annotation to deprecate.  It is not clear if the\njavadoc tool will support it or not as newer versions keep flip-flopping\non if it is supported or will cause an error.\nSee\nJDK-8160601.\nThe deprecated javadoc tag is currently the only way to say why the package\nis deprecated and what to use instead.  Until this is resolved, if you\ndon't want to print violations on package-info, you can use a\nfilter to ignore these files until\nthe javadoc tool faithfully supports it. An example config using\nSuppressionSingleFilter is:\n\n\n\n<!-- required till https://bugs.openjdk.org/browse/JDK-8160601 -->\n<module name=\"SuppressionSingleFilter\">\n<property name=\"checks\" value=\"MissingDeprecatedCheck\"/>\n<property name=\"files\" value=\"package-info\\.java\"/>\n</module>\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nviolateExecutionOnNonTightHtml\nControl when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules.\nboolean\nfalse\n8.24\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means if Rule1 then Rule2\nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\nCheckStyle Rule:\nRulename:\nNeedBraces\n\nDescription\nChecks for braces around code blocks.\n\nOptions:\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n\nFinal RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n",
    "JavadocVariable": "Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\n1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. \n2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.\n3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nJavadocVariable\nDescription\n\nChecks that a variable has a Javadoc comment. Ignores serialVersionUID\nfields.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nexcludeScope\nSpecify the visibility scope where Javadoc comments are not checked.\nScope\nnull\n3.4\n\n\nignoreNamePattern\nSpecify the regexp to define variable names to ignore.\nPattern\nnull\n5.8\n\n\nscope\nSpecify the visibility scope where Javadoc comments are checked.\nScope\nprivate\n3.0\n\n\ntokens\ntokens to check\nsubset of tokens\n\nENUM_CONSTANT_DEF\n.\n\n\n\nENUM_CONSTANT_DEF\n.\n\n3.0\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means if Rule1 then Rule2\nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\nCheckStyle Rule:\nRulename:\nNeedBraces\n\nDescription\nChecks for braces around code blocks.\n\nOptions:\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n\nFinal RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n",
    "NoEnumTrailingComma": "Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\n1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. \n2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.\n3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nNoEnumTrailingComma\nDescription\n\nChecks that enum definition does not contain a trailing comma.\nRationale: JLS allows trailing commas in arrays and enumerations, but does not allow\nthem in other locations. To unify the coding style, the use of trailing commas should\nbe prohibited.\n\n\n\nenum Foo1 {\nFOO,\nBAR;\n}\n\n\nThe check demands that there should not be any comma after last constant in\nenum definition.\n\n\n\nenum Foo1 {\nFOO,\nBAR, //violation\n}\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means if Rule1 then Rule2\nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\nCheckStyle Rule:\nRulename:\nNeedBraces\n\nDescription\nChecks for braces around code blocks.\n\nOptions:\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n\nFinal RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n",
    "UniqueProperties": "Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\n1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. \n2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.\n3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nUniqueProperties\nDescription\n\nDetects duplicated keys in properties files.\n\n\nRationale: Multiple property keys usually appear after merge\nor rebase of several branches. While there are no problems in\nruntime, there can be a confusion due to having different values\nfor the duplicated properties.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nfileExtensions\nSpecify the file extensions of the files to process.\nString[]\n.properties\n5.7\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means if Rule1 then Rule2\nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\nCheckStyle Rule:\nRulename:\nNeedBraces\n\nDescription\nChecks for braces around code blocks.\n\nOptions:\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n\nFinal RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n",
    "JavadocTagContinuationIndentation": "Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\n1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. \n2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.\n3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nJavadocTagContinuationIndentation\nDescription\n\nChecks the indentation of the continuation lines in block tags.\nThat is whether the\ncontinued description of at clauses should be indented or not. If the text is not properly\nindented it throws a violation. A continuation line is when the description starts/spans\npast the line with the tag. Default indentation required is at least 4, but this can be\nchanged with the help of properties below.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\noffset\nSpecify how many spaces to use for new indentation level.\nint\n4\n6.0\n\n\nviolateExecutionOnNonTightHtml\nControl when to print violations if the Javadoc being examined by this check violates the tight html rules defined at\nTight-HTML Rules.\nboolean\nfalse\n8.3\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means if Rule1 then Rule2\nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\nCheckStyle Rule:\nRulename:\nNeedBraces\n\nDescription\nChecks for braces around code blocks.\n\nOptions:\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n\nFinal RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n",
    "LambdaParameterName": "Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\n1. Analyze whether each sentence of Description of CheckStyle Rule is a rule and then classify it as mandatory or optional. If the rule is same as an option, do not need to parse it as a rule. If the rule is subjective, do not classify it as a rule. \n2. Analyze whether each option is a rule. If option is a configurable term, using {{OptionName}} to represent the term. If the option is to configure violation messages or reporting granularity, do not classify it as a rule. If the option is a rule, parse rule for each value of the option.\n3. When parsing a rule using the given Grammar, pay attention to map to suitable formal Java term and select appropriate real operator characters. \n\nCheckStyle Rule:\nRulename\nLambdaParameterName\nDescription\n\nChecks lambda parameter names.\nOptions\nProperties\n\n\n\nname\ndescription\ntype\ndefault value\nsince\n\n\nformat\nSets the pattern to match valid identifiers.\nPattern\n\"^[a-z][a-zA-Z0-9]*$\"\n8.11\n\nGrammar:\nRuleSet ::= Rule1 [And|Or|; Rule2]* # And means should satisfy Rule1 and Rule2. Or means can satisfy Rule1 or Rule2. ; means Rule1,Rule2 belongs to diffent groups\nRule ::= {{'Optional'| 'Mandatory'}} [ ['Order' of | 'Number' of] TermList [Operator TermList]* | Rule1 '->' Rule2] [ExceptionRule] #'Order' of  means order rule, 'Number' of means numberConstraint, Rule1 '->' Rule2 means if Rule1 then Rule2\nExceptionRule ::= 'Except ' TermList | Rule # means rules not applied to TermList | Rule # means rules not applied to TermList | Rule\nOperator = 'is'| 'is not' | '>=' | '<=' | '=' | '!=' | 'for' | 'not for' | 'before' | 'not before' | 'after' | 'not after' | 'between' | 'not between' | 'have' | 'not have' | 'Add' | 'Sub' | 'Mult' | MatMult | 'Div' | 'Mod' | 'Pow' | 'LShift' | 'RShift' | 'BitOr' | 'BitXor' | 'BitAnd' | 'FloorDiv'\nTermList ::= Term [, Term]*\nModifier ::= 'some' | 'each' | 'all' | 'except' | 'first' | 'last' | ...\nTerm :: = JavaTerm | Modifier* Term | Term of Term\nJavaTerm means the formal expression using such format [XXX] \"XXX\" represent a JavaTerm\n\n\nFor Example, Analyze the following CheckStyle Rule, please parse the CheckStyle Rule using the given Grammar to make its semantics clear and correct. CheckStyle Rule consists of Description and configurable Options. \n\nCheckStyle Rule:\nRulename:\nNeedBraces\n\nDescription\nChecks for braces around code blocks.\n\nOptions:\nallowEmptyLoopBody, Allow loops with empty bodies., boolean, false\nallowSingleLineStatement, Allow single-line statements without braces., boolean, false\ntokens, tokens to check, subset of tokens\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n,\nLITERAL_CASE\n,\nLITERAL_DEFAULT\n,\nLAMBDA\n.\n,\n\nLITERAL_DO\n,\nLITERAL_ELSE\n,\nLITERAL_FOR\n,\nLITERAL_IF\n,\nLITERAL_WHILE\n.\n\nFinal RuleSet Representation:\nBasic Rule:\n{{tokens}} has [Brace] \n\nOption Rule:\nallowEmptyLoopBody option:\nFalse: Mandatory: [body] of {{tokens}} is not [Null]\nTrue: Optional: [body] of {{tokens}} is [Null]\n\nallowSingleLineStatement option:\nFalse: Mandatory: Number of [statement] of [body] of [tokens] is 1 -> [tokens] has [Brace] \nTrue: Optional: Number of [statement] of [body] of [tokens] is 1 -> [tokens] not has [Brace]\n"
}