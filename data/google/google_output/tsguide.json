[
    {
        "title": "Introduction",
        "belongs to": "Introduction",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Terminology notes",
        "belongs to": "Introduction/Terminology notes",
        "cases": [
            {
                "description": "This Style Guide uses RFC 2119\nterminology when using the phrases must, must not, should, should not,\nand may. The terms prefer and avoid correspond to should and should\nnot, respectively. Imperative and declarative statements are prescriptive and\ncorrespond to must.",
                "example": []
            }
        ]
    },
    {
        "title": "Guide notes",
        "belongs to": "Introduction/Guide notes",
        "cases": [
            {
                "description": "All examples given are non-normative and serve only to illustrate the\nnormative language of the style guide. That is, while the examples are in Google\nStyle, they may not illustrate the only stylish way to represent the code.\nOptional formatting choices made in examples must not be enforced as rules.",
                "example": []
            }
        ]
    },
    {
        "title": "Source file basics",
        "belongs to": "Source file basics",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "File encoding: UTF-8",
        "belongs to": "Source file basics/File encoding: UTF-8",
        "cases": [
            {
                "description": "Source files are encoded in UTF-8.",
                "example": []
            }
        ]
    },
    {
        "title": "Whitespace characters",
        "belongs to": "Source file basics/File encoding: UTF-8/Whitespace characters",
        "cases": [
            {
                "description": "Aside from the line terminator sequence, the ASCII horizontal space character\n(0x20) is the only whitespace character that appears anywhere in a source file.\nThis implies that all other whitespace characters in string literals are\nescaped.",
                "example": []
            }
        ]
    },
    {
        "title": "Special escape sequences",
        "belongs to": "Source file basics/File encoding: UTF-8/Special escape sequences",
        "cases": [
            {
                "description": "For any character that has a special escape sequence (\\', \\\", \\\\, \\b,\n\\f, \\n, \\r, \\t, \\v), that sequence is used rather than the\ncorresponding numeric escape (e.g \\x0a, \\u000a, or \\u{a}). Legacy octal\nescapes are never used.",
                "example": []
            }
        ]
    },
    {
        "title": "Non-ASCII characters",
        "belongs to": "Source file basics/File encoding: UTF-8/Non-ASCII characters",
        "cases": [
            {
                "description": "For the remaining non-ASCII characters, use the actual Unicode character (e.g.\n∞). For non-printable characters, the equivalent hex or Unicode escapes (e.g.\n\\u221e) can be used along with an explanatory comment.",
                "example": [
                    "// Perfectly clear, even without a comment.\nconst units = 'μs';\n\n// Use escapes for non-printable characters.\nconst output = '\\ufeff' + content;  // byte order mark\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// Hard to read and prone to mistakes, even with the comment.\nconst units = '\\u03bcs'; // Greek letter mu, 's'\n\n// The reader has no idea what this is.\nconst output = '\\ufeff' + content;\n"
                ]
            },
            {
                "description": "\n",
                "example": []
            }
        ]
    },
    {
        "title": "Source file structure",
        "belongs to": "Source file structure",
        "cases": [
            {
                "description": "Files consist of the following, in order:\nCopyright information, if present\nJSDoc with @fileoverview, if present\nImports, if present\nThe file’s implementation\nExactly one blank line separates each section that is present.",
                "example": []
            }
        ]
    },
    {
        "title": "Copyright information",
        "belongs to": "Source file structure/Copyright information",
        "cases": [
            {
                "description": "If license or copyright information is necessary in a file, add it in a JSDoc at\nthe top of the file. \n",
                "example": []
            }
        ]
    },
    {
        "title": "@fileoverview JSDoc",
        "belongs to": "Source file structure/@fileoverview JSDoc",
        "cases": [
            {
                "description": "A file may have a top-level @fileoverview JSDoc. If present, it may provide a\ndescription of the file's content, its uses, or information about its\ndependencies. Wrapped lines are not indented.Example:",
                "example": [
                    "/**\n * @fileoverview Description of file. Lorem ipsum dolor sit amet, consectetur\n * adipiscing elit, sed do eiusmod tempor incididunt.\n */\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Imports",
        "belongs to": "Source file structure/Imports",
        "cases": [
            {
                "description": "There are four variants of import statements in ES6 and TypeScript:\n\n\n\nImport type\nExample\nUse for\n\n\n\n\nmodule[module_import]\n\nimport * as foo from\n'...';\nTypeScript imports\n\n\n\nnamed[destructuring_import]\n\nimport {SomeThing}\nfrom '...';\nTypeScript imports\n\n\n\ndefault\n\n\nimport SomeThing\nfrom '...';\n\nOnly for other\nexternal code that\nrequires them\n\n\nside-effect\n\n\n\n\nimport '...';\n\nOnly to import\nlibraries for their\nside-effects on load\n(such as custom\nelements)\n\n\n\n// Good: choose between two options as appropriate (see below).\nimport * as ng from '@angular/core';\nimport {Foo} from './foo';\n\n// Only when needed: default imports.\nimport Button from 'Button';\n\n// Sometimes needed to import libraries for their side effects:\nimport 'jasmine';\nimport '@polymer/paper-button';\n\n",
                "example": []
            }
        ]
    },
    {
        "title": "Import paths",
        "belongs to": "Source file structure/Imports/Import paths",
        "cases": [
            {
                "description": "TypeScript code must use paths to import other TypeScript code. Paths may be\nrelative, i.e. starting with . or ..,\n or rooted at the base directory, e.g.\nroot/path/to/file.Code should use relative imports (./foo) rather than absolute imports\npath/to/foo when referring to files within the same (logical) project as this\nallows to move the project around without introducing changes in these imports.Consider limiting the number of parent steps (../../../) as those can make\nmodule and path structures hard to understand.",
                "example": [
                    "import {Symbol1} from 'path/from/root';\nimport {Symbol2} from '../parent/file';\nimport {Symbol3} from './sibling';\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Namespace versus named imports",
        "belongs to": "Source file structure/Imports/Namespace versus named imports",
        "cases": [
            {
                "description": "Both namespace and named imports can be used.Prefer named imports for symbols used frequently in a file or for symbols that\nhave clear names, for example Jasmine's describe and it. Named imports can\nbe aliased to clearer names as needed with as.Prefer namespace imports when using many different symbols from large APIs. A\nnamespace import, despite using the * character, is not comparable to a\nwildcard import as seen in other languages. Instead, namespace imports give a\nname to all the exports of a module, and each exported symbol from the module\nbecomes a property on the module name. Namespace imports can aid readability for\nexported symbols that have common names like Model or Controller without the\nneed to declare aliases.",
                "example": [
                    "// Bad: overlong import statement of needlessly namespaced names.\nimport {Item as TableviewItem, Header as TableviewHeader, Row as TableviewRow,\n  Model as TableviewModel, Renderer as TableviewRenderer} from './tableview';\n\nlet item: TableviewItem|undefined;\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// Better: use the module for namespacing.\nimport * as tableview from './tableview';\n\nlet item: tableview.Item|undefined;\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "import * as testing from './testing';\n\n// Bad: The module name does not improve readability.\ntesting.describe('foo', () => {\n  testing.it('bar', () => {\n    testing.expect(null).toBeNull();\n    testing.expect(undefined).toBeUndefined();\n  });\n});\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// Better: give local names for these common functions.\nimport {describe, it, expect} from './testing';\n\ndescribe('foo', () => {\n  it('bar', () => {\n    expect(null).toBeNull();\n    expect(undefined).toBeUndefined();\n  });\n});\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Special case: Apps JSPB protos",
        "belongs to": "Source file structure/Imports/Namespace versus named imports/Special case: Apps JSPB protos",
        "cases": [
            {
                "description": "Apps JSPB protos must use named imports, even when it leads to long import\nlines.This rule exists to aid in build performance and dead code elimination since\noften .proto files contain many messages that are not all needed together.\nBy leveraging destructured imports the build system can create finer grained\ndependencies on Apps JSPB messages while preserving the ergonomics of path based\nimports.",
                "example": [
                    "// Good: import the exact set of symbols you need from the proto file.\nimport {Foo, Bar} from './foo.proto';\n\nfunction copyFooBar(foo: Foo, bar: Bar) {...}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Renaming imports",
        "belongs to": "Source file structure/Imports/Namespace versus named imports/Renaming imports",
        "cases": [
            {
                "description": "Code should fix name collisions by using a namespace import or renaming the\nexports themselves. Code may rename imports (import {SomeThing as\nSomeOtherThing}) if needed.Three examples where renaming can be helpful:\nIf it's necessary to avoid collisions with other imported symbols.\nIf the imported symbol name is generated.\nIf importing symbols whose names are unclear by themselves, renaming can\nimprove code clarity. For example, when using RxJS the from function might\nbe more readable when renamed to observableFrom.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Exports",
        "belongs to": "Source file structure/Imports/Namespace versus named imports/Exports",
        "cases": [
            {
                "description": "Use named exports in all code:",
                "example": [
                    "// Use named exports:\nexport class Foo { ... }\n"
                ]
            },
            {
                "description": "Do not use default exports. This ensures that all imports follow a uniform\npattern.",
                "example": [
                    "// Do not use default exports:\nexport default class Foo { ... } // BAD!\n"
                ]
            },
            {
                "description": "\nWhy?\nDefault exports provide no canonical name, which makes central maintenance\ndifficult with relatively little benefit to code owners, including potentially\ndecreased readability:\nimport Foo from './bar';  // Legal.\nimport Bar from './bar';  // Also legal.\n\nNamed exports have the benefit of erroring when import statements try to import\nsomething that hasn't been declared. In foo.ts:\nconst foo = 'blah';\nexport default foo;\n\nAnd in bar.ts:\nimport {fizz} from './foo';\n\nResults in error TS2614: Module '\"./foo\"' has no exported member 'fizz'. While\nbar.ts:\nimport fizz from './foo';\n\nResults in fizz === foo, which is probably unexpected and difficult to debug.\nAdditionally, default exports encourage people to put everything into one big\nobject to namespace it all together:\nexport default class Foo {\n  static SOME_CONSTANT = ...\n  static someHelpfulFunction() { ... }\n  ...\n}\n\nWith the above pattern, we have file scope, which can be used as a namespace. We\nalso have a perhaps needless second scope (the class Foo) that can be\nambiguously used as both a type and a value in other files.\nInstead, prefer use of file scope for namespacing, as well as named exports:\nexport const SOME_CONSTANT = ...\nexport function someHelpfulFunction()\nexport class Foo {\n  // only class stuff here\n}\n\n",
                "example": []
            }
        ]
    },
    {
        "title": "Export visibility",
        "belongs to": "Source file structure/Imports/Namespace versus named imports/Exports/Export visibility",
        "cases": [
            {
                "description": "TypeScript does not support restricting the visibility for exported symbols.\nOnly export symbols that are used outside of the module. Generally minimize the\nexported API surface of modules.",
                "example": []
            }
        ]
    },
    {
        "title": "Mutable exports",
        "belongs to": "Source file structure/Imports/Namespace versus named imports/Exports/Mutable exports",
        "cases": [
            {
                "description": "Regardless of technical support, mutable exports can create hard to understand\nand debug code, in particular with re-exports across multiple modules. One way\nto paraphrase this style point is that export let is not allowed.\nexport let foo = 3;\n// In pure ES6, foo is mutable and importers will observe the value change after a second.\n// In TS, if foo is re-exported by a second file, importers will not see the value change.\nwindow.setTimeout(() => {\n  foo = 4;\n}, 1000 /* ms */);\n\nIf one needs to support externally accessible and mutable bindings, they\nshould instead use explicit getter functions.",
                "example": [
                    "let foo = 3;\nwindow.setTimeout(() => {\n  foo = 4;\n}, 1000 /* ms */);\n// Use an explicit getter to access the mutable export.\nexport function getFoo() { return foo; };\n"
                ]
            },
            {
                "description": "For the common pattern of conditionally exporting either of two values, first do\nthe conditional check, then the export. Make sure that all exports are final\nafter the module's body has executed.",
                "example": [
                    "function pickApi() {\n  if (useOtherApi()) return OtherApi;\n  return RegularApi;\n}\nexport const SomeApi = pickApi();\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Container classes",
        "belongs to": "Source file structure/Imports/Namespace versus named imports/Exports/Container classes",
        "cases": [
            {
                "description": "Do not create container classes with static methods or properties for the sake\nof namespacing.",
                "example": [
                    "export class Container {\n  static FOO = 1;\n  static bar() { return 1; }\n}\n"
                ]
            },
            {
                "description": "Instead, export individual constants and functions:",
                "example": [
                    "export const FOO = 1;\nexport function bar() { return 1; }\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Import and export type",
        "belongs to": "Source file structure/Imports/Namespace versus named imports/Exports/Import and export type",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Import type",
        "belongs to": "Source file structure/Imports/Namespace versus named imports/Exports/Import and export type/Import type",
        "cases": [
            {
                "description": "You may use import type {...} when you use the imported symbol only as a type.\nUse regular imports for values:",
                "example": [
                    "import type {Foo} from './foo';\nimport {Bar} from './foo';\n\nimport {type Foo, Bar} from './foo';\n"
                ]
            },
            {
                "description": "\nWhy?\nThe TypeScript compiler automatically handles the distinction and does not\ninsert runtime loads for type references. So why annotate type imports?\nThe TypeScript compiler can run in 2 modes:\n\nIn development mode, we typically want quick iteration loops. The compiler\ntranspiles to JavaScript without full type information. This is much faster,\nbut requires import type in certain cases.\nIn production mode, we want correctness. The compiler type checks everything\nand ensures import type is used correctly.\n\nNote: If you need to force a runtime load for side effects, use import '...';.\nSee \n",
                "example": []
            }
        ]
    },
    {
        "title": "Export type",
        "belongs to": "Source file structure/Imports/Namespace versus named imports/Exports/Import and export type/Export type",
        "cases": [
            {
                "description": "Use export type when re-exporting a type, e.g.:",
                "example": [
                    "export type {AnInterface} from './foo';\n"
                ]
            },
            {
                "description": "\nWhy?\nexport type is useful to allow type re-exports in file-by-file transpilation.\nSee\nisolatedModules docs.\nexport type might also seem useful to avoid ever exporting a value symbol for\nan API. However it does not give guarantees, either: downstream code might still\nimport an API through a different path. A better way to split & guarantee type\nvs value usages of an API is to actually split the symbols into e.g.\nUserService and AjaxUserService. This is less error prone and also better\ncommunicates intent.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Use modules not namespaces",
        "belongs to": "Source file structure/Imports/Namespace versus named imports/Exports/Import and export type/Use modules not namespaces",
        "cases": [
            {
                "description": "TypeScript supports two methods to organize code: namespaces and modules,\nbut namespaces are disallowed.  That\nis, your code must refer to code in other files using imports and exports of\nthe form import {foo} from 'bar';Your code must not use the namespace Foo { ... } construct. namespaces\nmay only be used when required to interface with external, third party code.\nTo semantically namespace your code, use separate files.Code must not use require (as in import x = require('...');) for imports.\nUse ES6 module syntax.",
                "example": [
                    "// Bad: do not use namespaces:\nnamespace Rocket {\n  function launch() { ... }\n}\n\n// Bad: do not use <reference>\n/// <reference path=\"...\"/>\n\n// Bad: do not use require()\nimport x = require('mydep');\n"
                ]
            },
            {
                "description": "\nNB: TypeScript namespaces used to be called internal modules and used to use\nthe module keyword in the form module Foo { ... }. Don't use that either.\nAlways use ES6 imports.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Language features",
        "belongs to": "Language features",
        "cases": [
            {
                "description": "This section delineates which features may or may not be used, and any\nadditional constraints on their use.Language features which are not discussed in this style guide may be used with\nno recommendations of their usage.",
                "example": []
            }
        ]
    },
    {
        "title": "Local variable declarations",
        "belongs to": "Language features/Local variable declarations",
        "cases": [
            {
                "description": "\n",
                "example": []
            }
        ]
    },
    {
        "title": "Use const and let",
        "belongs to": "Language features/Local variable declarations/Use const and let",
        "cases": [
            {
                "description": "Always use const or let to declare variables. Use const by default, unless\na variable needs to be reassigned. Never use var.",
                "example": [
                    "const foo = otherValue;  // Use if \"foo\" never changes.\nlet bar = someValue;     // Use if \"bar\" is ever assigned into later on.\n"
                ]
            },
            {
                "description": "const and let are block scoped, like variables in most other languages.\nvar in JavaScript is function scoped, which can cause difficult to understand\nbugs. Don't use it.",
                "example": [
                    "var foo = someValue;     // Don't use - var scoping is complex and causes bugs.\n"
                ]
            },
            {
                "description": "Variables must not be used before their declaration.",
                "example": []
            }
        ]
    },
    {
        "title": "One variable per declaration",
        "belongs to": "Language features/Local variable declarations/One variable per declaration",
        "cases": [
            {
                "description": "Every local variable declaration declares only one variable: declarations such\nas let a = 1, b = 2; are not used.",
                "example": []
            }
        ]
    },
    {
        "title": "Array literals",
        "belongs to": "Language features/Local variable declarations/Array literals",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Do not use the Array constructor",
        "belongs to": "Language features/Local variable declarations/Array literals/Do not use the Array constructor",
        "cases": [
            {
                "description": "Do not use the Array() constructor, with or without new. It has confusing\nand contradictory usage:",
                "example": [
                    "const a = new Array(2); // [undefined, undefined]\nconst b = new Array(2, 3); // [2, 3];\n"
                ]
            },
            {
                "description": "Instead, always use bracket notation to initialize arrays, or from to\ninitialize an Array with a certain size:",
                "example": [
                    "const a = [2];\nconst b = [2, 3];\n\n// Equivalent to Array(2):\nconst c = [];\nc.length = 2;\n\n// [0, 0, 0, 0, 0]\nArray.from<number>({length: 5}).fill(0);\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Do not define properties on arrays",
        "belongs to": "Language features/Local variable declarations/Array literals/Do not define properties on arrays",
        "cases": [
            {
                "description": "Do not define or use non-numeric properties on an array (other than length).\nUse a Map (or Object) instead.",
                "example": []
            }
        ]
    },
    {
        "title": "Using spread syntax",
        "belongs to": "Language features/Local variable declarations/Array literals/Using spread syntax",
        "cases": [
            {
                "description": "Using spread syntax [...foo]; is a convenient shorthand for shallow-copying or\nconcatenating iterables.",
                "example": [
                    "const foo = [\n  1,\n];\n\nconst foo2 = [\n  ...foo,\n  6,\n  7,\n];\n\nconst foo3 = [\n  5,\n  ...foo,\n];\n\nfoo2[1] === 6;\nfoo3[1] === 1;\n"
                ]
            },
            {
                "description": "When using spread syntax, the value being spread must match what is being\ncreated. When creating an array, only spread iterables. Primitives (including\nnull and undefined) must not be spread.",
                "example": [
                    "const foo = [7];\nconst bar = [5, ...(shouldUseFoo && foo)]; // might be undefined\n\n// Creates {0: 'a', 1: 'b', 2: 'c'} but has no length\nconst fooStrings = ['a', 'b', 'c'];\nconst ids = {...fooStrings};\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "const foo = shouldUseFoo ? [7] : [];\nconst bar = [5, ...foo];\nconst fooStrings = ['a', 'b', 'c'];\nconst ids = [...fooStrings, 'd', 'e'];\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Array destructuring",
        "belongs to": "Language features/Local variable declarations/Array literals/Array destructuring",
        "cases": [
            {
                "description": "Array literals may be used on the left-hand side of an assignment to perform\ndestructuring (such as when unpacking multiple values from a single array or\niterable). A final rest element may be included (with no space between the\n... and the variable name). Elements should be omitted if they are unused.",
                "example": [
                    "const [a, b, c, ...rest] = generateResults();\nlet [, b,, d] = someArray;\n"
                ]
            },
            {
                "description": "Destructuring may also be used for function parameters. Always specify [] as\nthe default value if a destructured array parameter is optional, and provide\ndefault values on the left hand side:",
                "example": [
                    "function destructured([a = 4, b = 2] = []) { … }\n"
                ]
            },
            {
                "description": "Disallowed:",
                "example": [
                    "function badDestructuring([a, b] = [4, 2]) { … }\n"
                ]
            },
            {
                "description": "Tip: For (un)packing multiple values into a function’s parameter or return,\nprefer object destructuring to array destructuring when possible, as it allows\nnaming the individual elements and specifying a different type for each.",
                "example": []
            }
        ]
    },
    {
        "title": "Object literals",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Do not use the Object constructor",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Do not use the Object constructor",
        "cases": [
            {
                "description": "The Object constructor is disallowed. Use an object literal ({} or {a: 0,\nb: 1, c: 2}) instead.",
                "example": []
            }
        ]
    },
    {
        "title": "Iterating objects",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Iterating objects",
        "cases": [
            {
                "description": "Iterating objects with for (... in ...) is error prone. It will include\nenumerable properties from the prototype chain.Do not use unfiltered for (... in ...) statements:",
                "example": [
                    "for (const x in someObj) {\n  // x could come from some parent prototype!\n}\n"
                ]
            },
            {
                "description": "Either filter values explicitly with an if statement, or use for (... of\nObject.keys(...)).",
                "example": [
                    "for (const x in someObj) {\n  if (!someObj.hasOwnProperty(x)) continue;\n  // now x was definitely defined on someObj\n}\nfor (const x of Object.keys(someObj)) { // note: for _of_!\n  // now x was definitely defined on someObj\n}\nfor (const [key, value] of Object.entries(someObj)) { // note: for _of_!\n  // now key was definitely defined on someObj\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Using spread syntax",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Using spread syntax",
        "cases": [
            {
                "description": "Using spread syntax {...bar} is a convenient shorthand for creating a shallow\ncopy of an object. When using spread syntax in object initialization, later\nvalues replace earlier values at the same key.",
                "example": [
                    "const foo = {\n  num: 1,\n};\n\nconst foo2 = {\n  ...foo,\n  num: 5,\n};\n\nconst foo3 = {\n  num: 5,\n  ...foo,\n}\n\nfoo2.num === 5;\nfoo3.num === 1;\n\n"
                ]
            },
            {
                "description": "When using spread syntax, the value being spread must match what is being\ncreated. That is, when creating an object, only objects may be spread; arrays\nand primitives (including null and undefined) must not be spread. Avoid\nspreading objects that have prototypes other than the Object prototype (e.g.\nclass definitions, class instances, functions) as the behavior is unintuitive\n(only enumerable non-prototype properties are shallow-copied).",
                "example": [
                    "const foo = {num: 7};\nconst bar = {num: 5, ...(shouldUseFoo && foo)}; // might be undefined\n\n// Creates {0: 'a', 1: 'b', 2: 'c'} but has no length\nconst fooStrings = ['a', 'b', 'c'];\nconst ids = {...fooStrings};\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "const foo = shouldUseFoo ? {num: 7} : {};\nconst bar = {num: 5, ...foo};\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Computed property names",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Computed property names",
        "cases": [
            {
                "description": "Computed property names (e.g. {['key' + foo()]: 42}) are allowed, and are\nconsidered dict-style (quoted) keys (i.e., must not be mixed with non-quoted\nkeys) unless the computed property is a\nsymbol\n(e.g. [Symbol.iterator]).",
                "example": []
            }
        ]
    },
    {
        "title": "Object destructuring",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Object destructuring",
        "cases": [
            {
                "description": "Object destructuring patterns may be used on the left-hand side of an assignment\nto perform destructuring and unpack multiple values from a single object.Destructured objects may also be used as function parameters, but should be kept\nas simple as possible: a single level of unquoted shorthand properties. Deeper\nlevels of nesting and computed properties may not be used in parameter\ndestructuring. Specify any default values in the left-hand-side of the\ndestructured parameter ({str = 'some default'} = {}, rather than\n{str} = {str: 'some default'}), and if a\ndestructured object is itself optional, it must default to {}.Example:",
                "example": [
                    "interface Options {\n  /** The number of times to do something. */\n  num?: number;\n\n  /** A string to do stuff to. */\n  str?: string;\n}\n\nfunction destructured({num, str = 'default'}: Options = {}) {}\n"
                ]
            },
            {
                "description": "Disallowed:",
                "example": [
                    "function nestedTooDeeply({x: {num, str}}: {x: Options}) {}\nfunction nontrivialDefault({num, str}: Options = {num: 42, str: 'default'}) {}\n"
                ]
            },
            {
                "description": "\n",
                "example": []
            }
        ]
    },
    {
        "title": "Classes",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Class declarations",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class declarations",
        "cases": [
            {
                "description": "Class declarations must not be terminated with semicolons:",
                "example": [
                    "class Foo {\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class Foo {\n}; // Unnecessary semicolon\n"
                ]
            },
            {
                "description": "In contrast, statements that contain class expressions must be terminated with\na semicolon:",
                "example": [
                    "export const Baz = class extends Bar {\n  method(): number {\n    return this.x;\n  }\n}; // Semicolon here as this is a statement, not a declaration\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "exports const Baz = class extends Bar {\n  method(): number {\n    return this.x;\n  }\n}\n"
                ]
            },
            {
                "description": "It is neither encouraged nor discouraged to have blank lines separating class\ndeclaration braces from other class content:",
                "example": [
                    "// No spaces around braces - fine.\nclass Baz {\n  method(): number {\n    return this.x;\n  }\n}\n\n// A single space around both braces - also fine.\nclass Foo {\n\n  method(): number {\n    return this.x;\n  }\n\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Class method declarations",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations",
        "cases": [
            {
                "description": "Class method declarations must not use a semicolon to separate individual\nmethod declarations:",
                "example": [
                    "class Foo {\n  doThing() {\n    console.log(\"A\");\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class Foo {\n  doThing() {\n    console.log(\"A\");\n  }; // <-- unnecessary\n}\n"
                ]
            },
            {
                "description": "Method declarations should be separated from surrounding code by a single blank\nline:",
                "example": [
                    "class Foo {\n  doThing() {\n    console.log(\"A\");\n  }\n\n  getOtherThing(): number {\n    return 4;\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class Foo {\n  doThing() {\n    console.log(\"A\");\n  }\n  getOtherThing(): number {\n    return 4;\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Overriding toString",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Overriding toString",
        "cases": [
            {
                "description": "The toString method may be overridden, but must always succeed and never have\nvisible side effects.Tip: Beware, in particular, of calling other methods from toString, since\nexceptional conditions could lead to infinite loops.",
                "example": []
            }
        ]
    },
    {
        "title": "Static methods",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Avoid private static methods",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Avoid private static methods",
        "cases": [
            {
                "description": "Where it does not interfere with readability, prefer module-local functions over\nprivate static methods.",
                "example": []
            }
        ]
    },
    {
        "title": "Do not rely on dynamic dispatch",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Do not rely on dynamic dispatch",
        "cases": [
            {
                "description": "Code should not rely on dynamic dispatch of static\nmethods. Static methods should only be called on the base class\nitself (which defines it directly). Static methods should not be called on\nvariables containing a dynamic instance that may be either the constructor or a\nsubclass constructor (and must be defined with @nocollapse if this is done),\nand must not be called directly on a subclass that doesn’t define the method\nitself.Disallowed:",
                "example": [
                    "// Context for the examples below (this class is okay by itself)\nclass Base {\n  /** @nocollapse */ static foo() {}\n}\nclass Sub extends Base {}\n\n// Discouraged: don't call static methods dynamically\nfunction callFoo(cls: typeof Base) {\n  cls.foo();\n}\n\n// Disallowed: don't call static methods on subclasses that don't define it themselves\nSub.foo();\n\n// Disallowed: don't access this in static methods.\nclass MyClass {\n  static foo() {\n    return this.staticField;\n  }\n}\nMyClass.staticField = 1;\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Avoid static this references",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Avoid static this references",
        "cases": [
            {
                "description": "Code must not use this in a static context.JavaScript allows accessing static fields through this. Different from other\nlanguages, static fields are also inherited.",
                "example": [
                    "class ShoeStore {\n  static storage: Storage = ...;\n\n  static isAvailable(s: Shoe) {\n    // Bad: do not use `this` in a static method.\n    return this.storage.has(s.id);\n  }\n}\n\nclass EmptyShoeStore extends ShoeStore {\n  static storage: Storage = EMPTY_STORE;  // overrides storage from ShoeStore\n}\n"
                ]
            },
            {
                "description": "\nWhy?\nThis code is generally surprising: authors might not expect that static fields\ncan be accessed through the this pointer, and might be surprised to find that\nthey can be overridden - this feature is not commonly used.\nThis code also encourages an anti-pattern of having substantial static state,\nwhich causes problems with testability.\n\n",
                "example": []
            }
        ]
    },
    {
        "title": "Constructors",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Constructors",
        "cases": [
            {
                "description": "Constructor calls must use parentheses, even when no arguments are passed:",
                "example": [
                    "const x = new Foo;\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "const x = new Foo();\n"
                ]
            },
            {
                "description": "Omitting parentheses can lead to subtle mistakes. These two lines are not\nequivalent:",
                "example": [
                    "new Foo().Bar();\nnew Foo.Bar();\n"
                ]
            },
            {
                "description": "It is unnecessary to provide an empty constructor or one that simply delegates\ninto its parent class because ES2015 provides a default class constructor if one\nis not specified. However constructors with parameter properties, visibility\nmodifiers or parameter decorators should not be omitted even if the body of\nthe constructor is empty.",
                "example": [
                    "class UnnecessaryConstructor {\n  constructor() {}\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class UnnecessaryConstructorOverride extends Base {\n    constructor(value: number) {\n      super(value);\n    }\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class DefaultConstructor {\n}\n\nclass ParameterProperties {\n  constructor(private myService) {}\n}\n\nclass ParameterDecorators {\n  constructor(@SideEffectDecorator myService) {}\n}\n\nclass NoInstantiation {\n  private constructor() {}\n}\n"
                ]
            },
            {
                "description": "The constructor should be separated from surrounding code both above and below\nby a single blank line:",
                "example": [
                    "class Foo {\n  myField = 10;\n\n  constructor(private readonly ctorParam) {}\n\n  doThing() {\n    console.log(ctorParam.getThing() + myField);\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class Foo {\n  myField = 10;\n  constructor(private readonly ctorParam) {}\n  doThing() {\n    console.log(ctorParam.getThing() + myField);\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Class members",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "No #private fields",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/No #private fields",
        "cases": [
            {
                "description": "Do not use private fields (also known as private identifiers):",
                "example": [
                    "class Clazz {\n  #ident = 1;\n}\n"
                ]
            },
            {
                "description": "Instead, use TypeScript's visibility annotations:",
                "example": [
                    "class Clazz {\n  private ident = 1;\n}\n"
                ]
            },
            {
                "description": "\nWhy?\n Private identifiers cause substantial emit size and\nperformance regressions when down-leveled by TypeScript, and are unsupported\nbefore ES2015. They can only be downleveled to ES2015, not lower. At the same\ntime, they do not offer substantial benefits when static type checking is used\nto enforce visibility.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Use readonly",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Use readonly",
        "cases": [
            {
                "description": "Mark properties that are never reassigned outside of the constructor with the\nreadonly modifier (these need not be deeply immutable).",
                "example": []
            }
        ]
    },
    {
        "title": "Parameter properties",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Parameter properties",
        "cases": [
            {
                "description": "Rather than plumbing an obvious initializer through to a class member, use a\nTypeScript\nparameter property.",
                "example": [
                    "class Foo {\n  private readonly barService: BarService;\n\n  constructor(barService: BarService) {\n    this.barService = barService;\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class Foo {\n  constructor(private readonly barService: BarService) {}\n}\n"
                ]
            },
            {
                "description": "If the parameter property needs documentation,\nuse an @param JSDoc tag.",
                "example": []
            }
        ]
    },
    {
        "title": "Field initializers",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Field initializers",
        "cases": [
            {
                "description": "If a class member is not a parameter, initialize it where it's declared, which\nsometimes lets you drop the constructor entirely.",
                "example": [
                    "class Foo {\n  private readonly userList: string[];\n\n  constructor() {\n    this.userList = [];\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class Foo {\n  private readonly userList: string[] = [];\n}\n"
                ]
            },
            {
                "description": "Tip: Properties should never be added to or removed from an instance after the\nconstructor is finished, since it significantly hinders VMs’ ability to optimize\nclasses' shape. Optional fields that may be filled in later should be\nexplicitly initialized to undefined to prevent later shape changes.",
                "example": []
            }
        ]
    },
    {
        "title": "Properties used outside of class lexical scope",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Properties used outside of class lexical scope",
        "cases": [
            {
                "description": "Properties used from outside the lexical scope of their containing class, such\nas an Angular component's properties used from a template, must not use\nprivate visibility, as they are used outside of the lexical scope of their\ncontaining class.Use either protected or public as appropriate to the property in question.\nAngular and AngularJS template properties should use protected, but Polymer\nshould use public.TypeScript code must not use obj['foo'] to bypass the visibility of a\nproperty.\nWhy?\nWhen a property is private, you are declaring to both automated systems and\nhumans that the property accesses are scoped to the methods of the declaring\nclass, and they will rely on that. For example, a check for unused code will\nflag a private property that appears to be unused, even if some other file\nmanages to bypass the visibility restriction.\nThough it might appear that obj['foo'] can bypass visibility in the TypeScript\ncompiler, this pattern can be broken by rearranging the build rules, and also\nviolates optimization compatibility.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Getters and setters",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Getters and setters",
        "cases": [
            {
                "description": "Getters and setters, also known as accessors, for class members may be used.\nThe getter method must be a\npure function (i.e., result is\nconsistent and has no side effects: getters must not change observable state).\nThey are also useful as a means of restricting the visibility of internal or\nverbose implementation details (shown below).",
                "example": [
                    "class Foo {\n  constructor(private readonly someService: SomeService) {}\n\n  get someMember(): string {\n    return this.someService.someVariable;\n  }\n\n  set someMember(newValue: string) {\n    this.someService.someVariable = newValue;\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class Foo {\n  nextId = 0;\n  get next() {\n    return this.nextId++; // Bad: getter changes observable state\n  }\n}\n"
                ]
            },
            {
                "description": "If an accessor is used to hide a class property, the hidden property may be\nprefixed or suffixed with any whole word, like internal or wrapped. When\nusing these private properties, access the value through the accessor whenever\npossible. At least one accessor for a property must be non-trivial: do not\ndefine pass-through accessors only for the purpose of hiding a property.\nInstead, make the property public (or consider making it readonly rather than\njust defining a getter with no setter).",
                "example": [
                    "class Foo {\n  private wrappedBar = '';\n  get bar() {\n    return this.wrappedBar || 'bar';\n  }\n\n  set bar(wrapped: string) {\n    this.wrappedBar = wrapped.trim();\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class Bar {\n  private barInternal = '';\n  // Neither of these accessors have logic, so just make bar public.\n  get bar() {\n    return this.barInternal;\n  }\n\n  set bar(value: string) {\n    this.barInternal = value;\n  }\n}\n"
                ]
            },
            {
                "description": "Getters and setters must not be defined using Object.defineProperty, since\nthis interferes with property renaming.",
                "example": []
            }
        ]
    },
    {
        "title": "Computed properties",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Computed properties",
        "cases": [
            {
                "description": "Computed properties may only be used in classes when the property is a symbol.\nDict-style properties (that is, quoted or computed non-symbol keys) are not\nallowed (see\nrationale for not mixing key types. A\n[Symbol.iterator] method should be defined for any classes that are logically\niterable. Beyond this, Symbol should be used sparingly.Tip: be careful of using any other built-in symbols (e.g.\nSymbol.isConcatSpreadable) as they are not polyfilled by the compiler and will\ntherefore not work in older browsers.",
                "example": []
            }
        ]
    },
    {
        "title": "Visibility",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Visibility",
        "cases": [
            {
                "description": "Restricting visibility of properties, methods, and entire types helps with\nkeeping code decoupled.\nLimit symbol visibility as much as possible.\nConsider converting private methods to non-exported functions within the\nsame file but outside of any class, and moving private properties into a\nseparate, non-exported class.\nTypeScript symbols are public by default. Never use the public modifier\nexcept when declaring non-readonly public parameter properties (in\nconstructors).\n",
                "example": [
                    "class Foo {\n  public bar = new Bar();  // BAD: public modifier not needed\n\n  constructor(public readonly baz: Baz) {}  // BAD: readonly implies it's a property which defaults to public\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class Foo {\n  bar = new Bar();  // GOOD: public modifier not needed\n\n  constructor(public baz: Baz) {}  // public modifier allowed\n}\n"
                ]
            },
            {
                "description": "See also export visibility.",
                "example": []
            }
        ]
    },
    {
        "title": "Disallowed class patterns",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Do not manipulate prototypes directly",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Do not manipulate prototypes directly",
        "cases": [
            {
                "description": "The class keyword allows clearer and more readable class definitions than\ndefining prototype properties. Ordinary implementation code has no business\nmanipulating these objects. Mixins and modifying the prototypes of builtin\nobjects are explicitly forbidden.Exception: Framework code (such as Polymer, or Angular) may need to use prototypes, and should not resort\nto even-worse workarounds to avoid doing so.",
                "example": []
            }
        ]
    },
    {
        "title": "Functions",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Terminology",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Terminology",
        "cases": [
            {
                "description": "There are many different types of functions, with subtle distinctions between\nthem. This guide uses the following terminology, which aligns with\nMDN:\nfunction declaration: a declaration (i.e. not an expression) using the\nfunction keyword\nfunction expression: an expression, typically used in an assignment or\npassed as a parameter, using the function keyword\narrow function: an expression using the => syntax\nblock body: right hand side of an arrow function with braces\nconcise body: right hand side of an arrow function without braces\nMethods and classes/constructors are not covered in this section.",
                "example": []
            }
        ]
    },
    {
        "title": "Prefer function declarations for named functions",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Prefer function declarations for named functions",
        "cases": [
            {
                "description": "Prefer function declarations over arrow functions or function expressions when\ndefining named functions.",
                "example": [
                    "function foo() {\n  return 42;\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "const foo = () => 42;\n"
                ]
            },
            {
                "description": "Arrow functions may be used, for example, when an explicit type annotation is\nrequired.",
                "example": [
                    "interface SearchFunction {\n  (source: string, subString: string): boolean;\n}\n\nconst fooSearch: SearchFunction = (source, subString) => { ... };\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Nested functions",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Nested functions",
        "cases": [
            {
                "description": "Functions nested within other methods or functions may use function\ndeclarations or arrow functions, as appropriate. In method bodies in particular,\narrow functions are preferred because they have access to the outer this.",
                "example": []
            }
        ]
    },
    {
        "title": "Do not use function expressions",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Do not use function expressions",
        "cases": [
            {
                "description": "Do not use function expressions. Use arrow functions instead.",
                "example": [
                    "bar(() => { this.doSomething(); })\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "bar(function() { ... })\n"
                ]
            },
            {
                "description": "Exception: Function expressions may be used only if code has to\ndynamically rebind this (but this is discouraged), or for\ngenerator functions (which do not have an arrow syntax).\n",
                "example": []
            }
        ]
    },
    {
        "title": "Arrow function bodies",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Arrow function bodies",
        "cases": [
            {
                "description": "Use arrow functions with concise bodies (i.e. expressions) or block bodies as\nappropriate.",
                "example": [
                    "// Top level functions use function declarations.\nfunction someFunction() {\n  // Block bodies are fine:\n  const receipts = books.map((b: Book) => {\n    const receipt = payMoney(b.price);\n    recordTransaction(receipt);\n    return receipt;\n  });\n\n  // Concise bodies are fine, too, if the return value is used:\n  const longThings = myValues.filter(v => v.length > 1000).map(v => String(v));\n\n  function payMoney(amount: number) {\n    // function declarations are fine, but must not access `this`.\n  }\n\n  // Nested arrow functions may be assigned to a const.\n  const computeTax = (amount: number) => amount * 0.12;\n}\n"
                ]
            },
            {
                "description": "Only use a concise body if the return value of the function is actually used.\nThe block body makes sure the return type is void then and prevents potential\nside effects.",
                "example": [
                    "// BAD: use a block body if the return value of the function is not used.\nmyPromise.then(v => console.log(v));\n// BAD: this typechecks, but the return value still leaks.\nlet f: () => void;\nf = () => 1;\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// GOOD: return value is unused, use a block body.\nmyPromise.then(v => {\n  console.log(v);\n});\n// GOOD: code may use blocks for readability.\nconst transformed = [1, 2, 3].map(v => {\n  const intermediate = someComplicatedExpr(v);\n  const more = acrossManyLines(intermediate);\n  return worthWrapping(more);\n});\n// GOOD: explicit `void` ensures no leaked return value\nmyPromise.then(v => void console.log(v));\n"
                ]
            },
            {
                "description": "Tip: The void operator can be used to ensure an arrow function with an\nexpression body returns undefined when the result is unused.",
                "example": []
            }
        ]
    },
    {
        "title": "Rebinding this",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Rebinding this",
        "cases": [
            {
                "description": "Function expressions and function declarations must not use this unless they\nspecifically exist to rebind the this pointer. Rebinding this can in most\ncases be avoided by using arrow functions or explicit parameters.",
                "example": [
                    "function clickHandler() {\n  // Bad: what's `this` in this context?\n  this.textContent = 'Hello';\n}\n// Bad: the `this` pointer reference is implicitly set to document.body.\ndocument.body.onclick = clickHandler;\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// Good: explicitly reference the object from an arrow function.\ndocument.body.onclick = () => { document.body.textContent = 'hello'; };\n// Alternatively: take an explicit parameter\nconst setTextFn = (e: HTMLElement) => { e.textContent = 'hello'; };\ndocument.body.onclick = setTextFn.bind(null, document.body);\n"
                ]
            },
            {
                "description": "Prefer arrow functions over other approaches to binding this, such as\nf.bind(this), goog.bind(f, this), or const self = this.",
                "example": []
            }
        ]
    },
    {
        "title": "Prefer passing arrow functions as callbacks",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Prefer passing arrow functions as callbacks",
        "cases": [
            {
                "description": "Callbacks can be invoked with unexpected arguments that can pass a type check\nbut still result in logical errors.Avoid passing a named callback to a higher-order function, unless you are sure\nof the stability of both functions' call signatures. Beware, in particular, of\nless-commonly-used optional parameters.",
                "example": [
                    "// BAD: Arguments are not explicitly passed, leading to unintended behavior\n// when the optional `radix` argument gets the array indices 0, 1, and 2.\nconst numbers = ['11', '5', '10'].map(parseInt);\n// > [11, NaN, 2];\n"
                ]
            },
            {
                "description": "Instead, prefer passing an arrow-function that explicitly forwards parameters to\nthe named callback.",
                "example": [
                    "// GOOD: Arguments are explicitly passed to the callback\nconst numbers = ['11', '5', '3'].map((n) => parseInt(n));\n// > [11, 5, 3]\n\n// GOOD: Function is locally defined and is designed to be used as a callback\nfunction dayFilter(element: string|null|undefined) {\n  return element != null && element.endsWith('day');\n}\n\nconst days = ['tuesday', undefined, 'juice', 'wednesday'].filter(dayFilter);\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Arrow functions as properties",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Arrow functions as properties",
        "cases": [
            {
                "description": "Classes usually should not contain properties initialized to arrow functions.\nArrow function properties require the calling function to understand that the\ncallee's this is already bound, which increases confusion about what this\nis, and call sites and references using such handlers look broken (i.e. require\nnon-local knowledge to determine that they are correct). Code should always\nuse arrow functions to call instance methods (const handler = (x) => {\nthis.listener(x); };), and should not obtain or pass references to instance\nmethods (const handler = this.listener; handler(x);).\nNote: in some specific situations, e.g. when binding functions in a template,\narrow functions as properties are useful and create much more readable code.\nUse judgement with this rule. Also, see the\nEvent Handlers section below.\n",
                "example": [
                    "class DelayHandler {\n  constructor() {\n    // Problem: `this` is not preserved in the callback. `this` in the callback\n    // will not be an instance of DelayHandler.\n    setTimeout(this.patienceTracker, 5000);\n  }\n  private patienceTracker() {\n    this.waitedPatiently = true;\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// Arrow functions usually should not be properties.\nclass DelayHandler {\n  constructor() {\n    // Bad: this code looks like it forgot to bind `this`.\n    setTimeout(this.patienceTracker, 5000);\n  }\n  private patienceTracker = () => {\n    this.waitedPatiently = true;\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// Explicitly manage `this` at call time.\nclass DelayHandler {\n  constructor() {\n    // Use anonymous functions if possible.\n    setTimeout(() => {\n      this.patienceTracker();\n    }, 5000);\n  }\n  private patienceTracker() {\n    this.waitedPatiently = true;\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Event handlers",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Event handlers",
        "cases": [
            {
                "description": "Event handlers may use arrow functions when there is no need to uninstall the\nhandler (for example, if the event is emitted by the class itself). If the\nhandler requires uninstallation, arrow function properties are the right\napproach, because they automatically capture this and provide a stable\nreference to uninstall.",
                "example": [
                    "// Event handlers may be anonymous functions or arrow function properties.\nclass Component {\n  onAttached() {\n    // The event is emitted by this class, no need to uninstall.\n    this.addEventListener('click', () => {\n      this.listener();\n    });\n    // this.listener is a stable reference, we can uninstall it later.\n    window.addEventListener('onbeforeunload', this.listener);\n  }\n  onDetached() {\n    // The event is emitted by window. If we don't uninstall, this.listener will\n    // keep a reference to `this` because it's bound, causing a memory leak.\n    window.removeEventListener('onbeforeunload', this.listener);\n  }\n  // An arrow function stored in a property is bound to `this` automatically.\n  private listener = () => {\n    confirm('Do you want to exit the page?');\n  }\n}\n"
                ]
            },
            {
                "description": "Do not use bind in the expression that installs an event handler, because it\ncreates a temporary reference that can't be uninstalled.",
                "example": [
                    "// Binding listeners creates a temporary reference that prevents uninstalling.\nclass Component {\n  onAttached() {\n    // This creates a temporary reference that we won't be able to uninstall\n    window.addEventListener('onbeforeunload', this.listener.bind(this));\n  }\n  onDetached() {\n    // This bind creates a different reference, so this line does nothing.\n    window.removeEventListener('onbeforeunload', this.listener.bind(this));\n  }\n  private listener() {\n    confirm('Do you want to exit the page?');\n  }\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Parameter initializers",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Parameter initializers",
        "cases": [
            {
                "description": "Optional function parameters may be given a default initializer to use when\nthe argument is omitted. Initializers must not have any observable side\neffects. Initializers should be kept as simple as possible.",
                "example": [
                    "function process(name: string, extraContext: string[] = []) {}\nfunction activate(index = 0) {}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// BAD: side effect of incrementing the counter\nlet globalCounter = 0;\nfunction newId(index = globalCounter++) {}\n\n// BAD: exposes shared mutable state, which can introduce unintended coupling\n// between function calls\nclass Foo {\n  private readonly defaultPaths: string[];\n  frobnicate(paths = defaultPaths) {}\n}\n"
                ]
            },
            {
                "description": "Use default parameters sparingly. Prefer\ndestructuring to create readable APIs when\nthere are more than a small handful of optional parameters that do not have a\nnatural order.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Prefer rest and spread when appropriate",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Prefer rest and spread when appropriate",
        "cases": [
            {
                "description": "Use a rest parameter instead of accessing arguments. Never name a local\nvariable or parameter arguments, which confusingly shadows the built-in name.",
                "example": [
                    "function variadic(array: string[], ...numbers: number[]) {}\n"
                ]
            },
            {
                "description": "Use function spread syntax instead of Function.prototype.apply.",
                "example": []
            }
        ]
    },
    {
        "title": "Formatting functions",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Formatting functions",
        "cases": [
            {
                "description": "Blank lines at the start or end of the function body are not allowed.A single blank line may be used within function bodies sparingly to create\nlogical groupings of statements.Generators should attach the * to the function and yield keywords, as in\nfunction* foo() and yield* iter, rather than function *foo() or\nyield *iter.Parentheses around the left-hand side of a single-argument arrow function are\nrecommended but not required.Do not put a space after the ... in rest or spread syntax.",
                "example": [
                    "function myFunction(...elements: number[]) {}\nmyFunction(...array, ...iterable, ...generator());\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "this",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/this",
        "cases": [
            {
                "description": "Only use this in class constructors and methods, functions that have an\nexplicit this type declared (e.g. function func(this: ThisType, ...)), or in\narrow functions defined in a scope where this may be used.Never use this to refer to the global object, the context of an eval, the\ntarget of an event, or unnecessarily call()ed or apply()ed functions.",
                "example": [
                    "this.alert('Hello');\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Interfaces",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Interfaces",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Primitive literals",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "String literals",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Use single quotes",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Use single quotes",
        "cases": [
            {
                "description": "Ordinary string literals are delimited with single quotes ('), rather than\ndouble quotes (\").Tip: if a string contains a single quote character, consider using a template\nstring to avoid having to escape the quote.\n",
                "example": []
            }
        ]
    },
    {
        "title": "No line continuations",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/No line continuations",
        "cases": [
            {
                "description": "Do not use line continuations (that is, ending a line inside a string literal\nwith a backslash) in either ordinary or template string literals. Even though\nES5 allows this, it can lead to tricky errors if any trailing whitespace comes\nafter the slash, and is less obvious to readers.Disallowed:",
                "example": [
                    "const LONG_STRING = 'This is a very very very very very very very long string. \\\n    It inadvertently contains long stretches of spaces due to how the \\\n    continued lines are indented.';\n"
                ]
            },
            {
                "description": "Instead, write",
                "example": [
                    "const LONG_STRING = 'This is a very very very very very very long string. ' +\n    'It does not contain long stretches of spaces because it uses ' +\n    'concatenated strings.';\nconst SINGLE_STRING =\n    'http://it.is.also/acceptable_to_use_a_single_long_string_when_breaking_would_hinder_search_discoverability';\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Template literals",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Template literals",
        "cases": [
            {
                "description": "Use template literals (delimited with `) over complex string\nconcatenation, particularly if multiple string literals are involved. Template\nliterals may span multiple lines.If a template literal spans multiple lines, it does not need to follow the\nindentation of the enclosing block, though it may if the added whitespace does\nnot matter.Example:",
                "example": [
                    "function arithmetic(a: number, b: number) {\n  return `Here is a table of arithmetic operations:\n${a} + ${b} = ${a + b}\n${a} - ${b} = ${a - b}\n${a} * ${b} = ${a * b}\n${a} / ${b} = ${a / b}`;\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Number literals",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Number literals",
        "cases": [
            {
                "description": "Numbers may be specified in decimal, hex, octal, or binary. Use exactly 0x,\n0o, and 0b prefixes, with lowercase letters, for hex, octal, and binary,\nrespectively. Never include a leading zero unless it is immediately followed by\nx, o, or b.",
                "example": []
            }
        ]
    },
    {
        "title": "Type coercion",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion",
        "cases": [
            {
                "description": "TypeScript code may use the String() and Boolean() (note: no new!)\nfunctions, string template literals, or !! to coerce types.",
                "example": [
                    "const bool = Boolean(false);\nconst str = String(aNumber);\nconst bool2 = !!str;\nconst str2 = `result: ${bool2}`;\n"
                ]
            },
            {
                "description": "Values of enum types (including unions of enum types and other types) must not\nbe converted to booleans with Boolean() or !!, and must instead be compared\nexplicitly with comparison operators.",
                "example": [
                    "enum SupportLevel {\n  NONE,\n  BASIC,\n  ADVANCED,\n}\n\nconst level: SupportLevel = ...;\nlet enabled = Boolean(level);\n\nconst maybeLevel: SupportLevel|undefined = ...;\nenabled = !!maybeLevel;\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "enum SupportLevel {\n  NONE,\n  BASIC,\n  ADVANCED,\n}\n\nconst level: SupportLevel = ...;\nlet enabled = level !== SupportLevel.NONE;\n\nconst maybeLevel: SupportLevel|undefined = ...;\nenabled = level !== undefined && level !== SupportLevel.NONE;\n"
                ]
            },
            {
                "description": "\nWhy?\nFor most purposes, it doesn't matter what number or string value an enum name is\nmapped to at runtime, because values of enum types are referred to by name in\nsource code. Consequently, engineers are accustomed to not thinking about this,\nand so situations where it does matter are undesirable because they will be\nsurprising. Such is the case with conversion of enums to booleans; in\nparticular, by default, the first declared enum value is falsy (because it is 0)\nwhile the others are truthy, which is likely to be unexpected. Readers of code\nthat uses an enum value may not even know whether it's the first declared value\nor not.\nUsing string concatenation to cast to string is discouraged, as we check that\noperands to the plus operator are of matching types.Code must use Number() to parse numeric values, and must check its return\nfor NaN values explicitly, unless failing to parse is impossible from context.Note: Number(''), Number(' '), and Number('\\t') would return 0 instead\nof NaN. Number('Infinity') and Number('-Infinity') would return Infinity\nand -Infinity respectively. Additionally, exponential notation such as\nNumber('1e+309') and Number('-1e+309') can overflow into Infinity. These\ncases may require special handling.",
                "example": [
                    "const aNumber = Number('123');\nif (!isFinite(aNumber)) throw new Error(...);\n"
                ]
            },
            {
                "description": "Code must not use unary plus (+) to coerce strings to numbers. Parsing\nnumbers can fail, has surprising corner cases, and can be a code smell (parsing\nat the wrong layer). A unary plus is too easy to miss in code reviews given\nthis.",
                "example": [
                    "const x = +y;\n"
                ]
            },
            {
                "description": "Code also must not use parseInt or parseFloat to parse numbers, except for\nnon-base-10 strings (see below). Both of those functions ignore trailing\ncharacters in the string, which can shadow error conditions (e.g. parsing 12\ndwarves as 12).",
                "example": [
                    "const n = parseInt(someString, 10);  // Error prone,\nconst f = parseFloat(someString);    // regardless of passing a radix.\n"
                ]
            },
            {
                "description": "Code that requires parsing with a radix must check that its input contains\nonly appropriate digits for that radix before calling into parseInt;",
                "example": [
                    "if (!/^[a-fA-F0-9]+$/.test(someString)) throw new Error(...);\n// Needed to parse hexadecimal.\n// tslint:disable-next-line:ban\nconst n = parseInt(someString, 16);  // Only allowed for radix != 10\n"
                ]
            },
            {
                "description": "Use Number() followed by Math.floor or Math.trunc (where available) to\nparse integer numbers:",
                "example": [
                    "let f = Number(someString);\nif (isNaN(f)) handleError();\nf = Math.floor(f);\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Implicit coercion",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Implicit coercion",
        "cases": [
            {
                "description": "Do not use explicit boolean coercions in conditional clauses that have implicit\nboolean coercion. Those are the conditions in an if, for and while\nstatements.",
                "example": [
                    "const foo: MyInterface|null = ...;\nif (!!foo) {...}\nwhile (!!foo) {...}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "const foo: MyInterface|null = ...;\nif (foo) {...}\nwhile (foo) {...}\n"
                ]
            },
            {
                "description": "As with explicit conversions, values of enum types (including\nunions of enum types and other types) must not be implicitly coerced to\nbooleans, and must instead be compared explicitly with comparison operators.",
                "example": [
                    "enum SupportLevel {\n  NONE,\n  BASIC,\n  ADVANCED,\n}\n\nconst level: SupportLevel = ...;\nif (level) {...}\n\nconst maybeLevel: SupportLevel|undefined = ...;\nif (level) {...}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "enum SupportLevel {\n  NONE,\n  BASIC,\n  ADVANCED,\n}\n\nconst level: SupportLevel = ...;\nif (level !== SupportLevel.NONE) {...}\n\nconst maybeLevel: SupportLevel|undefined = ...;\nif (level !== undefined && level !== SupportLevel.NONE) {...}\n"
                ]
            },
            {
                "description": "Other types of values may be either implicitly coerced to booleans or compared\nexplicitly with comparison operators:",
                "example": [
                    "// Explicitly comparing > 0 is OK:\nif (arr.length > 0) {...}\n// so is relying on boolean coercion:\nif (arr.length) {...}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Control structures",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures",
        "cases": [
            {
                "description": "\n",
                "example": []
            }
        ]
    },
    {
        "title": "Control flow statements and blocks",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks",
        "cases": [
            {
                "description": "Control flow statements (if, else, for, do, while, etc) always use\nbraced blocks for the containing code, even if the body contains only a single\nstatement. The first statement of a non-empty block must begin on its own line.",
                "example": [
                    "for (let i = 0; i < x; i++) {\n  doSomethingWith(i);\n}\n\nif (x) {\n  doSomethingWithALongMethodNameThatForcesANewLine(x);\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "if (x)\n  doSomethingWithALongMethodNameThatForcesANewLine(x);\n\nfor (let i = 0; i < x; i++) doSomethingWith(i);\n"
                ]
            },
            {
                "description": "Exception: if statements fitting on one line may elide the block.",
                "example": [
                    "if (x) x.doFoo();\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Assignment in control statements",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Assignment in control statements",
        "cases": [
            {
                "description": "Prefer to avoid assignment of variables inside control statements. Assignment\ncan be easily mistaken for equality checks inside control statements.",
                "example": [
                    "if (x = someFunction()) {\n  // Assignment easily mistaken with equality check\n  // ...\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "x = someFunction();\nif (x) {\n  // ...\n}\n"
                ]
            },
            {
                "description": "In cases where assignment inside the control statement is preferred, enclose the\nassignment in additional parenthesis to indicate it is intentional.",
                "example": [
                    "while ((x = someFunction())) {\n  // Double parenthesis shows assignment is intentional\n  // ...\n}\n\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Iterating containers",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Iterating containers",
        "cases": [
            {
                "description": "Prefer for (... of someArr) to iterate over arrays. Array.prototype.forEach and vanilla for\nloops are also allowed:",
                "example": [
                    "for (const x of someArr) {\n  // x is a value of someArr.\n}\n\nfor (let i = 0; i < someArr.length; i++) {\n  // Explicitly count if the index is needed, otherwise use the for/of form.\n  const x = someArr[i];\n  // ...\n}\nfor (const [i, x] of someArr.entries()) {\n  // Alternative version of the above.\n}\n"
                ]
            },
            {
                "description": "for-in loops may only be used on dict-style objects (see\nbelow for more info). Do not\nuse for (... in ...) to iterate over arrays as it will counterintuitively give\nthe array's indices (as strings!), not values:",
                "example": [
                    "for (const x in someArray) {\n  // x is the index!\n}\n"
                ]
            },
            {
                "description": "Object.prototype.hasOwnProperty should be used in for-in loops to exclude\nunwanted prototype properties. Prefer for-of with Object.keys,\nObject.values, or Object.entries over for-in when possible.",
                "example": [
                    "for (const key in obj) {\n  if (!obj.hasOwnProperty(key)) continue;\n  doWork(key, obj[key]);\n}\nfor (const key of Object.keys(obj)) {\n  doWork(key, obj[key]);\n}\nfor (const value of Object.values(obj)) {\n  doWorkValOnly(value);\n}\nfor (const [key, value] of Object.entries(obj)) {\n  doWork(key, value);\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Grouping parentheses",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Grouping parentheses",
        "cases": [
            {
                "description": "Optional grouping parentheses are omitted only when the author and reviewer\nagree that there is no reasonable chance that the code will be misinterpreted\nwithout them, nor would they have made the code easier to read. It is not\nreasonable to assume that every reader has the entire operator precedence table\nmemorized.Do not use unnecessary parentheses around the entire expression following\ndelete, typeof, void, return, throw, case, in, of, or yield.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Exception handling",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling",
        "cases": [
            {
                "description": "Exceptions are an important part of the language and should be used whenever\nexceptional cases occur.Custom exceptions provide a great way to convey additional error information\nfrom functions. They should be defined and used wherever the native Error type\nis insufficient.Prefer throwing exceptions over ad-hoc error-handling approaches (such as\npassing an error container reference type, or returning an object with an error\nproperty).",
                "example": []
            }
        ]
    },
    {
        "title": "Instantiate errors using new",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Instantiate errors using new",
        "cases": [
            {
                "description": "Always use new Error() when instantiating exceptions, instead of just calling\nError(). Both forms create a new Error instance, but using new is more\nconsistent with how other objects are instantiated.",
                "example": [
                    "throw new Error('Foo is not a valid bar.');\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "throw Error('Foo is not a valid bar.');\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Only throw errors",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Only throw errors",
        "cases": [
            {
                "description": "JavaScript (and thus TypeScript) allow throwing or rejecting a Promise with\narbitrary values. However if the thrown or rejected value is not an Error, it\ndoes not populate stack trace information, making debugging hard. This treatment\nextends to Promise rejection values as Promise.reject(obj) is equivalent to\nthrow obj; in async functions.",
                "example": [
                    "// bad: does not get a stack trace.\nthrow 'oh noes!';\n// For promises\nnew Promise((resolve, reject) => void reject('oh noes!'));\nPromise.reject();\nPromise.reject('oh noes!');\n"
                ]
            },
            {
                "description": "Instead, only throw (subclasses of) Error:",
                "example": [
                    "// Throw only Errors\nthrow new Error('oh noes!');\n// ... or subtypes of Error.\nclass MyError extends Error {}\nthrow new MyError('my oh noes!');\n// For promises\nnew Promise((resolve) => resolve()); // No reject is OK.\nnew Promise((resolve, reject) => void reject(new Error('oh noes!')));\nPromise.reject(new Error('oh noes!'));\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Catching and rethrowing",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Catching and rethrowing",
        "cases": [
            {
                "description": "When catching errors, code should assume that all thrown errors are instances\nof Error.\nfunction assertIsError(e: unknown): asserts e is Error {\n  if (!(e instanceof Error)) throw new Error(\"e is not an Error\");\n}\n\ntry {\n  doSomething();\n} catch (e: unknown) {\n  // All thrown errors must be Error subtypes. Do not handle\n  // other possible values unless you know they are thrown.\n  assertIsError(e);\n  displayError(e.message);\n  // or rethrow:\n  throw e;\n}\n\nException handlers must not defensively handle non-Error types unless the\ncalled API is conclusively known to throw non-Errors in violation of the above\nrule. In that case, a comment should be included to specifically identify where\nthe non-Errors originate.",
                "example": [
                    "try {\n  badApiThrowingStrings();\n} catch (e: unknown) {\n  // Note: bad API throws strings instead of errors.\n  if (typeof e === 'string') { ... }\n}\n"
                ]
            },
            {
                "description": "\nWhy?\nAvoid\noverly defensive programming.\nRepeating the same defenses against a problem that will not exist in most code\nleads to boiler-plate code that is not useful.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Empty catch blocks",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Empty catch blocks",
        "cases": [
            {
                "description": "It is very rarely correct to do nothing in response to a caught exception. When\nit truly is appropriate to take no action whatsoever in a catch block, the\nreason this is justified is explained in a comment.",
                "example": [
                    "  try {\n    return handleNumericResponse(response);\n  } catch (e: unknown) {\n    // Response is not numeric. Continue to handle as text.\n  }\n  return handleTextResponse(response);\n"
                ]
            },
            {
                "description": "Disallowed:",
                "example": [
                    "  try {\n    shouldFail();\n    fail('expected an error');\n  } catch (expected: unknown) {\n  }\n"
                ]
            },
            {
                "description": "Tip: Unlike in some other languages, patterns like the above simply don’t work\nsince this will catch the error thrown by fail. Use assertThrows() instead.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Switch statements",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Switch statements",
        "cases": [
            {
                "description": "All switch statements must contain a default statement group, even if it\ncontains no code. The default statement group must be last.",
                "example": [
                    "switch (x) {\n  case Y:\n    doSomethingElse();\n    break;\n  default:\n    // nothing to do.\n}\n"
                ]
            },
            {
                "description": "Within a switch block, each statement group either terminates abruptly with a\nbreak, a return statement, or by throwing an exception. Non-empty statement\ngroups (case ...) must not fall through (enforced by the compiler):",
                "example": [
                    "switch (x) {\n  case X:\n    doSomething();\n    // fall through - not allowed!\n  case Y:\n    // ...\n}\n"
                ]
            },
            {
                "description": "Empty statement groups are allowed to fall through:",
                "example": [
                    "switch (x) {\n  case X:\n  case Y:\n    doSomething();\n    break;\n  default: // nothing to do.\n}\n"
                ]
            },
            {
                "description": "\n",
                "example": []
            }
        ]
    },
    {
        "title": "Equality checks",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Equality checks",
        "cases": [
            {
                "description": "Always use triple equals (===) and not equals (!==). The double equality\noperators cause error prone type coercions that are hard to understand and\nslower to implement for JavaScript Virtual Machines. See also the\nJavaScript equality table.",
                "example": [
                    "if (foo == 'bar' || baz != bam) {\n  // Hard to understand behaviour due to type coercion.\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "if (foo === 'bar' || baz !== bam) {\n  // All good here.\n}\n"
                ]
            },
            {
                "description": "Exception: Comparisons to the literal null value may use the == and\n!= operators to cover both null and undefined values.",
                "example": [
                    "if (foo == null) {\n  // Will trigger when foo is null or undefined.\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Type and non-nullability assertions",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions",
        "cases": [
            {
                "description": "Type assertions (x as SomeType) and non-nullability assertions (y!) are\nunsafe. Both only silence the TypeScript compiler, but do not insert any runtime\nchecks to match these assertions, so they can cause your program to crash at\nruntime.Because of this, you should not use type and non-nullability assertions\nwithout an obvious or explicit reason for doing so.Instead of the following:",
                "example": [
                    "(x as Foo).foo();\n\ny!.bar();\n"
                ]
            },
            {
                "description": "When you want to assert a type or non-nullability the best answer is to\nexplicitly write a runtime check that performs that check.",
                "example": [
                    "// assuming Foo is a class.\nif (x instanceof Foo) {\n  x.foo();\n}\n\nif (y) {\n  y.bar();\n}\n"
                ]
            },
            {
                "description": "Sometimes due to some local property of your code you can be sure that the\nassertion form is safe. In those situations, you should add clarification to\nexplain why you are ok with the unsafe behavior:",
                "example": [
                    "// x is a Foo, because ...\n(x as Foo).foo();\n\n// y cannot be null, because ...\ny!.bar();\n"
                ]
            },
            {
                "description": "If the reasoning behind a type or non-nullability assertion is obvious, the\ncomments may not be necessary. For example, generated proto code is always\nnullable, but perhaps it is well-known in the context of the code that certain\nfields are always provided by the backend. Use your judgement.",
                "example": []
            }
        ]
    },
    {
        "title": "Type assertion syntax",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Type assertion syntax",
        "cases": [
            {
                "description": "Type assertions must use the as syntax (as opposed to the angle brackets\nsyntax). This enforces parentheses around the assertion when accessing a member.",
                "example": [
                    "const x = (<Foo>z).length;\nconst y = <Foo>z.length;\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// z must be Foo because ...\nconst x = (z as Foo).length;\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Double assertions",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Double assertions",
        "cases": [
            {
                "description": "From the\nTypeScript handbook,\nTypeScript only allows type assertions which convert to a more specific or\nless specific version of a type. Adding a type assertion (x as Foo) which\ndoes not meet this criteria will give the error: Conversion of type 'X' to type\n'Y' may be a mistake because neither type sufficiently overlaps with the other.If you are sure an assertion is safe, you can perform a double assertion. This\ninvolves casting through unknown since it is less specific than all types.",
                "example": [
                    "// x is a Foo here, because...\n(x as unknown as Foo).fooMethod();\n"
                ]
            },
            {
                "description": "Use unknown (instead of any or {}) as the intermediate type.",
                "example": []
            }
        ]
    },
    {
        "title": "Type assertions and object literals",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Type assertions and object literals",
        "cases": [
            {
                "description": "Use type annotations (: Foo) instead of type assertions (as Foo) to specify\nthe type of an object literal. This allows detecting refactoring bugs when the\nfields of an interface change over time.",
                "example": [
                    "interface Foo {\n  bar: number;\n  baz?: string;  // was \"bam\", but later renamed to \"baz\".\n}\n\nconst foo = {\n  bar: 123,\n  bam: 'abc',  // no error!\n} as Foo;\n\nfunction func() {\n  return {\n    bar: 123,\n    bam: 'abc',  // no error!\n  } as Foo;\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "interface Foo {\n  bar: number;\n  baz?: string;\n}\n\nconst foo: Foo = {\n  bar: 123,\n  bam: 'abc',  // complains about \"bam\" not being defined on Foo.\n};\n\nfunction func(): Foo {\n  return {\n    bar: 123,\n    bam: 'abc',   // complains about \"bam\" not being defined on Foo.\n  };\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Keep try blocks focused",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Keep try blocks focused",
        "cases": [
            {
                "description": "Limit the amount of code inside a try block, if this can be done without hurting\nreadability.",
                "example": [
                    "try {\n  const result = methodThatMayThrow();\n  use(result);\n} catch (error: unknown) {\n  // ...\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "let result;\ntry {\n  result = methodThatMayThrow();\n} catch (error: unknown) {\n  // ...\n}\nuse(result);\n"
                ]
            },
            {
                "description": "Moving the non-throwable lines out of the try/catch block helps the reader learn\nwhich method throws exceptions. Some inline calls that do not throw exceptions\ncould stay inside because they might not be worth the extra complication of a\ntemporary variable.Exception: There may be performance issues if try blocks are inside a loop.\nWidening try blocks to cover a whole loop is ok.",
                "example": []
            }
        ]
    },
    {
        "title": "Decorators",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Decorators",
        "cases": [
            {
                "description": "Decorators are syntax with an @ prefix, like @MyDecorator.Do not define new decorators. Only use the decorators defined by\nframeworks:\nAngular (e.g. @Component, @NgModule, etc.)\nPolymer (e.g. @property)\n\nWhy?\nWe generally want to avoid decorators, because they were an experimental feature\nthat have since diverged from the TC39 proposal and have known bugs that won't\nbe fixed.\nWhen using decorators, the decorator must immediately precede the symbol it\ndecorates, with no empty lines between:",
                "example": [
                    "/** JSDoc comments go before decorators */\n@Component({...})  // Note: no empty line after the decorator.\nclass MyComp {\n  @Input() myField: string;  // Decorators on fields may be on the same line...\n\n  @Input()\n  myOtherField: string;  // ... or wrap.\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Disallowed features",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Disallowed features",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Wrapper objects for primitive types",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Disallowed features/Wrapper objects for primitive types",
        "cases": [
            {
                "description": "TypeScript code must not instantiate the wrapper classes for the primitive\ntypes String, Boolean, and Number. Wrapper classes have surprising\nbehavior, such as new Boolean(false) evaluating to true.",
                "example": [
                    "const s = new String('hello');\nconst b = new Boolean(false);\nconst n = new Number(5);\n"
                ]
            },
            {
                "description": "The wrappers may be called as functions for coercing (which is preferred over\nusing + or concatenating the empty string) or creating symbols. See\ntype coercion for more information.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Automatic Semicolon Insertion",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Disallowed features/Automatic Semicolon Insertion",
        "cases": [
            {
                "description": "Do not rely on Automatic Semicolon Insertion (ASI). Explicitly end all\nstatements using a semicolon. This prevents bugs due to incorrect semicolon\ninsertions and ensures compatibility with tools with limited ASI support (e.g.\nclang-format).",
                "example": []
            }
        ]
    },
    {
        "title": "Const enums",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Disallowed features/Const enums",
        "cases": [
            {
                "description": "Code must not use const enum; use plain enum instead.\nWhy?\nTypeScript enums already cannot be mutated; const enum is a separate language\nfeature related to optimization that makes the enum invisible to\nJavaScript users of the module.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Debugger statements",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Disallowed features/Debugger statements",
        "cases": [
            {
                "description": "Debugger statements must not be included in production code.",
                "example": [
                    "function debugMe() {\n  debugger;\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "with",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Disallowed features/with",
        "cases": [
            {
                "description": "Do not use the with keyword. It makes your code harder to understand and\nhas been banned in strict mode since ES5.",
                "example": []
            }
        ]
    },
    {
        "title": "Dynamic code evaluation",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Disallowed features/Dynamic code evaluation",
        "cases": [
            {
                "description": "Do not use eval or the Function(...string) constructor (except for code\nloaders). These features are potentially dangerous and simply do not work in\nenvironments using strict\nContent Security Policies.",
                "example": []
            }
        ]
    },
    {
        "title": "Non-standard features",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Disallowed features/Non-standard features",
        "cases": [
            {
                "description": "Do not use non-standard ECMAScript or Web Platform features.This includes:\nOld features that have been marked deprecated or removed entirely from\nECMAScript / the Web Platform (see\nMDN)\nNew ECMAScript features that are not yet standardized\n\nAvoid using features that are in current TC39 working draft or currently\nin the proposal process\nUse only ECMAScript features defined in the current ECMA-262\nspecification\n\nProposed but not-yet-complete web standards:\n\nWHATWG proposals that have not completed the\nproposal process.\n\nNon-standard language “extensions” (such as those provided by some external\ntranspilers)\nProjects targeting specific JavaScript runtimes, such as latest-Chrome-only,\nChrome extensions, Node.JS, Electron, can obviously use those APIs. Use caution\nwhen considering an API surface that is proprietary and only implemented in some\nbrowsers; consider whether there is a common library that can abstract this API\nsurface away for you.",
                "example": []
            }
        ]
    },
    {
        "title": "Modifying builtin objects",
        "belongs to": "Language features/Local variable declarations/Array literals/Object literals/Classes/Class method declarations/Static methods/Class members/Disallowed class patterns/Functions/Primitive literals/String literals/Type coercion/Control structures/Control flow statements and blocks/Exception handling/Type and non-nullability assertions/Disallowed features/Modifying builtin objects",
        "cases": [
            {
                "description": "Never modify builtin types, either by adding methods to their constructors or to\ntheir prototypes. Avoid depending on libraries that do\nthis.Do not add symbols to the global object unless absolutely necessary (e.g.\nrequired by a third-party API).\n",
                "example": []
            }
        ]
    },
    {
        "title": "Naming",
        "belongs to": "Naming",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Identifiers",
        "belongs to": "Naming/Identifiers",
        "cases": [
            {
                "description": "Identifiers must use only ASCII letters, digits, underscores (for constants\nand structured test method names), and (rarely) the '$' sign.",
                "example": []
            }
        ]
    },
    {
        "title": "Naming style",
        "belongs to": "Naming/Identifiers/Naming style",
        "cases": [
            {
                "description": "TypeScript expresses information in types, so names should not be decorated\nwith information that is included in the type. (See also\nTesting Blog\n for more about what\nnot to include.)Some concrete examples of this rule:\nDo not use trailing or leading underscores for private properties or\nmethods.\nDo not use the opt_ prefix for optional parameters.\n\nFor accessors, see accessor rules\nbelow.\n\nDo not mark interfaces specially (IMyInterface or\nMyFooInterface) unless it's idiomatic in its\nenvironment. When\nintroducing an interface for a class, give it a name that expresses why the\ninterface exists in the first place (e.g. class TodoItem and interface\nTodoItemStorage if the interface expresses the format used for\nstorage/serialization in JSON).\nSuffixing Observables with $ is a common external convention and can\nhelp resolve confusion regarding observable values vs concrete values.\nJudgement on whether this is a useful convention is left up to individual\nteams, but should be consistent within projects.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Descriptive names",
        "belongs to": "Naming/Identifiers/Descriptive names",
        "cases": [
            {
                "description": "Names must be descriptive and clear to a new reader. Do not use abbreviations\nthat are ambiguous or unfamiliar to readers outside your project, and do not\nabbreviate by deleting letters within a word.\nException: Variables that are in scope for 10 lines or fewer, including\narguments that are not part of an exported API, may use short (e.g.\nsingle letter) variable names.\n",
                "example": [
                    "// Good identifiers:\nerrorCount          // No abbreviation.\ndnsConnectionIndex  // Most people know what \"DNS\" stands for.\nreferrerUrl         // Ditto for \"URL\".\ncustomerId          // \"Id\" is both ubiquitous and unlikely to be misunderstood.\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// Disallowed identifiers:\nn                   // Meaningless.\nnErr                // Ambiguous abbreviation.\nnCompConns          // Ambiguous abbreviation.\nwgcConnections      // Only your group knows what this stands for.\npcReader            // Lots of things can be abbreviated \"pc\".\ncstmrId             // Deletes internal letters.\nkSecondsPerDay      // Do not use Hungarian notation.\ncustomerID          // Incorrect camelcase of \"ID\".\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Camel case",
        "belongs to": "Naming/Identifiers/Camel case",
        "cases": [
            {
                "description": "\nTreat abbreviations like acronyms in names as whole words, i.e. use\nloadHttpUrl, not loadHTTPURL, unless required by a platform name (e.g.\nXMLHttpRequest).",
                "example": []
            }
        ]
    },
    {
        "title": "Dollar sign",
        "belongs to": "Naming/Identifiers/Dollar sign",
        "cases": [
            {
                "description": "Identifiers should not generally use $, except when required by naming\nconventions for third party frameworks. See above for more on\nusing $ with Observable values.\n\n\n\n\n\n",
                "example": []
            }
        ]
    },
    {
        "title": "Rules by identifier type",
        "belongs to": "Naming/Identifiers/Rules by identifier type",
        "cases": [
            {
                "description": "Most identifier names should follow the casing in the table below, based on the\nidentifier's type.\n\n\nStyle\nCategory\n\n\n\n\nUpperCamelCase\n\nclass / interface / type / enum / decorator / type\nparameters / component functions in TSX / JSXElement type\nparameter\n\n\nlowerCamelCase\n\nvariable / parameter / function / method / property /\nmodule alias\n\n\nCONSTANT_CASE\n\nglobal constant values, including enum values. See\nConstants below.\n\n\n#ident\nprivate identifiers are never used.\n\n\n",
                "example": []
            }
        ]
    },
    {
        "title": "Type parameters",
        "belongs to": "Naming/Identifiers/Rules by identifier type/Type parameters",
        "cases": [
            {
                "description": "Type parameters, like in Array<T>, may use a single upper case character\n(T) or UpperCamelCase.",
                "example": []
            }
        ]
    },
    {
        "title": "Test names",
        "belongs to": "Naming/Identifiers/Rules by identifier type/Test names",
        "cases": [
            {
                "description": "Test method names inxUnit-style test frameworks may be structured with _ separators, e.g.\ntestX_whenY_doesZ().",
                "example": []
            }
        ]
    },
    {
        "title": "_ prefix/suffix",
        "belongs to": "Naming/Identifiers/Rules by identifier type/_ prefix/suffix",
        "cases": [
            {
                "description": "Identifiers must not use _ as a prefix or suffix.This also means that _ must not be used as an identifier by itself (e.g. to\nindicate a parameter is unused).\nTip: If you only need some of the elements from an array (or TypeScript\ntuple), you can insert extra commas in a destructuring statement to ignore\nin-between elements:\nconst [a, , b] = [1, 5, 10];  // a <- 1, b <- 10\n\n",
                "example": []
            }
        ]
    },
    {
        "title": "Imports",
        "belongs to": "Naming/Identifiers/Rules by identifier type/Imports",
        "cases": [
            {
                "description": "Module namespace imports are lowerCamelCase while files are snake_case,\nwhich means that imports correctly will not match in casing style, such as",
                "example": [
                    "import * as fooBar from './foo_bar';\n"
                ]
            },
            {
                "description": "Some libraries might commonly use a namespace import prefix that violates this\nnaming scheme, but overbearingly common open source use makes the violating\nstyle more readable. The only libraries that currently fall under this exception\nare:\njquery, using the $ prefix\nthreejs, using the THREE prefix\n",
                "example": []
            }
        ]
    },
    {
        "title": "Constants",
        "belongs to": "Naming/Identifiers/Rules by identifier type/Constants",
        "cases": [
            {
                "description": "Immutable: CONSTANT_CASE indicates that a value is intended to not be\nchanged, and may be used for values that can technically be modified (i.e.\nvalues that are not deeply frozen) to indicate to users that they must not be\nmodified.",
                "example": [
                    "const UNIT_SUFFIXES = {\n  'milliseconds': 'ms',\n  'seconds': 's',\n};\n// Even though per the rules of JavaScript UNIT_SUFFIXES is\n// mutable, the uppercase shows users to not modify it.\n"
                ]
            },
            {
                "description": "A constant can also be a static readonly property of a class.",
                "example": [
                    "class Foo {\n  private static readonly MY_SPECIAL_NUMBER = 5;\n\n  bar() {\n    return 2 * Foo.MY_SPECIAL_NUMBER;\n  }\n}\n"
                ]
            },
            {
                "description": "Global: Only symbols declared on the module level, static fields of module\nlevel classes, and values of module level enums, may use CONST_CASE. If a\nvalue can be instantiated more than once over the lifetime of the program (e.g.\na local variable declared within a function, or a static field on a class nested\nin a function) then it must use lowerCamelCase.If a value is an arrow function that implements an interface, then it may be\ndeclared lowerCamelCase.",
                "example": []
            }
        ]
    },
    {
        "title": "Aliases",
        "belongs to": "Naming/Identifiers/Rules by identifier type/Aliases",
        "cases": [
            {
                "description": "When creating a local-scope alias of an existing symbol, use the format of the\nexisting identifier. The local alias must match the existing naming and format\nof the source. For variables use const for your local aliases, and for class\nfields use the readonly attribute.\nNote: If you're creating an alias just to expose it to a template in your\nframework of choice, remember to also apply the proper\naccess modifiers.\n",
                "example": [
                    "const {BrewStateEnum} = SomeType;\nconst CAPACITY = 5;\n\nclass Teapot {\n  readonly BrewStateEnum = BrewStateEnum;\n  readonly CAPACITY = CAPACITY;\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Type system",
        "belongs to": "Type system",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Type inference",
        "belongs to": "Type system/Type inference",
        "cases": [
            {
                "description": "Code may rely on type inference as implemented by the TypeScript compiler for\nall type expressions (variables, fields, return types, etc).\n",
                "example": [
                    "const x = 15;  // Type inferred.\n"
                ]
            },
            {
                "description": "Leave out type annotations for trivially inferred types: variables or parameters\ninitialized to a string, number, boolean, RegExp literal or new\nexpression.",
                "example": [
                    "const x: boolean = true;  // Bad: 'boolean' here does not aid readability\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// Bad: 'Set' is trivially inferred from the initialization\nconst x: Set<string> = new Set();\n"
                ]
            },
            {
                "description": "Explicitly specifying types may be required to prevent generic type parameters\nfrom being inferred as unknown. For example, initializing generic types with\nno values (e.g. empty arrays, objects, Maps, or Sets).",
                "example": [
                    "const x = new Set<string>();\n"
                ]
            },
            {
                "description": "For more complex expressions, type annotations can help with readability of the\nprogram:",
                "example": [
                    "// Hard to reason about the type of 'value' without an annotation.\nconst value = await rpc.getSomeValue().transform();\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// Can tell the type of 'value' at a glance.\nconst value: string[] = await rpc.getSomeValue().transform();\n"
                ]
            },
            {
                "description": "Whether an annotation is required is decided by the code reviewer.",
                "example": []
            }
        ]
    },
    {
        "title": "Return types",
        "belongs to": "Type system/Type inference/Return types",
        "cases": [
            {
                "description": "Whether to include return type annotations for functions and methods is up to\nthe code author. Reviewers may ask for annotations to clarify complex return\ntypes that are hard to understand. Projects may have a local policy to always\nrequire return types, but this is not a general TypeScript style requirement.There are two benefits to explicitly typing out the implicit return values of\nfunctions and methods:\nMore precise documentation to benefit readers of the code.\nSurface potential type errors faster in the future if there are code changes\nthat change the return type of the function.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Undefined and null",
        "belongs to": "Type system/Type inference/Undefined and null",
        "cases": [
            {
                "description": "TypeScript supports undefined and null types. Nullable types can be\nconstructed as a union type (string|null); similarly with undefined. There\nis no special syntax for unions of undefined and null.TypeScript code can use either undefined or null to denote absence of a\nvalue, there is no general guidance to prefer one over the other. Many\nJavaScript APIs use undefined (e.g. Map.get), while many DOM and Google APIs\nuse null (e.g. Element.getAttribute), so the appropriate absent value\ndepends on the context.",
                "example": []
            }
        ]
    },
    {
        "title": "Nullable/undefined type aliases",
        "belongs to": "Type system/Type inference/Undefined and null/Nullable/undefined type aliases",
        "cases": [
            {
                "description": "Type aliases must not include |null or |undefined in a union type.\nNullable aliases typically indicate that null values are being passed around\nthrough too many layers of an application, and this clouds the source of the\noriginal issue that resulted in null. They also make it unclear when specific\nvalues on a class or interface might be absent.Instead, code must only add |null or |undefined when the alias is actually\nused. Code should deal with null values close to where they arise, using the\nabove techniques.",
                "example": [
                    "// Bad\ntype CoffeeResponse = Latte|Americano|undefined;\n\nclass CoffeeService {\n  getLatte(): CoffeeResponse { ... };\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "// Better\ntype CoffeeResponse = Latte|Americano;\n\nclass CoffeeService {\n  getLatte(): CoffeeResponse|undefined { ... };\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Prefer optional over |undefined",
        "belongs to": "Type system/Type inference/Undefined and null/Prefer optional over |undefined",
        "cases": [
            {
                "description": "In addition, TypeScript supports a special construct for optional parameters and\nfields, using ?:",
                "example": [
                    "interface CoffeeOrder {\n  sugarCubes: number;\n  milk?: Whole|LowFat|HalfHalf;\n}\n\nfunction pourCoffee(volume?: Milliliter) { ... }\n"
                ]
            },
            {
                "description": "Optional parameters implicitly include |undefined in their type. However, they\nare different in that they can be left out when constructing a value or calling\na method. For example, {sugarCubes: 1} is a valid CoffeeOrder because milk\nis optional.Use optional fields (on interfaces or classes) and parameters rather than a\n|undefined type.For classes preferably avoid this pattern altogether and initialize as many\nfields as possible.",
                "example": [
                    "class MyClass {\n  field = '';\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Use structural types",
        "belongs to": "Type system/Type inference/Undefined and null/Use structural types",
        "cases": [
            {
                "description": "TypeScript's type system is structural, not nominal. That is, a value matches a\ntype if it has at least all the properties the type requires and the properties'\ntypes match, recursively.When providing a structural-based implementation, explicitly include the type at\nthe declaration of the symbol (this allows more precise type checking and error\nreporting).",
                "example": [
                    "const foo: Foo = {\n  a: 123,\n  b: 'abc',\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "const badFoo = {\n  a: 123,\n  b: 'abc',\n}\n"
                ]
            },
            {
                "description": "Use interfaces to define structural types, not classes",
                "example": [
                    "interface Foo {\n  a: number;\n  b: string;\n}\n\nconst foo: Foo = {\n  a: 123,\n  b: 'abc',\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "class Foo {\n  readonly a: number;\n  readonly b: number;\n}\n\nconst foo: Foo = {\n  a: 123,\n  b: 'abc',\n}\n"
                ]
            },
            {
                "description": "\nWhy?\nThe badFoo object above relies on type inference. Additional fields could be\nadded to badFoo and the type is inferred based on the object itself.\nWhen passing a badFoo to a function that takes a Foo, the error will be at\nthe function call site, rather than at the object declaration site. This is also\nuseful when changing the surface of an interface across broad codebases.\ninterface Animal {\n  sound: string;\n  name: string;\n}\n\nfunction makeSound(animal: Animal) {}\n\n/**\n * 'cat' has an inferred type of '{sound: string}'\n */\nconst cat = {\n  sound: 'meow',\n};\n\n/**\n * 'cat' does not meet the type contract required for the function, so the\n * TypeScript compiler errors here, which may be very far from where 'cat' is\n * defined.\n */\nmakeSound(cat);\n\n/**\n * Horse has a structural type and the type error shows here rather than the\n * function call.  'horse' does not meet the type contract of 'Animal'.\n */\nconst horse: Animal = {\n  sound: 'niegh',\n};\n\nconst dog: Animal = {\n  sound: 'bark',\n  name: 'MrPickles',\n};\n\nmakeSound(dog);\nmakeSound(horse);\n\n",
                "example": []
            }
        ]
    },
    {
        "title": "Prefer interfaces over type literal aliases",
        "belongs to": "Type system/Type inference/Undefined and null/Prefer interfaces over type literal aliases",
        "cases": [
            {
                "description": "TypeScript supports\ntype aliases\nfor naming a type expression. This can be used to name primitives, unions,\ntuples, and any other types.However, when declaring types for objects, use interfaces instead of a type\nalias for the object literal expression.",
                "example": [
                    "interface User {\n  firstName: string;\n  lastName: string;\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "type User = {\n  firstName: string,\n  lastName: string,\n}\n"
                ]
            },
            {
                "description": "\nWhy?\nThese forms are nearly equivalent, so under the principle of just choosing one\nout of two forms to prevent variation, we should choose one. Additionally, there\nare also\ninteresting technical reasons to prefer interface.\nThat page quotes the TypeScript team lead: Honestly, my take is that it should\nreally just be interfaces for anything that they can model. There is no benefit\nto type aliases when there are so many issues around display/perf.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Array<T> Type",
        "belongs to": "Type system/Type inference/Undefined and null/Array<T> Type",
        "cases": [
            {
                "description": "For simple types (containing just alphanumeric characters and dot), use the\nsyntax sugar for arrays, T[] or readonly T[], rather than the longer form\nArray<T> or ReadonlyArray<T>.For multi-dimensional non-readonly arrays of simple types, use the syntax\nsugar form (T[][], T[][][], and so on) rather than the longer form.For anything more complex, use the longer form Array<T>.These rules apply at each level of nesting, i.e. a simple T[] nested in a more\ncomplex type would still be spelled as T[], using the syntax sugar.",
                "example": [
                    "let a: string[];\nlet b: readonly string[];\nlet c: ns.MyObj[];\nlet d: string[][];\nlet e: Array<{n: number, s: string}>;\nlet f: Array<string|number>;\nlet g: ReadonlyArray<string|number>;\nlet h: InjectionToken<string[]>;  // Use syntax sugar for nested types.\nlet i: ReadonlyArray<string[]>;\nlet j: Array<readonly string[]>;\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "let a: Array<string>;  // The syntax sugar is shorter.\nlet b: ReadonlyArray<string>;\nlet c: Array<ns.MyObj>;\nlet d: Array<string[]>;\nlet e: {n: number, s: string}[];  // The braces make it harder to read.\nlet f: (string|number)[];         // Likewise with parens.\nlet g: readonly (string | number)[];\nlet h: InjectionToken<Array<string>>;\nlet i: readonly string[][];\nlet j: (readonly string[])[];\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Indexable types / index signatures ({[key: string]: T})",
        "belongs to": "Type system/Type inference/Undefined and null/Indexable types / index signatures ({[key: string]: T})",
        "cases": [
            {
                "description": "In JavaScript, it's common to use an object as an associative array (aka map,\nhash, or dict). Such objects can be typed using an\nindex signature\n([k: string]: T) in TypeScript:",
                "example": [
                    "const fileSizes: {[fileName: string]: number} = {};\nfileSizes['readme.txt'] = 541;\n"
                ]
            },
            {
                "description": "In TypeScript, provide a meaningful label for the key. (The label only exists\nfor documentation; it's unused otherwise.)",
                "example": [
                    "const users: {[key: string]: number} = ...;\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "const users: {[userName: string]: number} = ...;\n"
                ]
            },
            {
                "description": "\nRather than using one of these, consider using the ES6 Map and Set types\ninstead. JavaScript objects have\nsurprising undesirable behaviors\nand the ES6 types more explicitly convey your intent. Also, Maps can be\nkeyed by—and Sets can contain—types other than string.\nTypeScript's builtin Record<Keys, ValueType> type allows constructing types\nwith a defined set of keys. This is distinct from associative arrays in that the\nkeys are statically known. See advice on that\nbelow.",
                "example": []
            }
        ]
    },
    {
        "title": "Mapped and conditional types",
        "belongs to": "Type system/Type inference/Undefined and null/Mapped and conditional types",
        "cases": [
            {
                "description": "TypeScript's\nmapped types\nand\nconditional types\nallow specifying new types based on other types. TypeScript's standard library\nincludes several type operators based on these (Record, Partial, Readonly\netc).These type system features allow succinctly specifying types and constructing\npowerful yet type safe abstractions. They come with a number of drawbacks\nthough:\nCompared to explicitly specifying properties and type relations (e.g. using\ninterfaces and extension, see below for an example), type operators require\nthe reader to mentally evaluate the type expression. This can make programs\nsubstantially harder to read, in particular combined with type inference and\nexpressions crossing file boundaries.\nMapped & conditional types' evaluation model, in particular when combined\nwith type inference, is underspecified, not always well understood, and\noften subject to change in TypeScript compiler versions. Code can\naccidentally compile or seem to give the right results. This increases\nfuture support cost of code using type operators.\nMapped & conditional types are most powerful when deriving types from\ncomplex and/or inferred types. On the flip side, this is also when they are\nmost prone to create hard to understand and maintain programs.\nSome language tooling does not work well with these type system features.\nE.g. your IDE's find references (and thus rename property refactoring) will\nnot find properties in a Pick<T, Keys> type, and Code Search won't\nhyperlink them.\n\nThe style recommendation is:\nAlways use the simplest type construct that can possibly express your code.\nA little bit of repetition or verbosity is often much cheaper than the long\nterm cost of complex type expressions.\nMapped & conditional types may be used, subject to these considerations.\nFor example, TypeScript's builtin Pick<T, Keys> type allows creating a new\ntype by subsetting another type T, but simple interface extension can often be\neasier to understand.",
                "example": [
                    "interface User {\n  shoeSize: number;\n  favoriteIcecream: string;\n  favoriteChocolate: string;\n}\n\n// FoodPreferences has favoriteIcecream and favoriteChocolate, but not shoeSize.\ntype FoodPreferences = Pick<User, 'favoriteIcecream'|'favoriteChocolate'>;\n"
                ]
            },
            {
                "description": "This is equivalent to spelling out the properties on FoodPreferences:",
                "example": [
                    "interface FoodPreferences {\n  favoriteIcecream: string;\n  favoriteChocolate: string;\n}\n"
                ]
            },
            {
                "description": "To reduce duplication, User could extend FoodPreferences, or (possibly\nbetter) nest a field for food preferences:",
                "example": [
                    "interface FoodPreferences { /* as above */ }\ninterface User extends FoodPreferences {\n  shoeSize: number;\n  // also includes the preferences.\n}\n"
                ]
            },
            {
                "description": "Using interfaces here makes the grouping of properties explicit, improves IDE\nsupport, allows better optimization, and arguably makes the code easier to\nunderstand.",
                "example": []
            }
        ]
    },
    {
        "title": "any Type",
        "belongs to": "Type system/Type inference/Undefined and null/any Type",
        "cases": [
            {
                "description": "TypeScript's any type is a super and subtype of all other types, and allows\ndereferencing all properties. As such, any is dangerous - it can mask severe\nprogramming errors, and its use undermines the value of having static types in\nthe first place.\nConsider not to use any. In circumstances where you want to use any,\nconsider one of:\n\nProvide a more specific type\nUse unknown\nSuppress the lint warning and document why\n",
                "example": []
            }
        ]
    },
    {
        "title": "Providing a more specific type",
        "belongs to": "Type system/Type inference/Undefined and null/any Type/Providing a more specific type",
        "cases": [
            {
                "description": "Use interfaces , an\ninline object type, or a type alias:",
                "example": [
                    "// Use declared interfaces to represent server-side JSON.\ndeclare interface MyUserJson {\n  name: string;\n  email: string;\n}\n\n// Use type aliases for types that are repetitive to write.\ntype MyType = number|string;\n\n// Or use inline object types for complex returns.\nfunction getTwoThings(): {something: number, other: string} {\n  // ...\n  return {something, other};\n}\n\n// Use a generic type, where otherwise a library would say `any` to represent\n// they don't care what type the user is operating on (but note \"Return type\n// only generics\" below).\nfunction nicestElement<T>(items: T[]): T {\n  // Find the nicest element in items.\n  // Code can also put constraints on T, e.g. <T extends HTMLElement>.\n}\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Using unknown over any",
        "belongs to": "Type system/Type inference/Undefined and null/any Type/Using unknown over any",
        "cases": [
            {
                "description": "The any type allows assignment into any other type and dereferencing any\nproperty off it. Often this behaviour is not necessary or desirable, and code\njust needs to express that a type is unknown. Use the built-in type unknown in\nthat situation — it expresses the concept and is much safer as it does not allow\ndereferencing arbitrary properties.",
                "example": [
                    "// Can assign any value (including null or undefined) into this but cannot\n// use it without narrowing the type or casting.\nconst val: unknown = value;\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "const danger: any = value /* result of an arbitrary expression */;\ndanger.whoops();  // This access is completely unchecked!\n"
                ]
            },
            {
                "description": "\nTo safely use unknown values, narrow the type using a\ntype guard\n",
                "example": []
            }
        ]
    },
    {
        "title": "Suppressing any lint warnings",
        "belongs to": "Type system/Type inference/Undefined and null/any Type/Suppressing any lint warnings",
        "cases": [
            {
                "description": "Sometimes using any is legitimate, for example in tests to construct a mock\nobject. In such cases, add a comment that suppresses the lint warning, and\ndocument why it is legitimate.",
                "example": [
                    "// This test only needs a partial implementation of BookService, and if\n// we overlooked something the test will fail in an obvious way.\n// This is an intentionally unsafe partial mock\n// tslint:disable-next-line:no-any\nconst mockBookService = ({get() { return mockBook; }} as any) as BookService;\n// Shopping cart is not used in this test\n// tslint:disable-next-line:no-any\nconst component = new MyComponent(mockBookService, /* unused ShoppingCart */ null as any);\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "{} Type",
        "belongs to": "Type system/Type inference/Undefined and null/any Type/{} Type",
        "cases": [
            {
                "description": "The {} type, also known as an empty interface type, represents a interface\nwith no properties. An empty interface type has no specified properties and\ntherefore any non-nullish value is assignable to it.",
                "example": [
                    "let player: {};\n\nplayer = {\n  health: 50,\n}; // Allowed.\n\nconsole.log(player.health) // Property 'health' does not exist on type '{}'.\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "function takeAnything(obj:{}) {\n\n}\n\ntakeAnything({});\ntakeAnything({ a: 1, b: 2 });\n"
                ]
            },
            {
                "description": "Google3 code should not use {} for most use cases. {} represents any\nnon-nullish primitive or object type, which is rarely appropriate. Prefer one of\nthe following more-descriptive types:\nunknown can hold any value, including null or undefined, and is\ngenerally more appropriate for opaque values.\nRecord<string, T> is better for dictionary-like objects, and provides\nbetter type safety by being explicit about the type T of contained values\n(which may itself be unknown).\nobject excludes primitives as well, leaving only non-nullish functions and\nobjects, but without any other assumptions about what properties may be\navailable.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Tuple types",
        "belongs to": "Type system/Type inference/Undefined and null/any Type/Tuple types",
        "cases": [
            {
                "description": "If you are tempted to create a Pair type, instead use a tuple type:",
                "example": [
                    "interface Pair {\n  first: string;\n  second: string;\n}\nfunction splitInHalf(input: string): Pair {\n  ...\n  return {first: x, second: y};\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "function splitInHalf(input: string): [string, string] {\n  ...\n  return [x, y];\n}\n\n// Use it like:\nconst [leftHalf, rightHalf] = splitInHalf('my string');\n"
                ]
            },
            {
                "description": "However, often it's clearer to provide meaningful names for the properties.If declaring an interface is too heavyweight, you can use an inline object\nliteral type:",
                "example": [
                    "function splitHostPort(address: string): {host: string, port: number} {\n  ...\n}\n\n// Use it like:\nconst address = splitHostPort(userAddress);\nuse(address.port);\n\n// You can also get tuple-like behavior using destructuring:\nconst {host, port} = splitHostPort(userAddress);\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Wrapper types",
        "belongs to": "Type system/Type inference/Undefined and null/any Type/Wrapper types",
        "cases": [
            {
                "description": "There are a few types related to JavaScript primitives that should not ever be\nused:\nString, Boolean, and Number have slightly different meaning from the\ncorresponding primitive types string, boolean, and number. Always use\nthe lowercase version.\nObject has similarities to both {} and object, but is slightly looser.\nUse {} for a type that include everything except null and undefined,\nor lowercase object to further exclude the other primitive types (the\nthree mentioned above, plus symbol and bigint).\nFurther, never invoke the wrapper types as constructors (with new).",
                "example": []
            }
        ]
    },
    {
        "title": "Return type only generics",
        "belongs to": "Type system/Type inference/Undefined and null/any Type/Return type only generics",
        "cases": [
            {
                "description": "Avoid creating APIs that have return type only generics. When working with\nexisting APIs that have return type only generics always explicitly specify the\ngenerics.",
                "example": []
            }
        ]
    },
    {
        "title": "Toolchain requirements",
        "belongs to": "Toolchain requirements",
        "cases": [
            {
                "description": "Google style requires using a number of tools in specific ways, outlined here.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "example": []
            }
        ]
    },
    {
        "title": "TypeScript compiler",
        "belongs to": "Toolchain requirements/TypeScript compiler",
        "cases": [
            {
                "description": "All TypeScript files must pass type checking using the standard\n tool chain.",
                "example": []
            }
        ]
    },
    {
        "title": "@ts-ignore",
        "belongs to": "Toolchain requirements/TypeScript compiler/@ts-ignore",
        "cases": [
            {
                "description": "Do not use @ts-ignore nor the variants @ts-expect-error or @ts-nocheck.\nWhy?\nThey superficially seem to be an easy way to fix a compiler error, but in\npractice, a specific compiler error is often caused by a larger problem that can\nbe fixed more directly.\nFor example, if you are using @ts-ignore to suppress a type error, then it's\nhard to predict what types the surrounding code will end up seeing. For many\ntype errors, the advice in how to best use any is useful.\nYou may use @ts-expect-error in unit tests, though you generally should not.\n@ts-expect-error suppresses all errors. It's easy to accidentally over-match\nand suppress more serious errors. Consider one of:\nWhen testing APIs that need to deal with unchecked values at runtime, add\ncasts to the expected type or to any and add an explanatory comment. This\nlimits error suppression to a single expression.\nSuppress the lint warning and document why, similar to\nsuppressing any lint warnings.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Conformance",
        "belongs to": "Toolchain requirements/TypeScript compiler/Conformance",
        "cases": [
            {
                "description": "Google TypeScript includes several conformance frameworks,\n\ntsetse and\ntsec.These rules are commonly used to enforce critical restrictions (such as defining\nglobals, which could break the codebase) and security patterns (such as using\neval or assigning to innerHTML), or more loosely to improve code quality.Google-style TypeScript must abide by any applicable global or framework-local\nconformance rules.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Comments and documentation",
        "belongs to": "Comments and documentation",
        "cases": [
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "JSDoc versus comments",
        "belongs to": "Comments and documentation/JSDoc versus comments",
        "cases": [
            {
                "description": "There are two types of comments, JSDoc (/** ... */) and non-JSDoc ordinary\ncomments (// ... or /* ... */).\nUse /** JSDoc */ comments for documentation, i.e. comments a user of the\ncode should read.\nUse // line comments for implementation comments, i.e. comments that only\nconcern the implementation of the code itself.\nJSDoc comments are understood by tools (such as editors and documentation\ngenerators), while ordinary comments are only for other humans.",
                "example": []
            }
        ]
    },
    {
        "title": "Multi-line comments",
        "belongs to": "Comments and documentation/Multi-line comments",
        "cases": [
            {
                "description": "Multi-line comments are indented at the same level as the surrounding code. They\nmust use multiple single-line comments (//-style), not block comment style\n(/* */).",
                "example": [
                    "// This is\n// fine\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "/*\n * This should\n * use multiple\n * single-line comments\n */\n\n/* This should use // */\n"
                ]
            },
            {
                "description": "Comments are not enclosed in boxes drawn with asterisks or other characters.",
                "example": []
            }
        ]
    },
    {
        "title": "JSDoc general form",
        "belongs to": "Comments and documentation/JSDoc general form",
        "cases": [
            {
                "description": "The basic formatting of JSDoc comments is as seen in this example:",
                "example": [
                    "/**\n * Multiple lines of JSDoc text are written here,\n * wrapped normally.\n * @param arg A number to do something to.\n */\nfunction doSomething(arg: number) { … }\n"
                ]
            },
            {
                "description": "or in this single-line example:",
                "example": [
                    "/** This short jsdoc describes the function. */\nfunction doSomething(arg: number) { … }\n"
                ]
            },
            {
                "description": "If a single-line comment overflows into multiple lines, it must use the\nmulti-line style with /** and */ on their own lines.Many tools extract metadata from JSDoc comments to perform code validation and\noptimization. As such, these comments must be well-formed.",
                "example": []
            }
        ]
    },
    {
        "title": "Markdown",
        "belongs to": "Comments and documentation/Markdown",
        "cases": [
            {
                "description": "JSDoc is written in Markdown, though it may include HTML when necessary.This means that tooling parsing JSDoc will ignore plain text formatting, so if\nyou did this:",
                "example": [
                    "/**\n * Computes weight based on three factors:\n *   items sent\n *   items received\n *   last timestamp\n */\n"
                ]
            },
            {
                "description": "it will be rendered like this:",
                "example": [
                    "Computes weight based on three factors: items sent items received last timestamp\n"
                ]
            },
            {
                "description": "Instead, write a Markdown list:",
                "example": [
                    "/**\n * Computes weight based on three factors:\n *\n * - items sent\n * - items received\n * - last timestamp\n */\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "JSDoc tags",
        "belongs to": "Comments and documentation/JSDoc tags",
        "cases": [
            {
                "description": "Google style allows a subset of JSDoc tags.  Most tags must occupy their own line, with the tag at the beginning\nof the line.",
                "example": [
                    "/**\n * The \"param\" tag must occupy its own line and may not be combined.\n * @param left A description of the left param.\n * @param right A description of the right param.\n */\nfunction add(left: number, right: number) { ... }\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "/**\n * The \"param\" tag must occupy its own line and may not be combined.\n * @param left @param right\n */\nfunction add(left: number, right: number) { ... }\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Line wrapping",
        "belongs to": "Comments and documentation/Line wrapping",
        "cases": [
            {
                "description": "Line-wrapped block tags are indented four spaces. Wrapped description text may\nbe lined up with the description on previous lines, but this horizontal\nalignment is discouraged.",
                "example": [
                    "/**\n * Illustrates line wrapping for long param/return descriptions.\n * @param foo This is a param with a particularly long description that just\n *     doesn't fit on one line.\n * @return This returns something that has a lengthy description too long to fit\n *     in one line.\n */\nexports.method = function(foo) {\n  return 5;\n};\n"
                ]
            },
            {
                "description": "Do not indent when wrapping a @desc or @fileoverview description.",
                "example": []
            }
        ]
    },
    {
        "title": "Document all top-level exports of modules",
        "belongs to": "Comments and documentation/Document all top-level exports of modules",
        "cases": [
            {
                "description": "Use /** JSDoc */ comments to communicate information to the users of your\ncode. Avoid merely restating the property or parameter name. You should also\ndocument all properties and methods (exported/public or not) whose purpose is\nnot immediately obvious from their name, as judged by your reviewer.Exception: Symbols that are only exported to be consumed by tooling, such as\n@NgModule classes, do not require comments.",
                "example": []
            }
        ]
    },
    {
        "title": "Class comments",
        "belongs to": "Comments and documentation/Class comments",
        "cases": [
            {
                "description": "JSDoc comments for classes should provide the reader with enough information to\nknow how and when to use the class, as well as any additional considerations\nnecessary to correctly use the class. Textual descriptions may be omitted on the\nconstructor.",
                "example": []
            }
        ]
    },
    {
        "title": "Method and function comments",
        "belongs to": "Comments and documentation/Method and function comments",
        "cases": [
            {
                "description": "Method, parameter, and return descriptions may be omitted if they are obvious\nfrom the rest of the method’s JSDoc or from the method name and type signature.Method descriptions begin with a verb phrase that describes what the method\ndoes. This phrase is not an imperative sentence, but instead is written in the\nthird person, as if there is an implied This method ... before it.",
                "example": []
            }
        ]
    },
    {
        "title": "Parameter property comments",
        "belongs to": "Comments and documentation/Parameter property comments",
        "cases": [
            {
                "description": "A\nparameter property\nis a constructor parameter that is prefixed by one of the modifiers private,\nprotected, public, or readonly. A parameter property declares both a\nparameter and an instance property, and implicitly assigns into it. For example,\nconstructor(private readonly foo: Foo), declares that the constructor takes a\nparameter foo, but also declares a private readonly property foo, and\nassigns the parameter into that property before executing the remainder of the\nconstructor.To document these fields, use JSDoc's @param annotation. Editors display the\ndescription on constructor calls and property accesses.",
                "example": [
                    "/** This class demonstrates how parameter properties are documented. */\nclass ParamProps {\n  /**\n   * @param percolator The percolator used for brewing.\n   * @param beans The beans to brew.\n   */\n  constructor(\n    private readonly percolator: Percolator,\n    private readonly beans: CoffeeBean[]) {}\n}\n"
                ]
            },
            {
                "description": "",
                "example": [
                    "/** This class demonstrates how ordinary fields are documented. */\nclass OrdinaryClass {\n  /** The bean that will be used in the next call to brew(). */\n  nextBean: CoffeeBean;\n\n  constructor(initialBean: CoffeeBean) {\n    this.nextBean = initialBean;\n  }\n}\n"
                ]
            },
            {
                "description": "\n",
                "example": []
            }
        ]
    },
    {
        "title": "JSDoc type annotations",
        "belongs to": "Comments and documentation/JSDoc type annotations",
        "cases": [
            {
                "description": "JSDoc type annotations are redundant in TypeScript source code. Do not declare\ntypes in @param or @return blocks, do not write @implements, @enum,\n@private, @override etc. on code that uses the implements, enum,\nprivate, override etc. keywords.",
                "example": []
            }
        ]
    },
    {
        "title": "Make comments that actually add information",
        "belongs to": "Comments and documentation/Make comments that actually add information",
        "cases": [
            {
                "description": "For non-exported symbols, sometimes the name and type of the function or\nparameter is enough. Code will usually benefit from more documentation than\njust variable names though!\nAvoid comments that just restate the parameter name and type, e.g.\n/** @param fooBarService The Bar service for the Foo application. */\n\nBecause of this rule, @param and @return lines are only required when\nthey add information, and may otherwise be omitted.\n/**\n * POSTs the request to start coffee brewing.\n * @param amountLitres The amount to brew. Must fit the pot size!\n */\nbrew(amountLitres: number, logger: Logger) {\n  // ...\n}\n\n",
                "example": []
            }
        ]
    },
    {
        "title": "Comments when calling a function",
        "belongs to": "Comments and documentation/Make comments that actually add information/Comments when calling a function",
        "cases": [
            {
                "description": "“Parameter name” comments should be used whenever the method name and parameter\nvalue do not sufficiently convey the meaning of the parameter.Before adding these comments, consider refactoring the method to instead accept\nan interface and destructure it to greatly improve call-site\nreadability.Parameter name comments go before the parameter value, and include the\nparameter name and a = suffix:",
                "example": [
                    "someFunction(obviousParam, /* shouldRender= */ true, /* name= */ 'hello');\n"
                ]
            },
            {
                "description": "Existing code may use a legacy parameter name comment style, which places these\ncomments ~after~ the parameter value and omits the =. Continuing to use this\nstyle within the file for consistency is acceptable.",
                "example": [
                    "someFunction(obviousParam, true /* shouldRender */, 'hello' /* name */);\n"
                ]
            },
            {
                "description": "",
                "example": []
            }
        ]
    },
    {
        "title": "Place documentation prior to decorators",
        "belongs to": "Comments and documentation/Make comments that actually add information/Place documentation prior to decorators",
        "cases": [
            {
                "description": "When a class, method, or property have both decorators like @Component and\nJsDoc, please make sure to write the JsDoc before the decorator.\nDo not write JsDoc between the Decorator and the decorated statement.\n@Component({\n  selector: 'foo',\n  template: 'bar',\n})\n/** Component that prints \"bar\". */\nexport class FooComponent {}\n\nWrite the JsDoc block before the Decorator.\n/** Component that prints \"bar\". */\n@Component({\n  selector: 'foo',\n  template: 'bar',\n})\nexport class FooComponent {}\n\n",
                "example": []
            }
        ]
    },
    {
        "title": "Policies",
        "belongs to": "Policies",
        "cases": [
            {
                "description": "\n",
                "example": []
            }
        ]
    },
    {
        "title": "Consistency",
        "belongs to": "Policies/Consistency",
        "cases": [
            {
                "description": "For any style question that isn't settled definitively by this specification, do\nwhat the other code in the same file is already doing (be consistent). If that\ndoesn't resolve the question, consider emulating the other files in the same\ndirectory.Brand new files must use Google Style, regardless of the style choices of\nother files in the same package. When adding new code to a file that is not in\nGoogle Style, reformatting the existing code first is recommended, subject to\nthe advice below. If this reformatting is not\ndone, then new code should be as consistent as possible with existing code in\nthe same file, but must not violate the style guide.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Reformatting existing code",
        "belongs to": "Policies/Consistency/Reformatting existing code",
        "cases": [
            {
                "description": "You will occasionally encounter files in the codebase that are not in proper\nGoogle Style. These may have come from an acquisition, or may have been written\nbefore Google Style took a position on some issue, or may be in non-Google Style\nfor any other reason.When updating the style of existing code, follow these guidelines.\nIt is not required to change all existing code to meet current style\nguidelines. Reformatting existing code is a trade-off between code churn and\nconsistency. Style rules evolve over time and these kinds of tweaks to\nmaintain compliance would create unnecessary churn. However, if significant\nchanges are being made to a file it is expected that the file will be in\nGoogle Style.\nBe careful not to allow opportunistic style fixes to muddle the focus of a\nCL. If you find yourself making a lot of style changes that aren’t critical\nto the central focus of a CL, promote those changes to a separate CL.\n",
                "example": []
            }
        ]
    },
    {
        "title": "Deprecation",
        "belongs to": "Policies/Consistency/Deprecation",
        "cases": [
            {
                "description": "Mark deprecated methods, classes or interfaces with an @deprecated JSDoc\nannotation. A deprecation comment must include simple, clear directions for\npeople to fix their call sites.",
                "example": []
            }
        ]
    },
    {
        "title": "Generated code: mostly exempt",
        "belongs to": "Policies/Consistency/Generated code: mostly exempt",
        "cases": [
            {
                "description": "Source code generated by the build process is not required to be in Google\nStyle. However, any generated identifiers that will be referenced from\nhand-written source code must follow the naming requirements. As a special\nexception, such identifiers are allowed to contain underscores, which may help\nto avoid conflicts with hand-written identifiers.",
                "example": []
            }
        ]
    },
    {
        "title": "Style guide goals",
        "belongs to": "Policies/Consistency/Generated code: mostly exempt/Style guide goals",
        "cases": [
            {
                "description": "In general, engineers usually know best about what's needed in their code, so if\nthere are multiple options and the choice is situation dependent, we should let\ndecisions be made locally. So the default answer should be leave it out.The following points are the exceptions, which are the reasons we have some\nglobal rules. Evaluate your style guide proposal against the following:\nCode should avoid patterns that are known to cause problems, especially\nfor users new to the language.\n\nCode across\nprojects should be consistent across\nirrelevant variations.\nWhen there are two options that are equivalent in a superficial way, we\nshould consider choosing one just so we don't divergently evolve for no\nreason and avoid pointless debates in code reviews.\nExamples:",
                "example": [
                    "\n\nThe capitalization style of names.\nx as T syntax vs the equivalent <T>x syntax (disallowed).\nArray<[number, number]> vs [number, number][].\n\nCode should be maintainable in the long term.\nCode usually lives longer than the original author works on it, and the\nTypeScript team must keep all of Google working into the future.\nExamples:\n\nWe use software to automate changes to code, so code is autoformatted so\nit's easy for software to meet whitespace rules.\nWe require a single set of compiler flags, so a given TS library can be\nwritten assuming a specific set of flags, and users can always safely\nuse a shared library.\nCode must import the libraries it uses (strict deps) so that a\nrefactor in a dependency doesn't change the dependencies of its users.\nWe ask users to write tests. Without tests we cannot have confidence\nthat changes that we make to the language,  don't break users.\n\nCode reviewers should be focused on improving the quality of the code, not\nenforcing arbitrary rules.\nIf it's possible to implement your rule as an\n\nautomated check that is often a good sign.\nThis also supports principle 3.\nIf it really just doesn't matter that much -- if it's an obscure corner of\nthe language or if it avoids a bug that is unlikely to occur -- it's\nprobably worth leaving out.\n"
                ]
            },
            {
                "description": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNamespace imports are often called 'module imports' ↩\n\n\nnamed imports are sometimes called 'destructuring\nimports' because they use similar syntax to\ndestructuring assignments. ↩\n\n\n",
                "example": []
            }
        ]
    }
]