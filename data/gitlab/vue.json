[
    {
        "title": "Linting",
        "belongs to": "Linting",
        "cases": [
            {
                "description": "We default to eslint-vue-plugin , with the `plugin:vue/recommended` . Check the rules for more documentation."
            }
        ]
    },
    {
        "title": "Basic Rules",
        "belongs to": "Basic Rules",
        "cases": [
            {
                "description": "The service has its own file The store has its own file \nUse a function in the bundle file to instantiate the Vue component:",
                "example": "// bad\nclass {\n  init() {\n    new Component({})\n  }\n}\n\n// good\ndocument.addEventListener('DOMContentLoaded', () => new Vue({\n  el: '#element',\n  components: {\n    componentName\n  },\n  render: createElement => createElement('component-name'),\n}));\n"
            },
            {
                "description": "Do not use a singleton for the service or the store",
                "example": "// bad\nclass Store {\n  constructor() {\n    if (!this.prototype.singleton) {\n      // do something\n    }\n  }\n}\n\n// good\nclass Store {\n  constructor() {\n    // do something\n  }\n}\n"
            },
            {
                "description": "Use `.vue` for Vue templates. Do not use `%template` in HAML. \nExplicitly define data being passed into the Vue app",
                "example": "// bad\nreturn new Vue({\n  el: '#element',\n  name: 'ComponentNameRoot',\n  components: {\n    componentName\n  },\n  provide: {\n    ...someDataset\n  },\n  props: {\n    ...anotherDataset\n  },\n  render: createElement => createElement('component-name'),\n}));\n\n// good\nconst { foobar, barfoo } = someDataset;\nconst { foo, bar } = anotherDataset;\n\nreturn new Vue({\n  el: '#element',\n  name: 'ComponentNameRoot',\n  components: {\n    componentName\n  },\n  provide: {\n    foobar,\n    barfoo\n  },\n  props: {\n    foo,\n    bar\n  },\n  render: createElement => createElement('component-name'),\n}));\n"
            },
            {
                "description": "We discourage the use of the spread operator in this specific case in order to keep our codebase explicit, discoverable, and searchable. This applies in any place where we would benefit from the above, such as when initializing Vuex state . The pattern above also enables us to easily parse non scalar values during instantiation.",
                "example": "return new Vue({\n  el: '#element',\n  name: 'ComponentNameRoot',\n  components: {\n    componentName\n  },\n  props: {\n    foo,\n    bar: parseBoolean(bar)\n  },\n  render: createElement => createElement('component-name'),\n}));\n"
            }
        ]
    },
    {
        "title": "Naming",
        "belongs to": "Naming",
        "cases": [
            {
                "description": "Extensions : Use `.vue` extension for Vue components. Do not use `.js` as file extension ( #34371 ). \nReference Naming : Use PascalCase for their default imports:",
                "example": "// bad\nimport cardBoard from 'cardBoard.vue'\n\ncomponents: {\n  cardBoard,\n};\n\n// good\nimport CardBoard from 'cardBoard.vue'\n\ncomponents: {\n  CardBoard,\n};\n"
            },
            {
                "description": "Props Naming: Avoid using DOM component prop names. \nProps Naming: Use kebab-case instead of camelCase to provide props in templates.",
                "example": "// bad\n<component class=\"btn\">\n\n// good\n<component css-class=\"btn\">\n\n// bad\n<component myProp=\"prop\" />\n\n// good\n<component my-prop=\"prop\" />\n"
            }
        ]
    },
    {
        "title": "Alignment",
        "belongs to": "Alignment",
        "cases": [
            {
                "description": "Follow these alignment styles for the template method: \nWith more than one attribute, all attributes should be on a new line:",
                "example": "// bad\n<component v-if=\"bar\"\n    param=\"baz\" />\n\n<button class=\"btn\">Click me</button>\n\n// good\n<component\n  v-if=\"bar\"\n  param=\"baz\"\n/>\n\n<button class=\"btn\">\n  Click me\n</button>\n"
            },
            {
                "description": "The tag can be inline if there is only one attribute:",
                "example": "// good\n  <component bar=\"bar\" />\n\n// good\n  <component\n    bar=\"bar\"\n    />\n\n// bad\n <component\n    bar=\"bar\" />\n"
            }
        ]
    },
    {
        "title": "Quotes",
        "belongs to": "Quotes",
        "cases": [
            {
                "description": "Always use double quotes `\"` inside templates and single quotes `'` for all other JS.",
                "example": "// bad\ntemplate: `\n  <button :class='style'>Button</button>\n`\n\n// good\ntemplate: `\n  <button :class=\"style\">Button</button>\n`\n"
            }
        ]
    },
    {
        "title": "Props",
        "belongs to": "Props",
        "cases": [
            {
                "description": "Props should be declared as an object",
                "example": "// bad\nprops: ['foo']\n\n// good\nprops: {\n  foo: {\n    type: String,\n    required: false,\n    default: 'bar'\n  }\n}\n"
            },
            {
                "description": "Required key should always be provided when declaring a prop",
                "example": "// bad\nprops: {\n  foo: {\n    type: String,\n  }\n}\n\n// good\nprops: {\n  foo: {\n    type: String,\n    required: false,\n    default: 'bar'\n  }\n}\n"
            },
            {
                "description": "Default key should be provided if the prop is not required. There are some scenarios where we need to check for the existence of the property. On those a default key should not be provided.",
                "example": "// good\nprops: {\n  foo: {\n    type: String,\n    required: false,\n  }\n}\n\n// good\nprops: {\n  foo: {\n    type: String,\n    required: false,\n    default: 'bar'\n  }\n}\n\n// good\nprops: {\n  foo: {\n    type: String,\n    required: true\n  }\n}\n"
            }
        ]
    },
    {
        "title": "Data",
        "belongs to": "Data",
        "cases": [
            {
                "description": "`data` method should always be a function",
                "example": "// bad\ndata: {\n  foo: 'foo'\n}\n\n// good\ndata() {\n  return {\n    foo: 'foo'\n  };\n}\n"
            }
        ]
    },
    {
        "title": "Directives",
        "belongs to": "Directives",
        "cases": [
            {
                "description": "Shorthand `@` is preferable over `v-on`",
                "example": "// bad\n<component v-on:click=\"eventHandler\"/>\n\n// good\n<component @click=\"eventHandler\"/>\n"
            },
            {
                "description": "Shorthand `:` is preferable over `v-bind`",
                "example": "// bad\n<component v-bind:class=\"btn\"/>\n\n// good\n<component :class=\"btn\"/>\n"
            },
            {
                "description": "Shorthand `#` is preferable over `v-slot`",
                "example": "// bad\n<template v-slot:header></template>\n\n// good\n<template #header></template>\n"
            }
        ]
    },
    {
        "title": "Closing tags",
        "belongs to": "Closing tags",
        "cases": [
            {
                "description": "Prefer self-closing component tags",
                "example": "// bad\n<component></component>\n\n// good\n<component />\n"
            }
        ]
    },
    {
        "title": "Component usage within templates",
        "belongs to": "Component usage within templates",
        "cases": [
            {
                "description": "Prefer a component’s kebab-cased name over other styles when using it in a template",
                "example": "// bad\n<MyComponent />\n\n// good\n<my-component />\n"
            }
        ]
    },
    {
        "title": "Ordering",
        "belongs to": "Ordering",
        "cases": [
            {
                "description": "Tag order in `.vue` file",
                "example": "<script>\n  // ...\n</script>\n\n<template>\n  // ...\n</template>\n\n// We don't use scoped styles but there are few instances of this\n<style>\n  // ...\n</style>\n",
                "appendix": "Properties in a Vue Component: Check order of properties in components rule ."
            }
        ]
    },
    {
        "title": ":key",
        "belongs to": ":key",
        "cases": [
            {
                "description": "When using `v-for` you need to provide a unique \n`:key` attribute for each item.\nIf the elements of the array being iterated have an unique `id` it is advised to use it:",
                "example": "<div\n  v-for=\"item in items\"\n  :key=\"item.id\"\n>\n  <!-- content -->\n</div>\n"
            },
            {
                "description": "When the elements being iterated don’t have a unique ID, you can use the array index as the `:key` attribute",
                "example": "<div\n  v-for=\"(item, index) in items\"\n  :key=\"index\"\n>\n  <!-- content -->\n</div>\n"
            },
            {
                "description": "When using `v-for` with `template` and there is more than one child element, the `:key` values must be unique. It’s advised to use `kebab-case` namespaces.",
                "example": "<template v-for=\"(item, index) in items\">\n  <span :key=\"`span-${index}`\"></span>\n  <button :key=\"`button-${index}`\"></button>\n</template>\n"
            },
            {
                "description": "When dealing with nested `v-for` use the same guidelines as above.",
                "example": "<div\n  v-for=\"item in items\"\n  :key=\"item.id\"\n>\n  <span\n    v-for=\"element in array\"\n    :key=\"element.id\"\n  >\n    <!-- content -->\n  </span>\n</div>\n"
            },
            {
                "description": "Useful links:\nMaintaining State \nVue Style Guide: Keyed v-for"
            }
        ]
    },
    {
        "title": "Vue testing",
        "belongs to": "Vue testing",
        "cases": [
            {
                "description": "Over time, a number of programming patterns and style preferences have emerged in our efforts to effectively test Vue components. The following guide describes some of these. These are not strict guidelines , but rather a collection of suggestions and good practices that aim to provide insight into how we write Vue tests at GitLab."
            }
        ]
    },
    {
        "title": "Mounting a component",
        "belongs to": "Vue testing/Mounting a component",
        "cases": [
            {
                "description": "Typically, when testing a Vue component, the component should be “re-mounted” in every test block.\nTo achieve this:\nCreate a mutable `wrapper` variable inside the top-level `describe` block. Mount the component using mount or shallowMount . Reassign the resulting Wrapper instance to our `wrapper` variable.\nCreating a global, mutable wrapper provides a number of advantages, including the ability to:\nDefine common functions for finding components/DOM elements:",
                "example": "import MyComponent from '~/path/to/my_component.vue';\ndescribe('MyComponent', () => {\n  let wrapper;\n\n  // this can now be reused across tests\n  const findMyComponent = wrapper.findComponent(MyComponent);\n  // ...\n})\n",
                "appendix": "Use a `beforeEach` block to mount the component (see the createComponent factory for more information). Automatically destroy the component after the test is run with enableAutoDestroy set in shared_test_setup.js ."
            }
        ]
    },
    {
        "title": "The createComponent factory",
        "belongs to": "Vue testing/Mounting a component/The createComponent factory",
        "cases": [
            {
                "description": "To avoid duplicating our mounting logic, it’s useful to define a `createComponent` factory function that we can reuse in each test block. This is a closure which should reassign our `wrapper` variable to the result of mount and shallowMount :",
                "example": "import MyComponent from '~/path/to/my_component.vue';\nimport { shallowMount } from '@vue/test-utils';\n\ndescribe('MyComponent', () => {\n  // Initiate the \"global\" wrapper variable. This will be used throughout our test:\n  let wrapper;\n\n  // Define our `createComponent` factory:\n  function createComponent() {\n    // Mount component and reassign `wrapper`:\n    wrapper = shallowMount(MyComponent);\n  }\n\n  it('mounts', () => {\n    createComponent();\n\n    expect(wrapper.exists()).toBe(true);\n  });\n\n  it('`isLoading` prop defaults to `false`', () => {\n    createComponent();\n\n    expect(wrapper.props('isLoading')).toBe(false);\n  });\n})\n"
            },
            {
                "description": "Similarly, we could further de-duplicate our test by calling `createComponent` in a `beforeEach` block:",
                "example": "import MyComponent from '~/path/to/my_component.vue';\nimport { shallowMount } from '@vue/test-utils';\n\ndescribe('MyComponent', () => {\n  // Initiate the \"global\" wrapper variable. This will be used throughout our test\n  let wrapper;\n\n  // define our `createComponent` factory\n  function createComponent() {\n    // mount component and reassign `wrapper`\n    wrapper = shallowMount(MyComponent);\n  }\n\n  beforeEach(() => {\n    createComponent();\n  });\n\n  it('mounts', () => {\n    expect(wrapper.exists()).toBe(true);\n  });\n\n  it('`isLoading` prop defaults to `false`', () => {\n    expect(wrapper.props('isLoading')).toBe(false);\n  });\n})\n"
            }
        ]
    },
    {
        "title": "createComponent best practices",
        "belongs to": "Vue testing/Mounting a component/createComponent best practices",
        "cases": [
            {
                "description": "Consider using a single (or a limited number of) object arguments over many arguments. Defining single parameters for common data like `props` is okay, but keep in mind our JavaScript style guide and stay within the parameter number limit:",
                "example": "// bad\nfunction createComponent(props, stubs, mountFn, foo) { }\n\n// good\nfunction createComponent({ props, stubs, mountFn, foo } = {}) { }\n\n// good\nfunction createComponent(props = {}, { stubs, mountFn, foo } = {}) { }\n"
            },
            {
                "description": "If you require both `mount` \nand \n`shallowMount` within the same set of tests, it can be useful define a `mountFn` parameter for the `createComponent` factory that accepts the mounting function ( `mount` or `shallowMount` ) to be used to mount the component:",
                "example": "import { shallowMount } from '@vue/test-utils';\n\nfunction createComponent({ mountFn = shallowMount } = {}) { }\n"
            },
            {
                "description": "Use the `mountExtended` and `shallowMountExtended` helpers to expose `wrapper.findByTestId()` :",
                "example": "import { shallowMountExtended } from 'helpers/vue_test_utils_helper';\nimport { SomeComponent } from 'components/some_component.vue';\n\nlet wrapper;\n\nconst createWrapper = () => { wrapper = shallowMountExtended(SomeComponent); };\nconst someButton = () => wrapper.findByTestId('someButtonTestId');\n",
                "appendix": "Avoid using `data` , `methods` , or any other mounting option that extends component internals."
            },
            {
                "example": "  import { shallowMountExtended } from 'helpers/vue_test_utils_helper';\n  import { SomeComponent } from 'components/some_component.vue';\n\n  let wrapper;\n\n  // bad :( - This circumvents the actual user interaction and couples the test to component internals.\n  const createWrapper = ({ data }) => {\n    wrapper = shallowMountExtended(SomeComponent, {\n      data\n    });\n  };\n\n  // good :) - Helpers like `clickShowButton` interact with the actual I/O of the component.\n  const createWrapper = () => {\n    wrapper = shallowMountExtended(SomeComponent);\n  };\n  const clickShowButton = () => {\n    wrapper.findByTestId('show').trigger('click');\n  }\n"
            }
        ]
    },
    {
        "title": "Setting component state",
        "belongs to": "Vue testing/Mounting a component/Setting component state",
        "cases": [
            {
                "description": "Avoid using setProps to set component state wherever possible. Instead, set the component’s propsData when mounting the component:",
                "example": "// bad\nwrapper = shallowMount(MyComponent);\nwrapper.setProps({\n  myProp: 'my cool prop'\n});\n\n// good\nwrapper = shallowMount({ propsData: { myProp: 'my cool prop' } });\n",
                "appendix": "The exception here is when you wish to test component reactivity in some way. For example, you may want to test the output of a component when after a particular watcher has executed. Using `setProps` to test such behavior is okay. \nAvoid using setData which sets the component’s internal state and circumvents testing the actual I/O of the component. Instead, trigger events on the component’s children or other side-effects to force state changes."
            }
        ]
    },
    {
        "title": "Accessing component state",
        "belongs to": "Vue testing/Mounting a component/Accessing component state",
        "cases": [
            {
                "description": "When accessing props or attributes, prefer the `wrapper.props('myProp')` syntax over `wrapper.props().myProp` or `wrapper.vm.myProp` :",
                "example": "// good\nexpect(wrapper.props().myProp).toBe(true);\nexpect(wrapper.attributes().myAttr).toBe(true);\n\n// better\nexpect(wrapper.props('myProp').toBe(true);\nexpect(wrapper.attributes('myAttr')).toBe(true);\n"
            },
            {
                "description": "When asserting multiple props, check the deep equality of the `props()` object with toEqual :",
                "example": "// good\nexpect(wrapper.props('propA')).toBe('valueA');\nexpect(wrapper.props('propB')).toBe('valueB');\nexpect(wrapper.props('propC')).toBe('valueC');\n\n// better\nexpect(wrapper.props()).toEqual({\n  propA: 'valueA',\n  propB: 'valueB',\n  propC: 'valueC',\n});\n"
            },
            {
                "description": "If you are only interested in some of the props, you can use toMatchObject . Prefer `toMatchObject` over expect.objectContaining :",
                "example": "// good\nexpect(wrapper.props()).toEqual(expect.objectContaining({\n  propA: 'valueA',\n  propB: 'valueB',\n}));\n\n// better\nexpect(wrapper.props()).toMatchObject({\n  propA: 'valueA',\n  propB: 'valueB',\n});\n"
            }
        ]
    },
    {
        "title": "Testing props validation",
        "belongs to": "Vue testing/Mounting a component/Testing props validation",
        "cases": [
            {
                "description": "When checking component props use `assertProps` helper. Props validation failures will be thrown as errors:",
                "example": "import { assertProps } from 'helpers/assert_props'\n\n// ...\n\nexpect(() => assertProps(SomeComponent, { invalidPropValue: '1', someOtherProp: 2 })).toThrow()\n"
            }
        ]
    },
    {
        "title": "The JavaScript/Vue Accord",
        "belongs to": "The JavaScript/Vue Accord",
        "cases": [
            {
                "description": "The goal of this accord is to make sure we are all on the same page.\nWhen writing Vue, you may not use jQuery in your application. \nIf you need to grab data from the DOM, you may query the DOM 1 time while bootstrapping your application to grab data attributes using `dataset` . You can do this without jQuery. You may use a jQuery dependency in Vue.js following this example from the docs . If an outside jQuery Event needs to be listen to inside the Vue application, you may use jQuery event listeners. We avoid adding new jQuery events when they are not required. Instead of adding new jQuery events take a look at different methods to do the same task . \nYou may query the `window` object one time, while bootstrapping your application for application specific data (for example, `scrollTo` is ok to access anytime). Do this access during the bootstrapping of your application. You may have a temporary but immediate need to create technical debt by writing code that does not follow our standards, to be refactored later. Maintainers need to be ok with the tech debt in the first place. An issue should be created for that tech debt to evaluate it further and discuss. In the coming months you should fix that tech debt, with its priority to be determined by maintainers. When creating tech debt you must write the tests for that code before hand and those tests may not be rewritten. For example, jQuery tests rewritten to Vue tests. You may choose to use VueX as a centralized state management. If you choose not to use VueX, you must use the store pattern which can be found in the Vue.js documentation . Once you have chosen a centralized state-management solution you must use it for your entire application. Don’t mix and match your state-management solutions."
            }
        ]
    },
    {
        "title": "Privacy Preference Center",
        "belongs to": "Privacy Preference Center",
        "cases": []
    }
]