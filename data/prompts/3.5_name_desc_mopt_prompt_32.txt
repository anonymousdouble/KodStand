Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.8.8 Numeric Literals
`long` -valued integer literals use an uppercase `L` suffix, never lowercase (to avoid confusion with the digit `1` ). For example, `3000000000L` rather than `3000000000l` .

CheckStyle Rules:
[Rule]
UpperEll
[Description]
Checks that long constants are defined with an upper ell. That
is 'L' and not 'l'. This is in accordance with the Java
Language Specification,

Section 3.10.1.


Rationale: The lower-case ell 'l' looks a lot like 1.
[Options]
[Rule]
MagicNumber
[Description]
Checks that there are no

"magic numbers" where a magic
number is a numeric literal that is not defined as a constant.
By default, -1, 0, 1, and 2 are not considered to be magic numbers.


Constant definition is any variable/field that has 'final' modifier.
It is fine to have one constant defining multiple numeric literals within one expression:



static final int SECONDS_PER_DAY = 24 * 60 * 60;
static final double SPECIAL_RATIO = 4.0 / 3.0;
static final double SPECIAL_SUM = 1 + Math.E;
static final double SPECIAL_DIFFERENCE = 4 - Math.PI;
static final Border STANDARD_BORDER = BorderFactory.createEmptyBorder(3, 3, 3, 3);
static final Integer ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE = new Integer(42);
[Options]
constantWaiverParentToken, Specify tokens that are allowed in the AST path from the number literal to the enclosing constant definition.
ignoreAnnotation, Ignore magic numbers in annotation declarations.
ignoreAnnotationElementDefaults, Ignore magic numbers in annotation elements defaults.
ignoreFieldDeclaration, Ignore magic numbers in field declarations.
ignoreHashCodeMethod, Ignore magic numbers in hashCode methods.
ignoreNumbers, Specify non-magic numbers.
tokens, tokens to check
[Rule]
StringLiteralEquality
[Description]
Checks that string literals are not used with == or
!=.
Since == will compare the object references,
not the actual value of the strings,
String.equals() should be used.
More information can be found

in this article.


Rationale: Novice Java programmers often use code like:



if (x == "something")

when they mean


if ("something".equals(x))
[Options]
[Rule]
ConstantName
[Description]
Checks that constant names conform to a specified pattern.
A constant is a static and final field or an
interface/annotation field, except serialVersionUID and
serialPersistentFields.
[Options]
applyToPackage, Control if check should apply to package-private members.
applyToPrivate, Control if check should apply to private members.
applyToProtected, Control if check should apply to protected members.
applyToPublic, Control if check should apply to public members.
format, Sets the pattern to match valid identifiers.
[Rule]
AbbreviationAsWordInName
[Description]
Validates abbreviations (consecutive capital letters) length in identifier name,
it also allows to enforce camel case naming. Please read more at

Google Style Guide
to get to know how to avoid long abbreviations in names.

'_' is considered as word separator in identifier name.

allowedAbbreviationLength specifies how many consecutive capital letters are
allowed in the identifier.
A value of 3 indicates that up to 4 consecutive capital letters are allowed,
one after the other, before a violation is printed. The identifier 'MyTEST' would be
allowed, but 'MyTESTS' would not be.
A value of 0 indicates that only 1 consecutive capital letter is allowed. This
is what should be used to enforce strict camel casing. The identifier 'MyTest' would
be allowed, but 'MyTEst' would not be.


ignoreFinal, ignoreStatic, and ignoreStaticFinal
control whether variables with the respective modifiers are to be ignored.
Note that a variable that is both static and final will always be considered under
ignoreStaticFinal only, regardless of the values of ignoreFinal
and ignoreStatic. So for example if ignoreStatic is true but
ignoreStaticFinal is false, then static final variables will not be ignored.
[Options]
allowedAbbreviationLength, Indicate the number of consecutive capital letters allowed in targeted identifiers (abbreviations in the classes, interfaces, variables and methods names, ... ).
allowedAbbreviations, Specify abbreviations that must be skipped for checking.
ignoreFinal, Allow to skip variables with final modifier.
ignoreOverriddenMethods, Allow to ignore methods tagged with @Override annotation (that usually mean inherited name).
ignoreStatic, Allow to skip variables with static modifier.
ignoreStaticFinal, Allow to skip variables with both static and final modifiers.
tokens, tokens to check
[Rule]
ModifierOrder
[Description]
Checks that the order of modifiers conforms to the suggestions in
the Java
Language specification, ¡ì 8.1.1, 8.3.1, 8.4.3 and

9.4. The correct order is:



public


protected


private


abstract


default


static


sealed


non-sealed


final


transient


volatile


synchronized


native


strictfp



In additional, modifiers are checked to ensure all annotations are
declared before all other modifiers.


Rationale: Code is easier to read if everybody follows a standard.


ATTENTION: We skip

type annotations from validation.
[Options]
[Rule]
EqualsAvoidNull
[Description]
Checks that any combination of String literals
is on the left side of an equals() comparison.
Also checks for String literals assigned to some field
(such as someString.equals(anotherString = "text")).


Rationale: Calling the equals()
method on String literals will avoid a potential
NullPointerException. Also, it is pretty common to see null
checks right before equals comparisons but following this rule such checks
are not required.
[Options]
ignoreEqualsIgnoreCase, Control whether to ignore String.equalsIgnoreCase(String) invocations.
[Rule]
LambdaBodyLength
[Description]
Checks lambda body length.


Rationale: Similar to anonymous inner classes, if lambda body becomes very long
it is hard to understand and to see the flow of the method
where the lambda is defined. Therefore, long lambda body
should usually be extracted to method.
[Options]
max, Specify the maximum number of lines allowed.
[Rule]
FileLength
[Description]
Checks for long source files.


Rationale: If a source file becomes very long it is hard to
understand. Therefore, long classes should usually be refactored
into several individual classes that focus on a specific task.
[Options]
fileExtensions, Specify the file extensions of the files to process.
max, Specify the maximum number of lines allowed.
[Rule]
MultipleStringLiterals
[Description]
Checks for multiple occurrences of the same string literal within a
single file.


Rationale: Code duplication makes maintenance more difficult, so it
can be better to replace the multiple occurrences with a constant.
[Options]
allowedDuplicates, Specify the maximum number of occurrences to allow without generating a warning.
ignoreOccurrenceContext, Specify token type names where duplicate strings are ignored even if they don't match ignoredStringsRegexp. This allows you to exclude syntactical contexts like annotations or static initializers from the check.
ignoreStringsRegexp, Specify RegExp for ignored strings (with quotation marks).

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
