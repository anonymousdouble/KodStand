url,rule_name,description,options,GPT-DSL
https://checkstyle.org/checks/coding/packagedeclaration.html#PackageDeclaration,PackageDeclaration,"Description

Ensures that a class has a package declaration, and (optionally) whether
the package name matches the directory name for the source file.


Rationale: Classes that live in the null package cannot be
imported. Many novice developers are not aware of this.


Packages provide logical namespace to classes and should be stored in
the form of directory levels to provide physical grouping to your classes.
These directories are added to the classpath so that your classes
are visible to JVM when it runs the code.","Properties



name
description
type
default value
since


matchDirectoryStructure
Control whether to check for directory and package name match.
boolean
true
7.6.1","The extracted Final Ruleset Description is:

Basic Rule:
Mandatory: Order of [PackageDeclaration] is [PackageDeclaration]
And
Optional: [PackageDeclaration] match [DirectoryStructure]"
https://checkstyle.org/checks/design/visibilitymodifier.html#VisibilityModifier,VisibilityModifier,"Description

Checks visibility of class members. Only static final, immutable or annotated
by specified annotation members may be public; other class members must be private
unless the property protectedAllowed or packageAllowed is set.


Public members are not flagged if the name matches the public
member regular expression (contains ""^serialVersionUID$"" by default).

Note that
Checkstyle 2 used to include ""^f[A-Z][a-zA-Z0-9]*$"" in the default
pattern to allow names used in container-managed persistence for Enterprise JavaBeans
(EJB) 1.1 with the default settings. With EJB 2.0 it is no longer necessary to have
public access for persistent fields, so the default has been changed.


Rationale: Enforce encapsulation.


Check also has options making it less strict:


ignoreAnnotationCanonicalNames - the list of annotations which ignore variables
in consideration. If user want to provide short annotation name that type
will match to any named the same type without consideration of package.


allowPublicFinalFields - which allows public final fields.


allowPublicImmutableFields - which allows immutable fields to be declared as
public if defined in final class.


Field is known to be immutable if:


It's declared as final

Has either a primitive type or instance of class user defined to be immutable
(such as String, ImmutableCollection from Guava, etc.)



Classes known to be immutable are listed in immutableClassCanonicalNames by their
canonical names.


Property Rationale: Forcing all fields of class to have private modifier by default is
good in most cases, but in some cases it drawbacks in too much boilerplate get/set code.
One of such cases are immutable classes.


Restriction: Check doesn't check if class is immutable, there's no
checking if accessory methods are missing and all fields are immutable, we only check
if current field is immutable or final. Under the flag
allowPublicImmutableFields, the enclosing class must also be final, to encourage
immutability. Under the flag allowPublicFinalFields, the final modifier on
the enclosing class is optional.


Star imports are out of scope of this Check. So if one of type imported via
star import collides with user specified one by its short name -
there won't be Check's violation.","Properties



name
description
type
default value
since


allowPublicFinalFields
Allow final fields to be declared as public.
boolean
false
7.0


allowPublicImmutableFields
Allow immutable fields to be declared as public if defined in final class.
boolean
false
6.4


ignoreAnnotationCanonicalNames
Specify annotations canonical names which ignore variables in consideration.
String[]
com.google.common.annotations.VisibleForTesting, org.junit.ClassRule, org.junit.Rule
6.5


immutableClassCanonicalNames
Specify immutable classes canonical names.
String[]
java.io.File, java.lang.Boolean, java.lang.Byte, java.lang.Character, java.lang.Double, java.lang.Float, java.lang.Integer, java.lang.Long, java.lang.Short, java.lang.StackTraceElement, java.lang.String, java.math.BigDecimal, java.math.BigInteger, java.net.Inet4Address, java.net.Inet6Address, java.net.InetSocketAddress, java.net.URI, java.net.URL, java.util.Locale, java.util.UUID
6.4.1


packageAllowed
Control whether package visible members are allowed.
boolean
false
3.0


protectedAllowed
Control whether protected members are allowed.
boolean
false
3.0


publicMemberPattern
Specify pattern for public members that should be ignored.
Pattern
""^serialVersionUID$""
3.0","The Extracted Final Ruleset Description is:
Basic Rule:
- Mandatory: Order of [class members] is {{VisibilityModifier}}
- Mandatory: {{VisibilityModifier}} have [public members] -> [static final, immutable or annotated by specified annotation members]

Option Rules:
- allowPublicFinalFields option:
  - false: Mandatory: [final fields] of [class members] is not [public]
  - true: Optional: [final fields] of [class members] is [public]

- allowPublicImmutableFields option:
  - false: Mandatory: [immutable fields] of [class members] is not [public]
  - true: Optional: [immutable fields] of [class members] is [public]

- ignoreAnnotationCanonicalNames option:
  - Specify annotations canonical names which ignore variables in consideration.
  - Type: String[]
  - Value Range: com.google.common.annotations.VisibleForTesting, org.junit.ClassRule, org.junit.Rule
  - Default Value: com.google.common.annotations.VisibleForTesting, org.junit.ClassRule, org.junit.Rule

- immutableClassCanonicalNames option:
  - Specify immutable classes canonical names.
  - Type: String[]
  - Value Range: java.io.File, java.lang.Boolean, java.lang.Byte, java.lang.Character, java.lang.Double, java.lang.Float, java.lang.Integer, java.lang.Long, java.lang.Short, java.lang.StackTraceElement, java.lang.String, java.math.BigDecimal, java.math.BigInteger, java.net.Inet4Address, java.net.Inet6Address, java.net.InetSocketAddress, java.net.URI, java.net.URL, java.util.Locale, java.util.UUID
  - Default Value: java.io.File, java.lang.Boolean, java.lang.Byte, java.lang.Character, java.lang.Double, java.lang.Float, java.lang.Integer, java.lang.Long, java.lang.Short, java.lang.StackTraceElement, java.lang.String, java.math.BigDecimal, java.math.BigInteger, java.net.Inet4Address, java.net.Inet6Address, java.net.InetSocketAddress, java.net.URI, java.net.URL, java.util.Locale, java.util.UUID

- packageAllowed option:
  - false: Mandatory: [package visible members] of [class members] is not [allowed]
  - true: Optional: [package visible members] of [class members] is [allowed]

- protectedAllowed option:
  - false: Mandatory: [protected members] of [class members] is not [allowed]
  - true: Optional: [protected members] of [class members] is [allowed]

- publicMemberPattern option:
  - Specify pattern for public members that should be ignored.
  - Type: Pattern
  - Value Range: ""^serialVersionUID$""
  - Default Value: ""^serialVersionUID$""

Options that are data specifications:
- None"
https://checkstyle.org/checks/misc/indentation.html#Indentation,Indentation,"Description

Checks correct indentation of Java code.


The idea behind this is that while pretty printers are
sometimes convenient for bulk reformats of legacy code, they often
either aren't configurable enough or just can't anticipate how
format should be done. Sometimes this is personal preference, other
times it is practical experience. In any case, this check should
just ensure that a minimal set of indentation rules is followed.


Basic offset indentation is used for indentation inside code blocks.
For any lines that span more than 1, line wrapping indentation is used for those
lines after the first.
Brace adjustment, case, and throws indentations are all used only if those specific
identifiers start the line. If, for example, a brace is used in the middle of the line,
its indentation will not take effect.
All indentations have an accumulative/recursive effect when they are triggered. If
during a line wrapping, another code block is found and it doesn't end on that same
line, then the subsequent lines afterwards, in that new code block, are increased on
top of the line wrap and any indentations above it.

Example:


if ((condition1 && condition2)
|| (condition3 && condition4)    // line wrap with bigger indentation
||!(condition5 && condition6)) { // line wrap with bigger indentation
field.doSomething()                    // basic offset
.doSomething()                     // line wrap
.doSomething( c -> {               // line wrap
return c.doSome();               // basic offset
});
}","Properties



name
description
type
default value
since


arrayInitIndent
Specify how far an array initialization should be indented when on next line.
int
4
5.8


basicOffset
Specify how far new indentation level should be indented when on the next line.
int
4
3.1


braceAdjustment
Specify how far a braces should be indented when on the next line.
int
0
3.1


caseIndent
Specify how far a case label should be indented when on next line.
int
4
3.1


forceStrictCondition
Force strict indent level in line wrapping case. If value is true, line wrap indent have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like.
boolean
false
6.3


lineWrappingIndentation
Specify how far continuation line should be indented when line-wrapping is present.
int
4
5.9


throwsIndent
Specify how far a throws clause should be indented when on next line.
int
4
5.7","The extracted Final Ruleset Description is:

Basic Rule:
- Order of [arrayInitIndent] is [int] >= 4
- Order of [basicOffset] is [int] >= 4
- Order of [braceAdjustment] is [int] >= 0
- Order of [caseIndent] is [int] >= 4
- Order of [forceStrictCondition] is [boolean] = false
- Order of [lineWrappingIndentation] is [int] >= 4
- Order of [throwsIndent] is [int] >= 4

Options that are data specifications:
- arrayInitIndent: int; >= 4; 4
- basicOffset: int; >= 4; 4
- braceAdjustment: int; >= 0; 0
- caseIndent: int; >= 4; 4
- forceStrictCondition: boolean; {true, false}; false
- lineWrappingIndentation: int; >= 4; 4
- throwsIndent: int; >= 4; 4"
https://checkstyle.org/checks/design/onetoplevelclass.html#OneTopLevelClass,OneTopLevelClass,"Description

Checks that each top-level class, interface, enum
or annotation resides in a source file of its own.
Official description of a 'top-level' term:
7.6. Top Level Type Declarations.
If file doesn't contain public class, interface, enum or annotation,
top-level type is the first type in file.",,"The Extracted Final Ruleset Description is:
Basic Rule:
Mandatory: Order of [top-level type declarations] is [separate source files]"
https://checkstyle.org/checks/annotation/missingdeprecated.html#MissingDeprecated,MissingDeprecated,"Description

Verifies that the annotation @Deprecated and the Javadoc tag
@deprecated are both present when either of them is present.


Both ways of flagging deprecation serve their own purpose.
The @Deprecated annotation is used for compilers and development tools.
The @deprecated javadoc tag is used to document why something is deprecated
and what, if any, alternatives exist.


In order to properly mark something as deprecated both forms of
deprecation should be present.


Package deprecation is an exception to the rule of always using the
javadoc tag and annotation to deprecate.  It is not clear if the
javadoc tool will support it or not as newer versions keep flip-flopping
on if it is supported or will cause an error.
See
JDK-8160601.
The deprecated javadoc tag is currently the only way to say why the package
is deprecated and what to use instead.  Until this is resolved, if you
don't want to print violations on package-info, you can use a
filter to ignore these files until
the javadoc tool faithfully supports it. An example config using
SuppressionSingleFilter is:



<!-- required till https://bugs.openjdk.org/browse/JDK-8160601 -->
<module name=""SuppressionSingleFilter"">
<property name=""checks"" value=""MissingDeprecatedCheck""/>
<property name=""files"" value=""package-info\.java""/>
</module>","Properties



name
description
type
default value
since


violateExecutionOnNonTightHtml
Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at
Tight-HTML Rules.
boolean
false
8.24","The extracted Final Ruleset Description is:

Basic Rule:
- Mandatory: Order of [annotation @Deprecated] is [present]
- And
- Mandatory: Order of [Javadoc tag @deprecated] is [present]

Option Rule:
- violateExecutionOnNonTightHtml option:
  - true: Mandatory: [Javadoc] violates [tight html rules] -> [print violations]
  - false: Optional: [Javadoc] not violate [tight html rules]

Options that are data specifications:
- None"
https://checkstyle.org/checks/javadoc/javadocvariable.html#JavadocVariable,JavadocVariable,"Description

Checks that a variable has a Javadoc comment. Ignores serialVersionUID
fields.","Properties



name
description
type
default value
since


excludeScope
Specify the visibility scope where Javadoc comments are not checked.
Scope
null
3.4


ignoreNamePattern
Specify the regexp to define variable names to ignore.
Pattern
null
5.8


scope
Specify the visibility scope where Javadoc comments are checked.
Scope
private
3.0


tokens
tokens to check
subset of tokens

ENUM_CONSTANT_DEF
.



ENUM_CONSTANT_DEF
.

3.0","The extracted Final Ruleset Description is:

Basic Rule:
- Mandatory: Order of [tokens] is {{ENUM_CONSTANT_DEF}}
- Mandatory: {{ENUM_CONSTANT_DEF}} not have [ENUM_CONSTANT_DEF] -> [ENUM_CONSTANT_DEF]

Options that are data specifications:
- {{ENUM_CONSTANT_DEF}}: Scope; {private, protected, public, package}; {private}"
https://checkstyle.org/checks/coding/noenumtrailingcomma.html#NoEnumTrailingComma,NoEnumTrailingComma,"Description

Checks that enum definition does not contain a trailing comma.
Rationale: JLS allows trailing commas in arrays and enumerations, but does not allow
them in other locations. To unify the coding style, the use of trailing commas should
be prohibited.



enum Foo1 {
FOO,
BAR;
}


The check demands that there should not be any comma after last constant in
enum definition.



enum Foo1 {
FOO,
BAR, //violation
}",,"The Extracted Final Ruleset Description is:
Basic Rule:
Mandatory: Order of [enum constants] should not have [comma] at the end of [enum definition]"
https://checkstyle.org/checks/misc/uniqueproperties.html#UniqueProperties,UniqueProperties,"Description

Detects duplicated keys in properties files.


Rationale: Multiple property keys usually appear after merge
or rebase of several branches. While there are no problems in
runtime, there can be a confusion due to having different values
for the duplicated properties.","Properties



name
description
type
default value
since


fileExtensions
Specify the file extensions of the files to process.
String[]
.properties
5.7","The extracted Final Ruleset Description is:

Basic Rule:
Mandatory: Order of [Properties] is [UniqueProperties]

Option Rule:
fileExtensions option:
Mandatory: Order of [file extensions] is [String[]] for 'properties' -> [Properties]"
https://checkstyle.org/checks/javadoc/javadoctagcontinuationindentation.html#JavadocTagContinuationIndentation,JavadocTagContinuationIndentation,"Description

Checks the indentation of the continuation lines in block tags.
That is whether the
continued description of at clauses should be indented or not. If the text is not properly
indented it throws a violation. A continuation line is when the description starts/spans
past the line with the tag. Default indentation required is at least 4, but this can be
changed with the help of properties below.","Properties



name
description
type
default value
since


offset
Specify how many spaces to use for new indentation level.
int
4
6.0


violateExecutionOnNonTightHtml
Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at
Tight-HTML Rules.
boolean
false
8.3","The extracted Final Ruleset Description is:

Basic Rule:
- Mandatory: Order of [block tags] is [JavadocTagContinuationIndentation]
- Mandatory: [JavadocTagContinuationIndentation] is >= [offset]

Option Rule:
- violateExecutionOnNonTightHtml option:
  - true: Mandatory: [JavadocTagContinuationIndentation] is not [violateExecutionOnNonTightHtml]
  - false: Optional: [JavadocTagContinuationIndentation] is [violateExecutionOnNonTightHtml]

Data Specifications:
- offset: int; >=4; 4
- violateExecutionOnNonTightHtml: boolean; {true, false}; false"
https://checkstyle.org/checks/naming/lambdaparametername.html#LambdaParameterName,LambdaParameterName,"Description

Checks lambda parameter names.","Properties



name
description
type
default value
since


format
Sets the pattern to match valid identifiers.
Pattern
""^[a-z][a-zA-Z0-9]*$""
8.11","The extracted Final Ruleset Description is:

Basic Rule:
Mandatory: Order of LambdaParameterName is Pattern ""^[a-z][a-zA-Z0-9]*$""

Options that are data specifications:
LambdaParameterName: String; {}; {};"
