Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
6.2 Caught exceptions: not ignored
Except as noted below, it is very rarely correct to do nothing in response to a caught exception. (Typical responses are to log it, or if it is considered "impossible", rethrow it as an `AssertionError` .)
 When it truly is appropriate to take no action whatsoever in a catch block, the reason this is justified is explained in a comment.
 try {
  int i = Integer.parseInt(response);
  return handleNumericResponse(i);
 } catch (NumberFormatException ok) {
  // it's not numeric; that's fine, just continue
 }
 return handleTextResponse(response);
 

 Exception: In tests, a caught exception may be ignored without comment if its name is or begins with `expected` . The following is a very common idiom for ensuring that the code under test does throw an exception of the expected type, so a comment is unnecessary here.
 try {
  emptyStack.pop();
  fail();
 } catch (NoSuchElementException expected) {
 }

CheckStyle Rules:
[Rule]
IllegalCatch
[Description]
Checks that certain exception types do not appear in a catch statement.


Rationale:
catching java.lang.Exception, java.lang.Error or
java.lang.RuntimeException is almost never acceptable.
Novice developers often simply catch Exception in an
attempt to handle multiple exception classes. This unfortunately
leads to code that inadvertently catches NullPointerException,
OutOfMemoryError, etc.
[Rule]
MagicNumber
[Description]
Checks that there are no

"magic numbers" where a magic
number is a numeric literal that is not defined as a constant.
By default, -1, 0, 1, and 2 are not considered to be magic numbers.


Constant definition is any variable/field that has 'final' modifier.
It is fine to have one constant defining multiple numeric literals within one expression:



static final int SECONDS_PER_DAY = 24 * 60 * 60;
static final double SPECIAL_RATIO = 4.0 / 3.0;
static final double SPECIAL_SUM = 1 + Math.E;
static final double SPECIAL_DIFFERENCE = 4 - Math.PI;
static final Border STANDARD_BORDER = BorderFactory.createEmptyBorder(3, 3, 3, 3);
static final Integer ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE = new Integer(42);
[Rule]
InnerAssignment
[Description]
Checks for assignments in subexpressions, such as in
String s = Integer.toString(i = 2);.


Rationale: Except for the loop idioms,
all assignments should occur in their own top-level statement
to increase readability. With inner assignments like the one given above, it is difficult
to see all places where a variable is set.


Note: Check allows usage of the popular assignments in loops:



String line;
while ((line = bufferedReader.readLine()) != null) { // OK
// process the line
}

for (;(line = bufferedReader.readLine()) != null;) { // OK
// process the line
}

do {
// process the line
}
while ((line = bufferedReader.readLine()) != null); // OK


Assignment inside a condition is not a problem here, as the assignment is surrounded by
an extra pair of parentheses. The comparison is != null and there is no
chance that intention was to write line == reader.readLine().
[Rule]
EmptyBlock
[Description]
Checks for empty blocks. This check does not validate sequential blocks.
Sequential blocks won't be checked. Also, no violations for fallthrough:


switch (a) {
case 1:                          // no violation
case 2:                          // no violation
case 3: someMethod(); { }        // no violation
default: break;
}


NOTE: This check processes LITERAL_CASE and LITERAL_DEFAULT separately.
Verification empty block is done for single nearest {@code case} or {@code default}.
[Rule]
AvoidInlineConditionals
[Description]
Detects inline conditionals. Here is one example of an inline conditional:



String a = getParameter("a");
String b = (a==null || a.length()<1) ? null : a.substring(1);


Rationale: Some developers find inline conditionals hard to read, so
their employer's coding standards forbid them.
[Rule]
EmptyCatchBlock
[Description]
Checks for empty catch blocks.
By default, check allows empty catch block with any comment inside.
[Rule]
HideUtilityClassConstructor
[Description]
Makes sure that utility classes (classes that contain only static
methods or fields in their API) do not have a public constructor.


Rationale: Instantiating utility classes does not make sense. Hence,
the constructors should either be private or (if you want to allow
subclassing) protected. A common mistake is forgetting to hide the
default constructor.


If you make the constructor protected you may want to consider the
following constructor implementation technique to disallow
instantiating subclasses:



public class StringUtils // not final to allow subclassing
{
protected StringUtils() {
// prevents calls from subclass
throw new UnsupportedOperationException();
}

public static int count(char c, String s) {
// ...
}
}
[Rule]
IllegalInstantiation
[Description]
Checks for illegal instantiations where a factory method is
preferred.


Rationale: Depending on the project, for some classes it might be
preferable to create instances through factory methods rather than
calling the constructor.


A simple example is the java.lang.Boolean
class. For performance reasons, it is preferable to
use the predefined constants  TRUE and
FALSE. Constructor invocations should be
replaced by calls to Boolean.valueOf().


Some extremely performance sensitive projects may require the use of
factory methods for other classes as well, to enforce the usage of
number caches or object pools.
[Rule]
MissingJavadocMethod
[Description]
Checks for missing Javadoc comments for a method or constructor.
The scope to verify is specified using the Scope class and
defaults to Scope.PUBLIC. To verify another
scope, set property scope to a different
scope.


Javadoc is not required on a method that is tagged with the
@Override annotation. However, under
Java 5 it is not possible to mark a method required for an
interface (this was corrected under Java 6). Hence,
Checkstyle supports using the convention of using a single
{@inheritDoc} tag instead of all the
other tags.


For getters and setters for the property allowMissingPropertyJavadoc,
the methods must match exactly the structures below.



public void setNumber(final int number)
{
mNumber = number;
}

public int getNumber()
{
return mNumber;
}

public boolean isSomething()
{
return false;
}
[Rule]
CyclomaticComplexity
[Description]
Checks cyclomatic complexity against a specified limit.
It is a measure of the minimum number of
possible paths through the source and therefore the number of
required tests, it is not about quality of code!
It is only applied to methods, c-tors,

static initializers and instance initializers.


The complexity is equal to the number of decision points  + 1.
Decision points: if, while
, do, for, ?:, catch
, switch, case
statements and operators && and ||
in the body of target.


By pure theory level 1-4 is considered easy to test, 5-7 OK, 8-10
consider re-factoring to ease testing, and 11+ re-factor now as testing will be painful.


When it comes to code quality measurement by this metric
level 10 is very good level as a ultimate target (that is hard to archive).
Do not be ashamed to have complexity level 15 or even higher,
but keep it below 20 to catch really bad-designed code automatically.


Please use Suppression to avoid violations on cases that could not be split in few
methods without damaging readability of code or encapsulation.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
