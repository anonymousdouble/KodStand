[
    {
        "title": "References",
        "belongs to": "References",
        "cases": [
            {
                "description": "Google Ruby Security Reviewer’s Guide \nOWASP Command Injection \nRuby on Rails Security Guide Command Line Injection"
            }
        ]
    },
    {
        "title": "Use File and FileUtils instead of shell commands",
        "belongs to": "Use File and FileUtils instead of shell commands",
        "cases": [
            {
                "description": "Sometimes we invoke basic Unix commands via the shell when there is also a Ruby API for doing it. Use the Ruby API if it exists.",
                "example": "# Wrong\nsystem \"mkdir -p tmp/special/directory\"\n# Better (separate tokens)\nsystem *%W(mkdir -p tmp/special/directory)\n# Best (do not use a shell command)\nFileUtils.mkdir_p \"tmp/special/directory\"\n\n# Wrong\ncontents = `cat #{filename}`\n# Correct\ncontents = File.read(filename)\n\n# Sometimes a shell command is just the best solution. The example below has no\n# user input, and is hard to implement correctly in Ruby: delete all files and\n# directories older than 120 minutes under /some/path, but not /some/path\n# itself.\nGitlab::Popen.popen(%W(find /some/path -not -path /some/path -mmin +120 -delete))\n"
            },
            {
                "description": "This coding style could have prevented CVE-2013-4490."
            }
        ]
    },
    {
        "title": "Always use the configurable Git binary path for Git commands",
        "belongs to": "Always use the configurable Git binary path for Git commands",
        "cases": [
            {
                "example": "# Wrong\nsystem(*%W(git branch -d -- #{branch_name}))\n\n# Correct\nsystem(*%W(#{Gitlab.config.git.bin_path} branch -d -- #{branch_name}))\n"
            }
        ]
    },
    {
        "title": "Bypass the shell by splitting commands into separate tokens",
        "belongs to": "Bypass the shell by splitting commands into separate tokens",
        "cases": [
            {
                "description": "When we pass shell commands as a single string to Ruby, Ruby lets `/bin/sh` evaluate the entire string. Essentially, we are asking the shell to evaluate a one-line script. This creates a risk for shell injection attacks. It is better to split the shell command into tokens ourselves. Sometimes we use the scripting capabilities of the shell to change the working directory or set environment variables. All of this can also be achieved securely straight from Ruby",
                "example": "# Wrong\nsystem \"cd /home/git/gitlab && bundle exec rake db:#{something} RAILS_ENV=production\"\n# Correct\nsystem({'RAILS_ENV' => 'production'}, *%W(bundle exec rake db:#{something}), chdir: '/home/git/gitlab')\n\n# Wrong\nsystem \"touch #{myfile}\"\n# Better\nsystem \"touch\", myfile\n# Best (do not run a shell command at all)\nFileUtils.touch myfile\n"
            },
            {
                "description": "This coding style could have prevented CVE-2013-4546.\nSee also https://gitlab.com/gitlab-org/gitlab/-/merge_requests/93030 , and https://starlabs.sg/blog/2022/07-gitlab-project-import-rce-analysis-cve-2022-2185/ for another example."
            }
        ]
    },
    {
        "title": "Separate options from arguments with –",
        "belongs to": "Separate options from arguments with –",
        "cases": [
            {
                "description": "Make the difference between options and arguments clear to the argument parsers of system commands with `--` . This is supported by many but not all Unix commands.\nTo understand what `--` does, consider the problem below.",
                "example": "# Example\n$ echo hello > -l\n$ cat -l\n\ncat: illegal option -- l\nusage: cat [-benstuv] [file ...]\n"
            },
            {
                "description": "In the example above, the argument parser of `cat` assumes that `-l` is an option. The solution in the example above is to make it clear to `cat` that `-l` is really an argument, not an option. Many Unix command-line tools follow the convention of separating options from arguments with `--` .",
                "example": "# Example (continued)\n$ cat -- -l\n\nhello\n"
            },
            {
                "description": "In the GitLab codebase, we avoid the option/argument ambiguity by always using `--` for commands that support it.",
                "example": "# Wrong\nsystem(*%W(#{Gitlab.config.git.bin_path} branch -d #{branch_name}))\n# Correct\nsystem(*%W(#{Gitlab.config.git.bin_path} branch -d -- #{branch_name}))\n"
            },
            {
                "description": "This coding style could have prevented CVE-2013-4582."
            }
        ]
    },
    {
        "title": "Do not use the backticks",
        "belongs to": "Do not use the backticks",
        "cases": [
            {
                "description": "Capturing the output of shell commands with backticks reads nicely, but you are forced to pass the command as one string to the shell. We explained above that this is unsafe. In the main GitLab codebase, the solution is to use `Gitlab::Popen.popen` instead.",
                "example": "# Wrong\nlogs = `cd #{repo_dir} && #{Gitlab.config.git.bin_path} log`\n# Correct\nlogs, exit_status = Gitlab::Popen.popen(%W(#{Gitlab.config.git.bin_path} log), repo_dir)\n\n# Wrong\nuser = `whoami`\n# Correct\nuser, exit_status = Gitlab::Popen.popen(%W(whoami))\n"
            },
            {
                "description": "In other repositories, such as GitLab Shell you can also use `IO.popen` .",
                "example": "# Safe IO.popen example\nlogs = IO.popen(%W(#{Gitlab.config.git.bin_path} log), chdir: repo_dir) { |p| p.read }\n"
            },
            {
                "description": "Note that unlike `Gitlab::Popen.popen` , `IO.popen` does not capture standard error."
            }
        ]
    },
    {
        "title": "Avoid user input at the start of path strings",
        "belongs to": "Avoid user input at the start of path strings",
        "cases": [
            {
                "description": "Various methods for opening and reading files in Ruby can be used to read the standard output of a process instead of a file. The following two commands do roughly the same:",
                "example": "`touch /tmp/pawned-by-backticks`\nFile.read('|touch /tmp/pawned-by-file-read')\n"
            },
            {
                "description": "The key is to open a ‘file’ whose name starts with a `|` . Affected methods include Kernel#open, File::read, File::open, IO::open and IO::read.\nYou can protect against this behavior of ‘open’ and ‘read’ by ensuring that an attacker cannot control the start of the filename string you are opening. For instance, the following is sufficient to protect against accidentally starting a shell command with `|` :",
                "example": "# we assume repo_path is not controlled by the attacker (user)\npath = File.join(repo_path, user_input)\n# path cannot start with '|' now.\nFile.read(path)\n"
            },
            {
                "description": "If you have to use user input a relative path, prefix `./` to the path.\nPrefixing user-supplied paths also offers extra protection against paths starting with `-` (see the discussion about using `--` above)."
            }
        ]
    },
    {
        "title": "Guard against path traversal",
        "belongs to": "Guard against path traversal",
        "cases": [
            {
                "description": "Path traversal is a security where the program (GitLab) tries to restrict user access to a certain directory on disk, but the user manages to open a file outside that directory by taking advantage of the `../` path notation.",
                "example": "# Suppose the user gave us a path and they are trying to trick us\nuser_input = '../other-repo.git/other-file'\n\n# We look up the repo path somewhere\nrepo_path = 'repositories/user-repo.git'\n\n# The intention of the code below is to open a file under repo_path, but\n# because the user used '..' they can 'break out' into\n# 'repositories/other-repo.git'\nfull_path = File.join(repo_path, user_input)\nFile.open(full_path) do # Oops!\n"
            },
            {
                "description": "A good way to protect against this is to compare the full path with its ‘absolute path’ according to Ruby’s `File.absolute_path` .",
                "example": "full_path = File.join(repo_path, user_input)\nif full_path != File.absolute_path(full_path)\n  raise \"Invalid path: #{full_path.inspect}\"\nend\n\nFile.open(full_path) do # Etc.\n"
            },
            {
                "description": "A check like this could have avoided CVE-2013-4583."
            }
        ]
    },
    {
        "title": "Properly anchor regular expressions to the start and end of strings",
        "belongs to": "Properly anchor regular expressions to the start and end of strings",
        "cases": [
            {
                "description": "When using regular expressions to validate user input that is passed as an argument to a shell command, make sure to use the `\\A` and `\\z` anchors that designate the start and end of the string, rather than `^` and `$` , or no anchors at all.\nIf you don’t, an attacker could use this to execute commands with potentially harmful effect.\nFor example, when a project’s `import_url` is validated like below, the user could trick GitLab into cloning from a Git repository on the local file system.",
                "example": "validates :import_url, format: { with: URI.regexp(%w(ssh git http https)) }\n# URI.regexp(%w(ssh git http https)) roughly evaluates to /(ssh|git|http|https):(something_that_looks_like_a_url)/\n"
            },
            {
                "description": "Suppose the user submits the following as their import URL:",
                "example": "file://git:/tmp/lol\n"
            },
            {
                "description": "Since there are no anchors in the used regular expression, the `git:/tmp/lol` in the value would match, and the validation would pass.\nWhen importing, GitLab would execute the following command, passing the `import_url` as an argument:",
                "example": "git clone file://git:/tmp/lol\n"
            },
            {
                "description": "Git ignores the `git:` part, interpret the path as `file:///tmp/lol` , and imports the repository into the new project. This action could potentially give the attacker access to any repository in the system, whether private or not."
            }
        ]
    },
    {
        "title": "Privacy Preference Center",
        "belongs to": "Privacy Preference Center",
        "cases": []
    }
]