Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
6.2 Caught exceptions: not ignored
Except as noted below, it is very rarely correct to do nothing in response to a caught exception. (Typical responses are to log it, or if it is considered "impossible", rethrow it as an `AssertionError` .)
 When it truly is appropriate to take no action whatsoever in a catch block, the reason this is justified is explained in a comment.
 try {
  int i = Integer.parseInt(response);
  return handleNumericResponse(i);
 } catch (NumberFormatException ok) {
  // it's not numeric; that's fine, just continue
 }
 return handleTextResponse(response);
 

 Exception: In tests, a caught exception may be ignored without comment if its name is or begins with `expected` . The following is a very common idiom for ensuring that the code under test does throw an exception of the expected type, so a comment is unnecessary here.
 try {
  emptyStack.pop();
  fail();
 } catch (NoSuchElementException expected) {
 }

CheckStyle Rules:
[Rule]
IllegalCatch
[Description]
Checks that certain exception types do not appear in a catch statement.


Rationale:
catching java.lang.Exception, java.lang.Error or
java.lang.RuntimeException is almost never acceptable.
Novice developers often simply catch Exception in an
attempt to handle multiple exception classes. This unfortunately
leads to code that inadvertently catches NullPointerException,
OutOfMemoryError, etc.
[Options]
illegalClassNames, Specify exception class names to reject.
[Rule]
EmptyCatchBlock
[Description]
Checks for empty catch blocks.
By default, check allows empty catch block with any comment inside.
[Options]
commentFormat, Specify the RegExp for the first comment inside empty catch block. If check meets comment inside empty catch block matching specified format - empty block is suppressed. If it is multi-line comment - only its first line is analyzed.
exceptionVariableName, Specify the RegExp for the name of the variable associated with exception. If check meets variable name matching specified value - empty block is suppressed.
[Rule]
InnerAssignment
[Description]
Checks for assignments in subexpressions, such as in
String s = Integer.toString(i = 2);.


Rationale: Except for the loop idioms,
all assignments should occur in their own top-level statement
to increase readability. With inner assignments like the one given above, it is difficult
to see all places where a variable is set.


Note: Check allows usage of the popular assignments in loops:



String line;
while ((line = bufferedReader.readLine()) != null) { // OK
// process the line
}

for (;(line = bufferedReader.readLine()) != null;) { // OK
// process the line
}

do {
// process the line
}
while ((line = bufferedReader.readLine()) != null); // OK


Assignment inside a condition is not a problem here, as the assignment is surrounded by
an extra pair of parentheses. The comparison is != null and there is no
chance that intention was to write line == reader.readLine().
[Options]
[Rule]
AvoidInlineConditionals
[Description]
Detects inline conditionals. Here is one example of an inline conditional:



String a = getParameter("a");
String b = (a==null || a.length()<1) ? null : a.substring(1);


Rationale: Some developers find inline conditionals hard to read, so
their employer's coding standards forbid them.
[Options]
[Rule]
MagicNumber
[Description]
Checks that there are no

"magic numbers" where a magic
number is a numeric literal that is not defined as a constant.
By default, -1, 0, 1, and 2 are not considered to be magic numbers.


Constant definition is any variable/field that has 'final' modifier.
It is fine to have one constant defining multiple numeric literals within one expression:



static final int SECONDS_PER_DAY = 24 * 60 * 60;
static final double SPECIAL_RATIO = 4.0 / 3.0;
static final double SPECIAL_SUM = 1 + Math.E;
static final double SPECIAL_DIFFERENCE = 4 - Math.PI;
static final Border STANDARD_BORDER = BorderFactory.createEmptyBorder(3, 3, 3, 3);
static final Integer ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE = new Integer(42);
[Options]
constantWaiverParentToken, Specify tokens that are allowed in the AST path from the number literal to the enclosing constant definition.
ignoreAnnotation, Ignore magic numbers in annotation declarations.
ignoreAnnotationElementDefaults, Ignore magic numbers in annotation elements defaults.
ignoreFieldDeclaration, Ignore magic numbers in field declarations.
ignoreHashCodeMethod, Ignore magic numbers in hashCode methods.
ignoreNumbers, Specify non-magic numbers.
tokens, tokens to check
[Rule]
AvoidNestedBlocks
[Description]
Finds nested blocks (blocks that are used freely in the code).


Rationale: Nested blocks are often leftovers from the
debugging process, they confuse the reader.


For example, this check finds the obsolete braces in



public void guessTheOutput()
{
int whichIsWhich = 0;
{
whichIsWhich = 2;
}
System.out.println("value = " + whichIsWhich);
}

and debugging / refactoring leftovers such as


// if (conditionThatIsNotUsedAnyLonger)
{
System.out.println("unconditional");
}


A case in a switch statement does not implicitly form a block.
Thus, to be able to introduce local variables that have case
scope it is necessary to open a nested block. This is
supported, set the allowInSwitchCase property to true and
include all statements of the case in the block.
[Options]
allowInSwitchCase, Allow nested blocks if they are the only child of a switch case.
[Rule]
HideUtilityClassConstructor
[Description]
Makes sure that utility classes (classes that contain only static
methods or fields in their API) do not have a public constructor.


Rationale: Instantiating utility classes does not make sense. Hence,
the constructors should either be private or (if you want to allow
subclassing) protected. A common mistake is forgetting to hide the
default constructor.


If you make the constructor protected you may want to consider the
following constructor implementation technique to disallow
instantiating subclasses:



public class StringUtils // not final to allow subclassing
{
protected StringUtils() {
// prevents calls from subclass
throw new UnsupportedOperationException();
}

public static int count(char c, String s) {
// ...
}
}
[Options]
[Rule]
WhitespaceAround
[Description]
Checks that a token is surrounded by whitespace. Empty constructor,
method, class, enum, interface, loop bodies (blocks), lambdas of the form


public MyClass() {}      // empty constructor
public void func() {}    // empty method
public interface Foo {} // empty interface
public class Foo {} // empty class
public enum Foo {} // empty enum
MyClass c = new MyClass() {}; // empty anonymous class
while (i = 1) {} // empty while loop
for (int i = 1; i > 1; i++) {} // empty for loop
do {} while (i = 1); // empty do-while loop
Runnable noop = () -> {}; // empty lambda
public @interface Beta {} // empty annotation type


may optionally be exempted from the policy using the
allowEmptyMethods, allowEmptyConstructors,
allowEmptyTypes, allowEmptyLoops,
allowEmptyLambdas and allowEmptyCatches
properties.

This check does not flag as violation double brace initialization like:



new Properties() {{
setProperty("key", "value");
}};


Parameter allowEmptyCatches allows to suppress violations when token
list contains SLIST to check if beginning of block is surrounded by
whitespace and catch block is empty, for example:



try {
k = 5 / i;
} catch (ArithmeticException ex) {}



With this property turned off, this raises violation because the beginning of the
catch block (left curly bracket) is not separated from the end of the catch
block (right curly bracket).
[Options]
allowEmptyCatches, Allow empty catch bodies.
allowEmptyConstructors, Allow empty constructor bodies.
allowEmptyLambdas, Allow empty lambda bodies.
allowEmptyLoops, Allow empty loop bodies.
allowEmptyMethods, Allow empty method bodies.
allowEmptyTypes, Allow empty class, interface and enum bodies.
ignoreEnhancedForColon, Ignore whitespace around colon in
enhanced for loop.
tokens, tokens to check
[Rule]
IllegalThrows
[Description]
Checks that specified types are not declared to be thrown.
Declaring that a method throws java.lang.Error or
java.lang.RuntimeException is almost never acceptable.
[Options]
ignoreOverriddenMethods, Allow to ignore checking overridden methods (marked with Override or java.lang.Override annotation).
ignoredMethodNames, Specify names of methods to ignore.
illegalClassNames, Specify throw class names to reject.
[Rule]
SingleLineJavadoc
[Description]
Checks that a Javadoc block can fit in a single-line and doesn't
contain block tags. Javadoc comment that contains at least one block tag
should be formatted in a few lines.
[Options]
ignoreInlineTags, Control whether
inline tags must be ignored.
ignoredTags, Specify
block tags which are ignored by the check.
violateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at
Tight-HTML Rules.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
