Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.8.5.2 Class annotations
Annotations applying to a class appear immediately after the documentation block, and each annotation is listed on a line of its own (that is, one annotation per line). These line breaks do not constitute line-wrapping (Section 4.5, Line-wrapping), so the indentation level is not increased. Example:
 @Deprecated
 @CheckReturnValue
 public final class Frozzler { ... }

CheckStyle Rules:
[Rule]
AnnotationLocation
[Description]
Checks location of annotation on language elements.
By default, Check enforce to locate annotations immediately after documentation block
and before target element, annotation should be located on separate line from target
element. This check also verifies that the annotations are on the same indenting level as
the annotated element if they are not on the same line.


Attention: Elements that cannot have JavaDoc comments like local variables are not in the
scope of this check even though a token type like VARIABLE_DEF would match
them.


Attention: Annotations among modifiers are ignored (looks like false-negative)
as there might be a problem with annotations for return types:


public @Nullable Long getStartTimeOrNull() { ... }

Such annotations are better to keep close to type.
Due to limitations, Checkstyle can not examine the target of an annotation.


Example:



@Override
@Nullable
public String getNameIfPresent() { ... }
[Rule]
AnnotationOnSameLine
[Description]
Checks that annotations are located on the same line with their targets.
Verifying with this check is not good practice, but it is using by some style guides.
[Rule]
InvalidJavadocPosition
[Description]
Checks that Javadocs are located at the correct position.
As specified at

Documentation Comment Specification for the Standard Doclet,
Javadocs are recognized only when placed immediately before module, package, class,
interface, constructor, method, or field declarations. Any other position, like
in the body of a method, will be ignored by the javadoc tool and is considered
invalid by this check.
[Rule]
PackageAnnotation
[Description]
Checks that all package annotations are in the package-info.java file.


For Java SE8 and above, placement of package annotations in the package-info.java
file is enforced by the compiler and this check is not necessary.


For Java SE7 and below, the Java Language Specification highly recommends
but doesn't require that annotations are placed in the package-info.java file,
and this check can help to enforce that placement.


See
Java Language Specification, ¡ì7.4.1 for more info.
[Rule]
OneTopLevelClass
[Description]
Checks that each top-level class, interface, enum
or annotation resides in a source file of its own.
Official description of a 'top-level' term:
7.6. Top Level Type Declarations.
If file doesn't contain public class, interface, enum or annotation,
top-level type is the first type in file.
[Rule]
FinalClass
[Description]
Ensures that identifies classes that can be effectively declared as final are explicitly
marked as final. The following are different types of classes that can be identified:



Private classes with no declared constructors.


Classes with any modifier, and contains only private constructors.



Classes are skipped if:



Class is Super class of some Anonymous inner class.


Class is extended by another class in the same file.
[Rule]
ModifierOrder
[Description]
Checks that the order of modifiers conforms to the suggestions in
the Java
Language specification, ¡ì 8.1.1, 8.3.1, 8.4.3 and

9.4. The correct order is:



public


protected


private


abstract


default


static


sealed


non-sealed


final


transient


volatile


synchronized


native


strictfp



In additional, modifiers are checked to ensure all annotations are
declared before all other modifiers.


Rationale: Code is easier to read if everybody follows a standard.


ATTENTION: We skip

type annotations from validation.
[Rule]
SingleLineJavadoc
[Description]
Checks that a Javadoc block can fit in a single-line and doesn't
contain block tags. Javadoc comment that contains at least one block tag
should be formatted in a few lines.
[Rule]
JavadocTagContinuationIndentation
[Description]
Checks the indentation of the continuation lines in block tags.
That is whether the
continued description of at clauses should be indented or not. If the text is not properly
indented it throws a violation. A continuation line is when the description starts/spans
past the line with the tag. Default indentation required is at least 4, but this can be
changed with the help of properties below.
[Rule]
Indentation
[Description]
Checks correct indentation of Java code.


The idea behind this is that while pretty printers are
sometimes convenient for bulk reformats of legacy code, they often
either aren't configurable enough or just can't anticipate how
format should be done. Sometimes this is personal preference, other
times it is practical experience. In any case, this check should
just ensure that a minimal set of indentation rules is followed.


Basic offset indentation is used for indentation inside code blocks.
For any lines that span more than 1, line wrapping indentation is used for those
lines after the first.
Brace adjustment, case, and throws indentations are all used only if those specific
identifiers start the line. If, for example, a brace is used in the middle of the line,
its indentation will not take effect.
All indentations have an accumulative/recursive effect when they are triggered. If
during a line wrapping, another code block is found and it doesn't end on that same
line, then the subsequent lines afterwards, in that new code block, are increased on
top of the line wrap and any indentations above it.

Example:


if ((condition1 && condition2)
|| (condition3 && condition4)    // line wrap with bigger indentation
||!(condition5 && condition6)) { // line wrap with bigger indentation
field.doSomething()                    // basic offset
.doSomething()                     // line wrap
.doSomething( c -> {               // line wrap
return c.doSome();               // basic offset
});
}

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
