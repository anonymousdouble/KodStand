Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.8.4.3 Presence of the default label
Each switch statement includes a default statement group, even if it contains no code.
 Exception: A switch statement for an enum type may omit the default statement group, if it includes explicit cases covering all possible values of that type. This enables IDEs or other static analysis tools to issue a warning if any cases were missed.

CheckStyle Rules:
[Rule]
MissingSwitchDefault
[Description]
Checks that switch statement has a default clause.


Rationale: It's usually a good idea to introduce a default case in
every switch statement. Even if the developer is sure that all
currently possible cases are covered, this should be expressed in
the default branch, e.g. by using an assertion. This way the code is
protected against later changes, e.g. introduction of new types in an
enumeration type.


This check does not validate any switch expressions. Rationale:
The compiler requires switch expressions to be exhaustive. This means
that all possible inputs must be covered.


This check does not validate switch statements that use pattern or null
labels. Rationale: Switch statements that use pattern or null labels are
checked by the compiler for exhaustiveness. This means that all possible
inputs must be covered.


See the

Java Language Specification for more information about switch statements
and expressions.
[Rule]
DefaultComesLast
[Description]
Check that the default is after all the
cases in a switch statement.


Rationale: Java allows default anywhere
within the switch statement. But it is
more readable if it comes after the last case.
[Rule]
EmptyBlock
[Description]
Checks for empty blocks. This check does not validate sequential blocks.
Sequential blocks won't be checked. Also, no violations for fallthrough:


switch (a) {
case 1:                          // no violation
case 2:                          // no violation
case 3: someMethod(); { }        // no violation
default: break;
}


NOTE: This check processes LITERAL_CASE and LITERAL_DEFAULT separately.
Verification empty block is done for single nearest {@code case} or {@code default}.
[Rule]
NoWhitespaceBeforeCaseDefaultColon
[Description]
Checks that there is no whitespace before the colon in a switch block.
[Rule]
FallThrough
[Description]
Checks for fall-through in switch
statements. Finds locations where a case
contains Java code but lacks a break, return,
yield, throw or continue
statement.


The check honors special comments to suppress the warning.
By default, the texts
"fallthru", "fall thru", "fall-thru",
"fallthrough", "fall through", "fall-through"
"fallsthrough", "falls through", "falls-through" (case-sensitive).
The comment containing these words must be all on one line,
and must be on the last non-empty line before the
case triggering the warning or on
the same line before the case
(ugly, but possible).


Note: The check assumes that there is no unreachable
code in the case.
[Rule]
AvoidNestedBlocks
[Description]
Finds nested blocks (blocks that are used freely in the code).


Rationale: Nested blocks are often leftovers from the
debugging process, they confuse the reader.


For example, this check finds the obsolete braces in



public void guessTheOutput()
{
int whichIsWhich = 0;
{
whichIsWhich = 2;
}
System.out.println("value = " + whichIsWhich);
}

and debugging / refactoring leftovers such as


// if (conditionThatIsNotUsedAnyLonger)
{
System.out.println("unconditional");
}


A case in a switch statement does not implicitly form a block.
Thus, to be able to introduce local variables that have case
scope it is necessary to open a nested block. This is
supported, set the allowInSwitchCase property to true and
include all statements of the case in the block.
[Rule]
OneStatementPerLine
[Description]
Checks that there is only one statement per line.


Rationale: It's very difficult to read multiple statements on one line.


In the Java programming language, statements are the fundamental unit of
execution. All statements except blocks are terminated by a semicolon.
Blocks are denoted by open and close curly braces.


OneStatementPerLineCheck checks the following types of statements:
variable declaration statements, empty statements, import statements,
assignment statements, expression statements, increment statements,
object creation statements, 'for loop' statements, 'break' statements,
'continue' statements, 'return' statements, resources statements (optional).
[Rule]
RightCurly
[Description]
Checks the placement of right curly braces ('}') for code blocks.
This check supports if-else, try-catch-finally blocks, switch statements, switch cases,
while-loops, for-loops, method definitions, class definitions, constructor definitions,
instance, static initialization blocks, annotation definitions and enum definitions.
For right curly brace of expression blocks of arrays, lambdas and class instances
please follow issue
#5945.
For right curly brace of enum constant please follow issue
#7519.
[Rule]
ExplicitInitialization
[Description]
Checks if any class or object member is explicitly initialized to
default for its type value (null for
object references, zero for numeric types and char and false for
boolean.


Rationale: Each instance variable gets initialized twice, to the
same value. Java initializes each instance variable to its default value
(0 or null) before performing any initialization specified in
the code. So there is a minor inefficiency.
[Rule]
EmptyStatement
[Description]
Detects empty statements (standalone ";" semicolon).
Empty statements often introduce bugs that are hard to spot

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
