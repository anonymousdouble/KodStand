Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
5.2.3 Method names
Method names are written in lowerCamelCase .
 Method names are typically verbs or verb phrases. For example, `sendMessage` or `stop` .
 Underscores may appear in JUnit test method names to separate logical components of the name, with each component written in lowerCamelCase , for example `transferMoney_deductsFromSource` . There is no One Correct Way to name test methods.

CheckStyle Rules:
[Rule]
AbbreviationAsWordInName
[Description]
Validates abbreviations (consecutive capital letters) length in identifier name,
it also allows to enforce camel case naming. Please read more at

Google Style Guide
to get to know how to avoid long abbreviations in names.

'_' is considered as word separator in identifier name.

allowedAbbreviationLength specifies how many consecutive capital letters are
allowed in the identifier.
A value of 3 indicates that up to 4 consecutive capital letters are allowed,
one after the other, before a violation is printed. The identifier 'MyTEST' would be
allowed, but 'MyTESTS' would not be.
A value of 0 indicates that only 1 consecutive capital letter is allowed. This
is what should be used to enforce strict camel casing. The identifier 'MyTest' would
be allowed, but 'MyTEst' would not be.


ignoreFinal, ignoreStatic, and ignoreStaticFinal
control whether variables with the respective modifiers are to be ignored.
Note that a variable that is both static and final will always be considered under
ignoreStaticFinal only, regardless of the values of ignoreFinal
and ignoreStatic. So for example if ignoreStatic is true but
ignoreStaticFinal is false, then static final variables will not be ignored.
[Options]
allowedAbbreviationLength, Indicate the number of consecutive capital letters allowed in targeted identifiers (abbreviations in the classes, interfaces, variables and methods names, ... ).
allowedAbbreviations, Specify abbreviations that must be skipped for checking.
ignoreFinal, Allow to skip variables with final modifier.
ignoreOverriddenMethods, Allow to ignore methods tagged with @Override annotation (that usually mean inherited name).
ignoreStatic, Allow to skip variables with static modifier.
ignoreStaticFinal, Allow to skip variables with both static and final modifiers.
tokens, tokens to check
[Rule]
MethodName
[Description]
Checks that method names conform to a specified pattern.


Also, checks if a method name has the same name as the residing class.
The default is false (it is not allowed). It is legal in Java to have
method with the same name as a class. As long as a return type is specified
it is a method and not a constructor which it could be easily confused as.
Does not check-style the name of an overridden methods because the developer
does not have a choice in renaming such methods.
[Options]
allowClassName, Control whether to allow a method name to have the same name as the enclosing class name. Setting this property false helps to avoid confusion between constructors and methods.
applyToPackage, Control if check should apply to package-private members.
applyToPrivate, Control if check should apply to private members.
applyToProtected, Control if check should apply to protected members.
applyToPublic, Control if check should apply to public members.
format, Sets the pattern to match valid identifiers.
[Rule]
CatchParameterName
[Description]
Checks that catch parameter names conform to a specified pattern.


Default pattern has the following characteristic:


allows names beginning with two lowercase letters followed by at least one uppercase
or lowercase letter
allows e abbreviation (suitable for exceptions end errors)
allows ex abbreviation (suitable for exceptions)
allows t abbreviation (suitable for throwables)
prohibits numbered abbreviations like e1 or t2
prohibits one letter prefixes like pException
prohibits two letter abbreviations like ie or ee
prohibits any other characters than letters
[Options]
format, Sets the pattern to match valid identifiers.
[Rule]
HideUtilityClassConstructor
[Description]
Makes sure that utility classes (classes that contain only static
methods or fields in their API) do not have a public constructor.


Rationale: Instantiating utility classes does not make sense. Hence,
the constructors should either be private or (if you want to allow
subclassing) protected. A common mistake is forgetting to hide the
default constructor.


If you make the constructor protected you may want to consider the
following constructor implementation technique to disallow
instantiating subclasses:



public class StringUtils // not final to allow subclassing
{
protected StringUtils() {
// prevents calls from subclass
throw new UnsupportedOperationException();
}

public static int count(char c, String s) {
// ...
}
}
[Options]
[Rule]
MemberName
[Description]
Checks that instance variable names conform to a specified pattern.
[Options]
applyToPackage, Control if check should apply to package-private members.
applyToPrivate, Control if check should apply to private members.
applyToProtected, Control if check should apply to protected members.
applyToPublic, Control if check should apply to public members.
format, Sets the pattern to match valid identifiers.
[Rule]
RequireThis
[Description]
Checks that references to instance variables and methods of the present
object are explicitly of the form "this.varName" or
"this.methodName(args)" and that those references don't
rely on the default behavior when "this." is absent.


Warning: the Check is very controversial if 'validateOnlyOverlapping' option is set to
'false' and not that actual nowadays.


Rationale:



The same notation/habit for C++ and Java (C++ have global methods, so having
"this." do make sense in it to distinguish call of method of class
instead of global).


Non-IDE development (ease of refactoring, some clearness to distinguish
static and non-static methods).
[Options]
checkFields, Control whether to check references to fields.
checkMethods, Control whether to check references to methods.
validateOnlyOverlapping, Control whether to check only overlapping by variables or arguments.
[Rule]
ModifierOrder
[Description]
Checks that the order of modifiers conforms to the suggestions in
the Java
Language specification, ¡ì 8.1.1, 8.3.1, 8.4.3 and

9.4. The correct order is:



public


protected


private


abstract


default


static


sealed


non-sealed


final


transient


volatile


synchronized


native


strictfp



In additional, modifiers are checked to ensure all annotations are
declared before all other modifiers.


Rationale: Code is easier to read if everybody follows a standard.


ATTENTION: We skip

type annotations from validation.
[Options]
[Rule]
MethodCount
[Description]
Checks the number of methods declared in each type declaration by access modifier or
total count.


This check can be configured to flag classes that define too many methods to prevent the
class from getting too complex.
Counting can be customized to prevent too many total methods in a type definition
(maxTotal), or to prevent too many methods of a specific access modifier
(private, package, protected or
public).
Each count is completely separated to customize how many methods of each you want to
allow. For example, specifying a maxTotal of 10, still means you can
prevent more than 0 maxPackage methods. A violation won't appear for 8
public methods, but one will appear if there is also 3 private methods or any
package-private methods.


Methods defined in anonymous classes are not counted towards any totals.
Counts only go towards the main type declaration parent, and are kept separate from it's
children's inner types.



public class ExampleClass {
public enum Colors {
RED, GREEN, YELLOW;

public String getRGB() { ... } // NOT counted towards ExampleClass
}

public void example() { // counted towards ExampleClass
Runnable r = (new Runnable() {
public void run() { ... } // NOT counted towards ExampleClass, won't produce any violations
});
}

public static class InnerExampleClass {
protected void example2() { ... } // NOT counted towards ExampleClass,
// but counted towards InnerExampleClass
}
}
[Options]
maxPackage, Specify the maximum number of package methods allowed.
maxPrivate, Specify the maximum number of private methods allowed.
maxProtected, Specify the maximum number of protected methods allowed.
maxPublic, Specify the maximum number of public methods allowed.
maxTotal, Specify the maximum number of methods allowed at all scope levels.
tokens, tokens to check
[Rule]
ParameterName
[Description]
Checks that method parameter names conform to a specified pattern.
By using accessModifiers property it is possible
to specify different formats for methods at different visibility levels.


To validate catch parameters please use

CatchParameterName
.


To validate lambda parameters please use

LambdaParameterName
.
[Options]
accessModifiers, Access modifiers of methods where parameters are checked.
format, Sets the pattern to match valid identifiers.
ignoreOverridden, Allows to skip methods with Override annotation from validation.
[Rule]
DeclarationOrder
[Description]
Checks that the parts of a class, record, or interface declaration appear in the order
suggested by the

Code Conventions for the Java Programming Language.


According to

Code Conventions for the Java Programming Language , the parts
of a class or interface declaration should appear in the following
order:



Class (static) variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.


Instance variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.

Constructors
Methods


Purpose of ignore* option is to ignore related violations,
however it still impacts on other class members.


ATTENTION: the check skips class fields which have

forward references
from validation due to the fact that we have Checkstyle's limitations to clearly
detect user intention of fields location and grouping. For example:



public class A {
private double x = 1.0;
private double y = 2.0;
public double slope = x / y; // will be skipped from validation due to forward reference
}
[Options]
ignoreConstructors, Control whether to ignore constructors.
ignoreModifiers, Control whether to ignore modifiers (fields, ...).

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
