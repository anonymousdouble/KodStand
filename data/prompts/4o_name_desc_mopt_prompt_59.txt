Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
3.4.2.1 Overloads: never split
Methods of a class that share the same name appear in a single contiguous group with no other members in between. The same applies to multiple constructors (which always have the same name). This rule applies even when modifiers such as static or private differ between the methods.

CheckStyle Rules:
[Rule]
OverloadMethodsDeclarationOrder
[Description]
Checks that overloaded methods are grouped together. Overloaded methods have the same
name but different signatures where the signature can differ by the number of input
parameters or type of input parameters or both.
[Options]
[Rule]
HideUtilityClassConstructor
[Description]
Makes sure that utility classes (classes that contain only static
methods or fields in their API) do not have a public constructor.


Rationale: Instantiating utility classes does not make sense. Hence,
the constructors should either be private or (if you want to allow
subclassing) protected. A common mistake is forgetting to hide the
default constructor.


If you make the constructor protected you may want to consider the
following constructor implementation technique to disallow
instantiating subclasses:



public class StringUtils // not final to allow subclassing
{
protected StringUtils() {
// prevents calls from subclass
throw new UnsupportedOperationException();
}

public static int count(char c, String s) {
// ...
}
}
[Options]
[Rule]
ModifierOrder
[Description]
Checks that the order of modifiers conforms to the suggestions in
the Java
Language specification, ¡ì 8.1.1, 8.3.1, 8.4.3 and

9.4. The correct order is:



public


protected


private


abstract


default


static


sealed


non-sealed


final


transient


volatile


synchronized


native


strictfp



In additional, modifiers are checked to ensure all annotations are
declared before all other modifiers.


Rationale: Code is easier to read if everybody follows a standard.


ATTENTION: We skip

type annotations from validation.
[Options]
[Rule]
DeclarationOrder
[Description]
Checks that the parts of a class, record, or interface declaration appear in the order
suggested by the

Code Conventions for the Java Programming Language.


According to

Code Conventions for the Java Programming Language , the parts
of a class or interface declaration should appear in the following
order:



Class (static) variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.


Instance variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.

Constructors
Methods


Purpose of ignore* option is to ignore related violations,
however it still impacts on other class members.


ATTENTION: the check skips class fields which have

forward references
from validation due to the fact that we have Checkstyle's limitations to clearly
detect user intention of fields location and grouping. For example:



public class A {
private double x = 1.0;
private double y = 2.0;
public double slope = x / y; // will be skipped from validation due to forward reference
}
[Options]
ignoreConstructors, Control whether to ignore constructors.
ignoreModifiers, Control whether to ignore modifiers (fields, ...).
[Rule]
ConstantName
[Description]
Checks that constant names conform to a specified pattern.
A constant is a static and final field or an
interface/annotation field, except serialVersionUID and
serialPersistentFields.
[Options]
applyToPackage, Control if check should apply to package-private members.
applyToPrivate, Control if check should apply to private members.
applyToProtected, Control if check should apply to protected members.
applyToPublic, Control if check should apply to public members.
format, Sets the pattern to match valid identifiers.
[Rule]
EqualsHashCode
[Description]
Checks that classes that either override equals()
or hashCode() also overrides the other.
This check only verifies that the method declarations match
Object.equals(Object) and Object.hashCode() exactly to be
considered an override. This check does not verify invalid method names, parameters
other than Object, or anything else.


Rationale: The contract of equals() and
hashCode() requires that equal objects
have the same hashCode. Therefore, whenever you override
equals() you must override hashCode()
to ensure that your class can be used in hash-based collections.
[Options]
[Rule]
AvoidStaticImport
[Description]
Checks that there are no static import statements.


Rationale: Importing static members can lead to naming
conflicts between class' members. It may lead to poor code
readability since it may no longer be clear what class a
member resides in (without looking at the import statement).
[Options]
excludes, Control whether to allow for certain classes via a star notation to be excluded such as java.lang.Math.* or specific static members to be excluded like java.lang.System.out for a variable or java.lang.Math.random for a method. See notes section for details.
[Rule]
NoClone
[Description]
Checks that the clone method is not overridden from the
Object class.


This check is almost exactly the same as the NoFinalizerCheck.


See
Object.clone()


Rationale: The clone method relies on strange, hard to follow rules that
are difficult to get right and do not work in all situations.
In some cases, either a copy constructor
or a static factory method can be used instead of the clone method
to return copies of an object.
For more information on rules for the clone method and its issues, see Effective Java:
Programming Language Guide First Edition by Joshua Bloch
pages 45-52.


Below are some rules/reasons why the clone method should be avoided.



Classes supporting the clone method should implement the Cloneable interface
but the Cloneable interface does not include the clone method.
As a result, it doesn't enforce the method override.


The Cloneable interface forces the Object's clone method to work correctly.
Without implementing it, the Object's clone method will throw a
CloneNotSupportedException.


Non-final classes must return the object returned from a call to super.clone().


Final classes can use a constructor to create a clone which is different
from non-final classes.


If a super class implements the clone method incorrectly all subclasses calling
super.clone() are doomed to failure.


If a class has references to mutable objects then those object references must be
replaced with copies in the clone method after calling super.clone().


The clone method does not work correctly with final mutable object references because
final references cannot be reassigned.


If a super class overrides the clone method then all subclasses must provide a correct
clone implementation.



Two alternatives to the clone method, in some cases, is a copy constructor or a static
factory method to return copies of an object. Both of these approaches are simpler and
do not conflict with final fields. They do not force the calling client to handle a
CloneNotSupportedException.  They also are typed therefore no casting is necessary.
Finally, they are more flexible since they can take interface types rather than concrete
classes.


Sometimes a copy constructor or static factory is not an acceptable alternative to the
clone method.  The example below highlights the limitation of a copy constructor
(or static factory). Assume Square is a subclass for Shape.



Shape s1 = new Square();
System.out.println(s1 instanceof Square); //true


...assume at this point the code knows nothing of s1 being a Square that's the beauty
of polymorphism but the code wants to copy the Square which is declared as a Shape,
its super type...



Shape s2 = new Shape(s1); //using the copy constructor
System.out.println(s2 instanceof Square); //false


The working solution (without knowing about all subclasses and doing many casts) is to do
the following (assuming correct clone implementation).



Shape s2 = s1.clone();
System.out.println(s2 instanceof Square); //true


Just keep in mind if this type of polymorphic cloning is required then a properly
implemented clone method may be the best choice.


Much of this information was taken from Effective Java: Programming Language Guide First
Edition by Joshua Bloch pages 45-52.  Give Bloch credit for writing an excellent book.
[Options]
[Rule]
ImportOrder
[Description]
Checks the ordering/grouping of imports. Features are:

groups type/static imports: ensures that groups of imports come in a
specific order (e.g., java. comes first, javax. comes second,
then everything else)
adds a separation between type import groups : ensures that a blank
line sit between each group
type/static import groups aren't separated internally: ensures that
each group aren't separated internally by blank line or comment
sorts type/static imports inside each group: ensures that imports
within each group are in lexicographic order

sorts according to case: ensures that the comparison
between imports is case-sensitive, in
ASCII sort order


arrange static imports: ensures the relative order between
type imports and static imports (see
ImportOrderOption)
[Options]
caseSensitive, Control whether string comparison should be case-sensitive or not. Case-sensitive sorting is in ASCII sort order. It affects both type imports and static imports.
groups, Specify list of type import groups. Every group identified either by a common prefix string, or by a regular expression enclosed in forward slashes (e.g. /regexp/). All type imports, which does not match any group, falls into an additional group, located at the end. Thus, the empty list of type groups (the default value) means one group for all type imports.
option, Specify policy on the relative order between type imports and static imports.
ordered, Control whether type imports within each group should be sorted. It doesn't affect sorting for static imports.
separated, Control whether type import groups should be separated by, at least, one blank line or comment and aren't separated internally. It doesn't affect separations for static imports.
separatedStaticGroups, Control whether static import groups should be separated by, at least, one blank line or comment and aren't separated internally. This property has effect only when the property option is set to top or bottom and when property staticGroups is enabled.
sortStaticImportsAlphabetically, Control whether static imports located at top or bottom are sorted within the group.
staticGroups, Specify list of static import groups. Every group identified either by a common prefix string, or by a regular expression enclosed in forward slashes (e.g. /regexp/). All static imports, which does not match any group, fall into an additional group, located at the end. Thus, the empty list of static groups (the default value) means one group for all static imports. This property has effect only when the property option is set to top or bottom.
useContainerOrderingForStatic, Control whether to use container ordering (Eclipse IDE term) for static imports or not.
[Rule]
OneTopLevelClass
[Description]
Checks that each top-level class, interface, enum
or annotation resides in a source file of its own.
Official description of a 'top-level' term:
7.6. Top Level Type Declarations.
If file doesn't contain public class, interface, enum or annotation,
top-level type is the first type in file.
[Options]

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
