Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
7.3.2 Exception: overrides
Javadoc is not always present on a method that overrides a supertype method.

CheckStyle Rules:
[Rule]
DesignForExtension
[Description]
Checks that classes are designed for extension (subclass creation).


Nothing wrong could be with founded classes.
This check makes sense only for library projects (not application projects)
which care of ideal OOP-design to make sure that class works in all cases even misusage.
Even in library projects this check most likely will find classes that are designed
for extension by somebody. User needs to use suppressions extensively to got a benefit
from this check, and keep in suppressions all confirmed/known classes that are deigned
for inheritance intentionally to let the check catch only new classes, and bring this to
team/user attention.


ATTENTION: Only user can decide whether a class is designed for extension or not.
The check just shows all classes which are possibly designed for extension.
If smth inappropriate is found please use suppression.


ATTENTION: If the method which can be overridden in a subclass has a javadoc comment
(a good practice is to explain its self-use of overridable methods) the check will not
rise a violation. The violation can also be skipped if the method which can be overridden
in a subclass has one or more annotations that are specified in ignoredAnnotations
option. Note, that by default @Override annotation is not included in the
ignoredAnnotations set as in a subclass the method which has the annotation can also be
overridden in its subclass.


Problem is described at "Effective Java, 2nd Edition by Joshua Bloch" book, chapter
"Item 17: Design and document for inheritance or else prohibit it".


Some quotes from book:

The class must document its self-use of overridable methods.
By convention, a method that invokes overridable methods contains a description
of these invocations at the end of its documentation comment. The description
begins with the phrase ¡°This implementation.¡±

The best solution to this problem is to prohibit subclassing in classes that
are not designed and documented to be safely subclassed.

If a concrete class does not implement a standard interface, then you may
inconvenience some programmers by prohibiting inheritance. If you feel that you
must allow inheritance from such a class, one reasonable approach is to ensure
that the class never invokes any of its overridable methods and to document this
fact. In other words, eliminate the class¡¯s self-use of overridable methods entirely.
In doing so, you¡¯ll create a class that is reasonably safe to subclass. Overriding a
method will never affect the behavior of any other method.


The check finds classes that have overridable methods (public or protected methods
that are non-static, not-final, non-abstract) and have non-empty implementation.


Rationale: This library design style protects superclasses against
being broken by subclasses. The downside is that subclasses are
limited in their flexibility, in particular they cannot prevent
execution of code in the superclass, but that also means that
subclasses cannot corrupt the state of the superclass by forgetting
to call the superclass's method.


More specifically,
it enforces a programming style where superclasses provide empty
"hooks" that can be implemented by subclasses.


Example of code that cause violation as it is designed for extension:



public abstract class Plant {
private String roots;
private String trunk;

protected void validate() {
if (roots == null) throw new IllegalArgumentException("No roots!");
if (trunk == null) throw new IllegalArgumentException("No trunk!");
}

public abstract void grow();
}

public class Tree extends Plant {
private List leaves;

@Overrides
protected void validate() {
super.validate();
if (leaves == null) throw new IllegalArgumentException("No leaves!");
}

public void grow() {
validate();
}
}


Example of code without violation:



public abstract class Plant {
private String roots;
private String trunk;

private void validate() {
if (roots == null) throw new IllegalArgumentException("No roots!");
if (trunk == null) throw new IllegalArgumentException("No trunk!");
validateEx();
}

protected void validateEx() { }

public abstract void grow();
}
[Options]
ignoredAnnotations, Specify annotations which allow the check to skip the method from validation.
requiredJavadocPhrase, Specify the comment text pattern which qualifies a method as designed for extension. Supports multi-line regex.
[Rule]
MissingDeprecated
[Description]
Verifies that the annotation @Deprecated and the Javadoc tag
@deprecated are both present when either of them is present.


Both ways of flagging deprecation serve their own purpose.
The @Deprecated annotation is used for compilers and development tools.
The @deprecated javadoc tag is used to document why something is deprecated
and what, if any, alternatives exist.


In order to properly mark something as deprecated both forms of
deprecation should be present.


Package deprecation is an exception to the rule of always using the
javadoc tag and annotation to deprecate.  It is not clear if the
javadoc tool will support it or not as newer versions keep flip-flopping
on if it is supported or will cause an error.
See
JDK-8160601.
The deprecated javadoc tag is currently the only way to say why the package
is deprecated and what to use instead.  Until this is resolved, if you
don't want to print violations on package-info, you can use a
filter to ignore these files until
the javadoc tool faithfully supports it. An example config using
SuppressionSingleFilter is:



<!-- required till https://bugs.openjdk.org/browse/JDK-8160601 -->
<module name="SuppressionSingleFilter">
<property name="checks" value="MissingDeprecatedCheck"/>
<property name="files" value="package-info\.java"/>
</module>
[Options]
violateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at
Tight-HTML Rules.
[Rule]
MissingOverride
[Description]
Verifies that the @Override annotation is present
when the @inheritDoc javadoc tag is present.


Rationale: The @Override annotation helps
compiler tools ensure that an override is actually occurring.  It is
quite easy to accidentally overload a method or hide a static method
and using the @Override annotation points out these problems.


This check will log a violation if using the @inheritDoc tag on a method that
is not valid (ex: private, or static method).


There is a slight difference between the @Override annotation in Java 5 versus
Java 6 and above. In Java 5, any method overridden from an interface cannot
be annotated with @Override. In Java 6 this behavior is allowed.


As a result of the aforementioned difference between Java 5 and Java 6, a
property called javaFiveCompatibility is available. This
property will only check classes, interfaces, etc. that do not contain the
extends or implements keyword or are not anonymous classes. This means it
only checks methods overridden from java.lang.Object.
Java 5 Compatibility mode severely limits this check. It is recommended to
only use it on Java 5 source.
[Options]
javaFiveCompatibility, Enable java 5 compatibility mode.
[Rule]
InvalidJavadocPosition
[Description]
Checks that Javadocs are located at the correct position.
As specified at

Documentation Comment Specification for the Standard Doclet,
Javadocs are recognized only when placed immediately before module, package, class,
interface, constructor, method, or field declarations. Any other position, like
in the body of a method, will be ignored by the javadoc tool and is considered
invalid by this check.
[Options]
[Rule]
SuperClone
[Description]
Checks that an overriding clone() method invokes
super.clone(). Does not check native methods, as
they have no possible java defined implementation.


Reference:
Object.clone().
[Options]
[Rule]
SuperFinalize
[Description]
Checks that an overriding finalize() method invokes
super.finalize(). Does not check native methods, as
they have no possible java defined implementation.


References:

How to Handle Java Finalization's Memory-Retention Issues;

10 points on finalize method in Java.
[Options]
[Rule]
MissingJavadocPackage
[Description]
Checks for missing package definition Javadoc comments in package-info.java files.


Rationale: description and other related documentation for a package can be written up
in the package-info.java file and it gets used in the production of the Javadocs.
See
link for more info.


This check specifically only validates package definitions. It will not validate any
methods or interfaces declared in the package-info.java file.
[Options]
[Rule]
JavadocMethod
[Description]
Checks the Javadoc of a method or constructor.


Violates parameters and type parameters
for which no param tags are
present can be suppressed by defining property
allowMissingParamTags.


Violates methods which return non-void but for which no return tag is
present can be suppressed by defining property
allowMissingReturnTag.


Violates exceptions which are declared to be thrown (by throws in the method
signature or by throw new in the method body), but for which no throws tag is
present by activation of property validateThrows.
Note that throw new is not checked in the following places:



Inside a try block (with catch). It is not possible to determine if the thrown
exception can be caught by the catch block as there is no knowledge of the
inheritance hierarchy, so the try block is ignored entirely. However, catch
and finally blocks, as well as try blocks without catch, are still checked.


Local classes, anonymous classes and lambda expressions. It is not known when the
throw statements inside such classes are going to be evaluated, so they are ignored.



ATTENTION: Checkstyle does not have information about hierarchy of exception types
so usage of base class is considered as separate exception type.
As workaround, you need to specify both types in javadoc (parent and exact type).


Javadoc is not required on a method that is tagged with the
@Override annotation. However, under
Java 5 it is not possible to mark a method required for an
interface (this was corrected under Java 6). Hence,
Checkstyle supports using the convention of using a single
{@inheritDoc} tag instead of all the
other tags.


Note that only inheritable items will allow the
{@inheritDoc} tag to be used in place
of comments. Static methods at all visibilities, private non-static
methods and constructors are not inheritable.


For example, if the following method is
implementing a method required by an interface, then the
Javadoc could be done as:



/** {@inheritDoc} */
public int checkReturnTag(final int aTagIndex,
JavadocTag[] aTags,
int aLineNo)
[Options]
accessModifiers, Specify the access modifiers where Javadoc comments are checked.
allowMissingParamTags, Control whether to ignore violations when a method has parameters but does not have matching param tags in the javadoc.
allowMissingReturnTag, Control whether to ignore violations when a method returns non-void type and does not have a return tag in the javadoc.
allowedAnnotations, Specify annotations that allow missed documentation.
validateThrows, Control whether to validate throws tags.
tokens, tokens to check
[Rule]
JavadocContentLocation
[Description]
Checks that the Javadoc content begins from the same position
for all Javadoc comments in the project. Any leading asterisks and spaces
are not counted as the beginning of the content and are therefore ignored.


It is possible to enforce two different styles:



{@code first_line} - Javadoc content starts from the first line:



/** Summary text.
* More details.
*/
public void method();



{@code second_line} - Javadoc content starts from the second line:



/**
* Summary text.
* More details.
*/
public void method();
[Options]
location, Specify the policy on placement of the Javadoc content.
[Rule]
IllegalThrows
[Description]
Checks that specified types are not declared to be thrown.
Declaring that a method throws java.lang.Error or
java.lang.RuntimeException is almost never acceptable.
[Options]
ignoreOverriddenMethods, Allow to ignore checking overridden methods (marked with Override or java.lang.Override annotation).
ignoredMethodNames, Specify names of methods to ignore.
illegalClassNames, Specify throw class names to reject.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
