Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
5.2.2 Class names
Class names are written in UpperCamelCase .
 Class names are typically nouns or noun phrases. For example, `Character` or `ImmutableList` . Interface names may also be nouns or noun phrases (for example, `List` ), but may sometimes be adjectives or adjective phrases instead (for example, `Readable` ).
 There are no specific rules or even well-established conventions for naming annotation types.
 A test class has a name that ends with `Test` , for example, `HashIntegrationTest` . If it covers a single class, its name is the name of that class plus `Test` , for example `HashImplTest` .

CheckStyle Rules:
[Rule]
OneTopLevelClass
[Description]
Checks that each top-level class, interface, enum
or annotation resides in a source file of its own.
Official description of a 'top-level' term:
7.6. Top Level Type Declarations.
If file doesn't contain public class, interface, enum or annotation,
top-level type is the first type in file.
[Options]
[Rule]
AbbreviationAsWordInName
[Description]
Validates abbreviations (consecutive capital letters) length in identifier name,
it also allows to enforce camel case naming. Please read more at

Google Style Guide
to get to know how to avoid long abbreviations in names.

'_' is considered as word separator in identifier name.

allowedAbbreviationLength specifies how many consecutive capital letters are
allowed in the identifier.
A value of 3 indicates that up to 4 consecutive capital letters are allowed,
one after the other, before a violation is printed. The identifier 'MyTEST' would be
allowed, but 'MyTESTS' would not be.
A value of 0 indicates that only 1 consecutive capital letter is allowed. This
is what should be used to enforce strict camel casing. The identifier 'MyTest' would
be allowed, but 'MyTEst' would not be.


ignoreFinal, ignoreStatic, and ignoreStaticFinal
control whether variables with the respective modifiers are to be ignored.
Note that a variable that is both static and final will always be considered under
ignoreStaticFinal only, regardless of the values of ignoreFinal
and ignoreStatic. So for example if ignoreStatic is true but
ignoreStaticFinal is false, then static final variables will not be ignored.
[Options]
allowedAbbreviationLength, Indicate the number of consecutive capital letters allowed in targeted identifiers (abbreviations in the classes, interfaces, variables and methods names, ... ).
allowedAbbreviations, Specify abbreviations that must be skipped for checking.
ignoreFinal, Allow to skip variables with final modifier.
ignoreOverriddenMethods, Allow to ignore methods tagged with @Override annotation (that usually mean inherited name).
ignoreStatic, Allow to skip variables with static modifier.
ignoreStaticFinal, Allow to skip variables with both static and final modifiers.
tokens, tokens to check
[Rule]
ModifierOrder
[Description]
Checks that the order of modifiers conforms to the suggestions in
the Java
Language specification, ¡ì 8.1.1, 8.3.1, 8.4.3 and

9.4. The correct order is:



public


protected


private


abstract


default


static


sealed


non-sealed


final


transient


volatile


synchronized


native


strictfp



In additional, modifiers are checked to ensure all annotations are
declared before all other modifiers.


Rationale: Code is easier to read if everybody follows a standard.


ATTENTION: We skip

type annotations from validation.
[Options]
[Rule]
DesignForExtension
[Description]
Checks that classes are designed for extension (subclass creation).


Nothing wrong could be with founded classes.
This check makes sense only for library projects (not application projects)
which care of ideal OOP-design to make sure that class works in all cases even misusage.
Even in library projects this check most likely will find classes that are designed
for extension by somebody. User needs to use suppressions extensively to got a benefit
from this check, and keep in suppressions all confirmed/known classes that are deigned
for inheritance intentionally to let the check catch only new classes, and bring this to
team/user attention.


ATTENTION: Only user can decide whether a class is designed for extension or not.
The check just shows all classes which are possibly designed for extension.
If smth inappropriate is found please use suppression.


ATTENTION: If the method which can be overridden in a subclass has a javadoc comment
(a good practice is to explain its self-use of overridable methods) the check will not
rise a violation. The violation can also be skipped if the method which can be overridden
in a subclass has one or more annotations that are specified in ignoredAnnotations
option. Note, that by default @Override annotation is not included in the
ignoredAnnotations set as in a subclass the method which has the annotation can also be
overridden in its subclass.


Problem is described at "Effective Java, 2nd Edition by Joshua Bloch" book, chapter
"Item 17: Design and document for inheritance or else prohibit it".


Some quotes from book:

The class must document its self-use of overridable methods.
By convention, a method that invokes overridable methods contains a description
of these invocations at the end of its documentation comment. The description
begins with the phrase ¡°This implementation.¡±

The best solution to this problem is to prohibit subclassing in classes that
are not designed and documented to be safely subclassed.

If a concrete class does not implement a standard interface, then you may
inconvenience some programmers by prohibiting inheritance. If you feel that you
must allow inheritance from such a class, one reasonable approach is to ensure
that the class never invokes any of its overridable methods and to document this
fact. In other words, eliminate the class¡¯s self-use of overridable methods entirely.
In doing so, you¡¯ll create a class that is reasonably safe to subclass. Overriding a
method will never affect the behavior of any other method.


The check finds classes that have overridable methods (public or protected methods
that are non-static, not-final, non-abstract) and have non-empty implementation.


Rationale: This library design style protects superclasses against
being broken by subclasses. The downside is that subclasses are
limited in their flexibility, in particular they cannot prevent
execution of code in the superclass, but that also means that
subclasses cannot corrupt the state of the superclass by forgetting
to call the superclass's method.


More specifically,
it enforces a programming style where superclasses provide empty
"hooks" that can be implemented by subclasses.


Example of code that cause violation as it is designed for extension:



public abstract class Plant {
private String roots;
private String trunk;

protected void validate() {
if (roots == null) throw new IllegalArgumentException("No roots!");
if (trunk == null) throw new IllegalArgumentException("No trunk!");
}

public abstract void grow();
}

public class Tree extends Plant {
private List leaves;

@Overrides
protected void validate() {
super.validate();
if (leaves == null) throw new IllegalArgumentException("No leaves!");
}

public void grow() {
validate();
}
}


Example of code without violation:



public abstract class Plant {
private String roots;
private String trunk;

private void validate() {
if (roots == null) throw new IllegalArgumentException("No roots!");
if (trunk == null) throw new IllegalArgumentException("No trunk!");
validateEx();
}

protected void validateEx() { }

public abstract void grow();
}
[Options]
ignoredAnnotations, Specify annotations which allow the check to skip the method from validation.
requiredJavadocPhrase, Specify the comment text pattern which qualifies a method as designed for extension. Supports multi-line regex.
[Rule]
FinalClass
[Description]
Ensures that identifies classes that can be effectively declared as final are explicitly
marked as final. The following are different types of classes that can be identified:



Private classes with no declared constructors.


Classes with any modifier, and contains only private constructors.



Classes are skipped if:



Class is Super class of some Anonymous inner class.


Class is extended by another class in the same file.
[Options]
[Rule]
InterfaceIsType
[Description]
Implements Joshua Bloch, Effective Java, Item 17 - Use Interfaces only to
define types.


According to Bloch, an interface should describe a type.
It is therefore inappropriate to define an interface that does not
contain any methods but only constants. The Standard interface
javax.swing.SwingConstants
is an example of an interface that would be flagged by this check.


The check can be configured to also disallow marker interfaces like
java.io.Serializable, that do not contain methods or
constants at all.
[Options]
allowMarkerInterfaces, Control whether marker interfaces like Serializable are allowed.
[Rule]
DeclarationOrder
[Description]
Checks that the parts of a class, record, or interface declaration appear in the order
suggested by the

Code Conventions for the Java Programming Language.


According to

Code Conventions for the Java Programming Language , the parts
of a class or interface declaration should appear in the following
order:



Class (static) variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.


Instance variables. First the public class variables, then
protected, then package level (no access modifier), and then
private.

Constructors
Methods


Purpose of ignore* option is to ignore related violations,
however it still impacts on other class members.


ATTENTION: the check skips class fields which have

forward references
from validation due to the fact that we have Checkstyle's limitations to clearly
detect user intention of fields location and grouping. For example:



public class A {
private double x = 1.0;
private double y = 2.0;
public double slope = x / y; // will be skipped from validation due to forward reference
}
[Options]
ignoreConstructors, Control whether to ignore constructors.
ignoreModifiers, Control whether to ignore modifiers (fields, ...).
[Rule]
VisibilityModifier
[Description]
Checks visibility of class members. Only static final, immutable or annotated
by specified annotation members may be public; other class members must be private
unless the property protectedAllowed or packageAllowed is set.


Public members are not flagged if the name matches the public
member regular expression (contains "^serialVersionUID$" by default).

Note that
Checkstyle 2 used to include "^f[A-Z][a-zA-Z0-9]*$" in the default
pattern to allow names used in container-managed persistence for Enterprise JavaBeans
(EJB) 1.1 with the default settings. With EJB 2.0 it is no longer necessary to have
public access for persistent fields, so the default has been changed.


Rationale: Enforce encapsulation.


Check also has options making it less strict:


ignoreAnnotationCanonicalNames - the list of annotations which ignore variables
in consideration. If user want to provide short annotation name that type
will match to any named the same type without consideration of package.


allowPublicFinalFields - which allows public final fields.


allowPublicImmutableFields - which allows immutable fields to be declared as
public if defined in final class.


Field is known to be immutable if:


It's declared as final

Has either a primitive type or instance of class user defined to be immutable
(such as String, ImmutableCollection from Guava, etc.)



Classes known to be immutable are listed in immutableClassCanonicalNames by their
canonical names.


Property Rationale: Forcing all fields of class to have private modifier by default is
good in most cases, but in some cases it drawbacks in too much boilerplate get/set code.
One of such cases are immutable classes.


Restriction: Check doesn't check if class is immutable, there's no
checking if accessory methods are missing and all fields are immutable, we only check
if current field is immutable or final. Under the flag
allowPublicImmutableFields, the enclosing class must also be final, to encourage
immutability. Under the flag allowPublicFinalFields, the final modifier on
the enclosing class is optional.


Star imports are out of scope of this Check. So if one of type imported via
star import collides with user specified one by its short name -
there won't be Check's violation.
[Options]
allowPublicFinalFields, Allow final fields to be declared as public.
allowPublicImmutableFields, Allow immutable fields to be declared as public if defined in final class.
ignoreAnnotationCanonicalNames, Specify annotations canonical names which ignore variables in consideration.
immutableClassCanonicalNames, Specify immutable classes canonical names.
packageAllowed, Control whether package visible members are allowed.
protectedAllowed, Control whether protected members are allowed.
publicMemberPattern, Specify pattern for public members that should be ignored.
[Rule]
HideUtilityClassConstructor
[Description]
Makes sure that utility classes (classes that contain only static
methods or fields in their API) do not have a public constructor.


Rationale: Instantiating utility classes does not make sense. Hence,
the constructors should either be private or (if you want to allow
subclassing) protected. A common mistake is forgetting to hide the
default constructor.


If you make the constructor protected you may want to consider the
following constructor implementation technique to disallow
instantiating subclasses:



public class StringUtils // not final to allow subclassing
{
protected StringUtils() {
// prevents calls from subclass
throw new UnsupportedOperationException();
}

public static int count(char c, String s) {
// ...
}
}
[Options]
[Rule]
AbstractClassName
[Description]
Ensures that the names of abstract classes conforming to some pattern and
check that abstract modifier exists.


Rationale: Abstract classes are convenience base class implementations of
interfaces. For this reason, it should be made obvious that a given class
is abstract by prefacing the class name with 'Abstract'.
[Options]
format, Specify valid identifiers.
ignoreModifier, Control whether to ignore checking for the abstract modifier on classes that match the name.
ignoreName, Control whether to ignore checking the name. Realistically only useful if using the check to identify that match name and do not have the abstract modifier.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
