Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
7.3.4 Non-required Javadoc
Other classes and members have Javadoc as needed or desired .
 Whenever an implementation comment would be used to define the overall purpose or behavior of a class or member, that comment is written as Javadoc instead (using `/**` ).
 Non-required Javadoc is not strictly required to follow the formatting rules of Sections 7.1.1, 7.1.2, 7.1.3, and 7.2, though it is of course recommended.

CheckStyle Rules:
[Rule]
MissingJavadocPackage
[Description]
Checks for missing package definition Javadoc comments in package-info.java files.


Rationale: description and other related documentation for a package can be written up
in the package-info.java file and it gets used in the production of the Javadocs.
See
link for more info.


This check specifically only validates package definitions. It will not validate any
methods or interfaces declared in the package-info.java file.
[Options]
[Rule]
InvalidJavadocPosition
[Description]
Checks that Javadocs are located at the correct position.
As specified at

Documentation Comment Specification for the Standard Doclet,
Javadocs are recognized only when placed immediately before module, package, class,
interface, constructor, method, or field declarations. Any other position, like
in the body of a method, will be ignored by the javadoc tool and is considered
invalid by this check.
[Options]
[Rule]
JavadocStyle
[Description]
Validates Javadoc comments to help ensure they are well formed.


The following checks are performed:



Ensures the first sentence ends with proper punctuation
(That is a period, question mark, or exclamation mark, by default).
Note that this check is not applied to inline @return tags,
because the Javadoc tools automatically appends a period to the end of the tag
content.
Javadoc automatically places the first sentence in the
method summary table and index. Without proper punctuation
the Javadoc may be malformed. All items eligible for the
{@inheritDoc} tag are exempt from this
requirement.


Check text for Javadoc statements that do not have any
description. This includes both completely empty Javadoc,
and Javadoc with only tags such as @param and @return.


Check text for incomplete HTML tags. Verifies that HTML
tags have corresponding end tags and issues an "Unclosed
HTML tag found:" error if not. An "Extra HTML tag found:"
error is issued if an end tag is found without a previous
open tag.


Check that a package Javadoc comment is well-formed (as
described above).


Check for allowed HTML tags. The list of allowed HTML tags
is "a", "abbr", "acronym", "address", "area", "b", "bdo", "big",
"blockquote", "br", "caption", "cite", "code", "colgroup", "dd",
"del", "dfn", "div", "dl", "dt", "em", "fieldset", "font", "h1",
"h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "ins", "kbd", "li",
"ol", "p", "pre", "q", "samp", "small", "span", "strong", "sub",
"sup", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "tt",
"u", "ul", "var".



These checks were patterned after the checks made by the
DocCheck
doclet available from Sun. Note: Original Sun's DocCheck tool does not exist anymore.
[Options]
checkEmptyJavadoc, Control whether to check if the Javadoc is missing a describing text.
checkFirstSentence, Control whether to check the first sentence for proper end of sentence.
checkHtml, Control whether to check for incomplete HTML tags.
endOfSentenceFormat, Specify the format for matching the end of a sentence.
excludeScope, Specify the visibility scope where Javadoc comments are not checked.
scope, Specify the visibility scope where Javadoc comments are checked.
tokens, tokens to check
[Rule]
JavadocMissingWhitespaceAfterAsterisk
[Description]
Checks that there is at least one whitespace after the leading asterisk.
Although spaces after asterisks are optional in the Javadoc comments, their absence
makes the documentation difficult to read. It is the de facto standard to put at least
one whitespace after the leading asterisk.
[Options]
violateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at
Tight-HTML Rules.
[Rule]
DesignForExtension
[Description]
Checks that classes are designed for extension (subclass creation).


Nothing wrong could be with founded classes.
This check makes sense only for library projects (not application projects)
which care of ideal OOP-design to make sure that class works in all cases even misusage.
Even in library projects this check most likely will find classes that are designed
for extension by somebody. User needs to use suppressions extensively to got a benefit
from this check, and keep in suppressions all confirmed/known classes that are deigned
for inheritance intentionally to let the check catch only new classes, and bring this to
team/user attention.


ATTENTION: Only user can decide whether a class is designed for extension or not.
The check just shows all classes which are possibly designed for extension.
If smth inappropriate is found please use suppression.


ATTENTION: If the method which can be overridden in a subclass has a javadoc comment
(a good practice is to explain its self-use of overridable methods) the check will not
rise a violation. The violation can also be skipped if the method which can be overridden
in a subclass has one or more annotations that are specified in ignoredAnnotations
option. Note, that by default @Override annotation is not included in the
ignoredAnnotations set as in a subclass the method which has the annotation can also be
overridden in its subclass.


Problem is described at "Effective Java, 2nd Edition by Joshua Bloch" book, chapter
"Item 17: Design and document for inheritance or else prohibit it".


Some quotes from book:

The class must document its self-use of overridable methods.
By convention, a method that invokes overridable methods contains a description
of these invocations at the end of its documentation comment. The description
begins with the phrase ¡°This implementation.¡±

The best solution to this problem is to prohibit subclassing in classes that
are not designed and documented to be safely subclassed.

If a concrete class does not implement a standard interface, then you may
inconvenience some programmers by prohibiting inheritance. If you feel that you
must allow inheritance from such a class, one reasonable approach is to ensure
that the class never invokes any of its overridable methods and to document this
fact. In other words, eliminate the class¡¯s self-use of overridable methods entirely.
In doing so, you¡¯ll create a class that is reasonably safe to subclass. Overriding a
method will never affect the behavior of any other method.


The check finds classes that have overridable methods (public or protected methods
that are non-static, not-final, non-abstract) and have non-empty implementation.


Rationale: This library design style protects superclasses against
being broken by subclasses. The downside is that subclasses are
limited in their flexibility, in particular they cannot prevent
execution of code in the superclass, but that also means that
subclasses cannot corrupt the state of the superclass by forgetting
to call the superclass's method.


More specifically,
it enforces a programming style where superclasses provide empty
"hooks" that can be implemented by subclasses.


Example of code that cause violation as it is designed for extension:



public abstract class Plant {
private String roots;
private String trunk;

protected void validate() {
if (roots == null) throw new IllegalArgumentException("No roots!");
if (trunk == null) throw new IllegalArgumentException("No trunk!");
}

public abstract void grow();
}

public class Tree extends Plant {
private List leaves;

@Overrides
protected void validate() {
super.validate();
if (leaves == null) throw new IllegalArgumentException("No leaves!");
}

public void grow() {
validate();
}
}


Example of code without violation:



public abstract class Plant {
private String roots;
private String trunk;

private void validate() {
if (roots == null) throw new IllegalArgumentException("No roots!");
if (trunk == null) throw new IllegalArgumentException("No trunk!");
validateEx();
}

protected void validateEx() { }

public abstract void grow();
}
[Options]
ignoredAnnotations, Specify annotations which allow the check to skip the method from validation.
requiredJavadocPhrase, Specify the comment text pattern which qualifies a method as designed for extension. Supports multi-line regex.
[Rule]
MissingJavadocType
[Description]
Checks for missing Javadoc comments for class, enum, interface, and annotation
interface definitions. The scope to verify is specified using the Scope
class and defaults to Scope.PUBLIC. To verify
another scope, set property scope to one of the
Scope constants.
[Options]
excludeScope, Specify the visibility scope where Javadoc comments are not checked.
scope, Specify the visibility scope where Javadoc comments are checked.
skipAnnotations, Specify annotations that allow missed documentation. If annotation is present in target sources in multiple forms of qualified name, all forms should be listed in this property.
tokens, tokens to check
[Rule]
UnusedImports
[Description]
Checks for unused import statements. An
import statement is considered unused if:



It is not referenced in the file. The algorithm does not support
wild-card imports like import
java.io.*;. Most IDE's provide very sophisticated checks
for imports that handle wild-card imports.


The class imported is from the java.lang
package. For example importing java.lang.String.


The class imported is from the same package.


A static method is imported when used as method reference. In that case,
only the type needs to be imported and that's enough to resolve the method.


Optionally: it is referenced in Javadoc comments. This check
is on by default, but it is considered bad practice to introduce
a compile-time dependency for documentation purposes only.
As an example, the import java.util.List would be
considered referenced with the Javadoc comment
{@link List}. The alternative to avoid introducing a
compile-time dependency would be to write the Javadoc comment as
{@link java.util.List}.



The main limitation of this check is handling the cases where:



An imported type has the same name as a declaration, such as a member variable.


There are two or more static imports with the same method name
(javac can distinguish imports with same name but different parameters, but checkstyle
can not due to
limitation.)
[Options]
processJavadoc, Control whether to process Javadoc comments.
[Rule]
JavadocType
[Description]
Checks the Javadoc comments for type definitions.
By default, does not check for author or version tags. The
scope to verify is specified using the Scope
class and defaults to Scope.PRIVATE. To verify
another scope, set property scope to one of the
Scope constants. To define the format for an
author tag or a version tag, set property authorFormat or
versionFormat respectively to a

pattern.


Does not perform checks for author and version tags for inner
classes, as they should be redundant because of outer class.


Does not perform checks for type definitions that do not have
any Javadoc comments.


Error messages about type parameters and record components for which no
param tags are present can be suppressed by defining property
allowMissingParamTags.
[Options]
allowMissingParamTags, Control whether to ignore violations when a class has type parameters but does not have matching param tags in the Javadoc.
allowUnknownTags, Control whether to ignore violations when a Javadoc tag is not recognised.
allowedAnnotations, Specify annotations that allow skipping validation at all. Only short names are allowed, e.g. Generated.
authorFormat, Specify the pattern for @author tag.
excludeScope, Specify the visibility scope where Javadoc comments are not checked.
scope, Specify the visibility scope where Javadoc comments are checked.
versionFormat, Specify the pattern for @version tag.
tokens, tokens to check
[Rule]
JavadocParagraph
[Description]
Checks the Javadoc paragraph.


Checks that:



There is one blank line between each of two paragraphs.


Each paragraph but the first has <p> immediately before the first word, with
no space after.
[Options]
allowNewlineParagraph, Control whether the <p> tag should be placed immediately before the first word.
violateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at
Tight-HTML Rules.
[Rule]
JavadocVariable
[Description]
Checks that a variable has a Javadoc comment. Ignores serialVersionUID
fields.
[Options]
excludeScope, Specify the visibility scope where Javadoc comments are not checked.
ignoreNamePattern, Specify the regexp to define variable names to ignore.
scope, Specify the visibility scope where Javadoc comments are checked.
tokens, tokens to check

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
