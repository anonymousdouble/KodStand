Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.8.4.2 Fall-through: commented
Within a switch block, each statement group either terminates abruptly (with a break, continue, return or thrown exception), or is marked with a comment to indicate that execution will or might continue into the next statement group. Any comment that communicates the idea of fall-through is sufficient (typically // fall through). This special comment is not required in the last statement group of the switch block. Example:
 switch (input) {
  case 1:
  case 2:
  prepareOneOrTwo();
  // fall through
  case 3:
  handleOneTwoOrThree();
  break;
  default:
  handleLargeNumber(input);
 }
 Notice that no comment is needed after case 1:, only at the end of the statement group.

CheckStyle Rules:
[Rule]
FallThrough
[Description]
Checks for fall-through in switch
statements. Finds locations where a case
contains Java code but lacks a break, return,
yield, throw or continue
statement.


The check honors special comments to suppress the warning.
By default, the texts
"fallthru", "fall thru", "fall-thru",
"fallthrough", "fall through", "fall-through"
"fallsthrough", "falls through", "falls-through" (case-sensitive).
The comment containing these words must be all on one line,
and must be on the last non-empty line before the
case triggering the warning or on
the same line before the case
(ugly, but possible).


Note: The check assumes that there is no unreachable
code in the case.
[Options]
checkLastCaseGroup, Control whether the last case group must be checked.
reliefPattern, Define the RegExp to match the relief comment that suppresses the warning about a fall through.
[Rule]
AvoidNestedBlocks
[Description]
Finds nested blocks (blocks that are used freely in the code).


Rationale: Nested blocks are often leftovers from the
debugging process, they confuse the reader.


For example, this check finds the obsolete braces in



public void guessTheOutput()
{
int whichIsWhich = 0;
{
whichIsWhich = 2;
}
System.out.println("value = " + whichIsWhich);
}

and debugging / refactoring leftovers such as


// if (conditionThatIsNotUsedAnyLonger)
{
System.out.println("unconditional");
}


A case in a switch statement does not implicitly form a block.
Thus, to be able to introduce local variables that have case
scope it is necessary to open a nested block. This is
supported, set the allowInSwitchCase property to true and
include all statements of the case in the block.
[Options]
allowInSwitchCase, Allow nested blocks if they are the only child of a switch case.
[Rule]
MissingSwitchDefault
[Description]
Checks that switch statement has a default clause.


Rationale: It's usually a good idea to introduce a default case in
every switch statement. Even if the developer is sure that all
currently possible cases are covered, this should be expressed in
the default branch, e.g. by using an assertion. This way the code is
protected against later changes, e.g. introduction of new types in an
enumeration type.


This check does not validate any switch expressions. Rationale:
The compiler requires switch expressions to be exhaustive. This means
that all possible inputs must be covered.


This check does not validate switch statements that use pattern or null
labels. Rationale: Switch statements that use pattern or null labels are
checked by the compiler for exhaustiveness. This means that all possible
inputs must be covered.


See the

Java Language Specification for more information about switch statements
and expressions.
[Options]
[Rule]
EmptyBlock
[Description]
Checks for empty blocks. This check does not validate sequential blocks.
Sequential blocks won't be checked. Also, no violations for fallthrough:


switch (a) {
case 1:                          // no violation
case 2:                          // no violation
case 3: someMethod(); { }        // no violation
default: break;
}


NOTE: This check processes LITERAL_CASE and LITERAL_DEFAULT separately.
Verification empty block is done for single nearest {@code case} or {@code default}.
[Options]
option, Specify the policy on block contents.
tokens, tokens to check
[Rule]
DefaultComesLast
[Description]
Check that the default is after all the
cases in a switch statement.


Rationale: Java allows default anywhere
within the switch statement. But it is
more readable if it comes after the last case.
[Options]
skipIfLastAndSharedWithCase, Control whether to allow default along with case if they are not last.
[Rule]
TrailingComment
[Description]
The check to ensure that lines with code do not end with comment.
For the case of // comments that means that the only thing
that should precede it is whitespace. It doesn't check comments if
they do not end a line; for example, it accepts the following:
Thread.sleep( 10 /*some comment here*/ ); Format
property is intended to deal with the } // while example.


Rationale: Steve McConnell in Code Complete suggests that
endline comments are a bad practice. An end line comment would be
one that is on the same line as actual code. For example:



a = b + c;      // Some insightful comment
d = e / f;        // Another comment for this line


Quoting Code Complete for the justification:


"The comments have to be aligned so that they do not
interfere with the visual structure of the code. If you don't align
them neatly, they'll make your listing look like it's been through a
washing machine."

"Endline comments tend to be hard to format...It takes
time to align them. Such time is not spent learning more about the
code; it's dedicated solely to the tedious task of pressing the
spacebar or tab key."

"Endline comments are also hard to maintain. If the code
on any line containing an endline comment grows, it bumps the
comment farther out, and all the other endline comments will have to
bumped out to match. Styles that are hard to maintain aren't
maintained...."

"Endline comments also tend to be cryptic. The right side
of the line doesn't offer much room and the desire to keep the
comment on one line means the comment must be short. Work then goes
into making the line as short as possible instead of as clear as
possible. The comment usually ends up as cryptic as
possible...."

"A systemic problem with endline comments is that it's
hard to write a meaningful comment for one line of code. Most
endline comments just repeat the line of code, which hurts more than
it helps."



McConnell's comments on being hard to maintain when the size of the line
changes are even more important in the age of automated
refactorings.
[Options]
format, Specify pattern for strings allowed before the comment.
legalComment, Define pattern for text allowed in trailing comments. This pattern will not be applied to multiline comments.
[Rule]
AvoidInlineConditionals
[Description]
Detects inline conditionals. Here is one example of an inline conditional:



String a = getParameter("a");
String b = (a==null || a.length()<1) ? null : a.substring(1);


Rationale: Some developers find inline conditionals hard to read, so
their employer's coding standards forbid them.
[Options]
[Rule]
EmptyCatchBlock
[Description]
Checks for empty catch blocks.
By default, check allows empty catch block with any comment inside.
[Options]
commentFormat, Specify the RegExp for the first comment inside empty catch block. If check meets comment inside empty catch block matching specified format - empty block is suppressed. If it is multi-line comment - only its first line is analyzed.
exceptionVariableName, Specify the RegExp for the name of the variable associated with exception. If check meets variable name matching specified value - empty block is suppressed.
[Rule]
OneStatementPerLine
[Description]
Checks that there is only one statement per line.


Rationale: It's very difficult to read multiple statements on one line.


In the Java programming language, statements are the fundamental unit of
execution. All statements except blocks are terminated by a semicolon.
Blocks are denoted by open and close curly braces.


OneStatementPerLineCheck checks the following types of statements:
variable declaration statements, empty statements, import statements,
assignment statements, expression statements, increment statements,
object creation statements, 'for loop' statements, 'break' statements,
'continue' statements, 'return' statements, resources statements (optional).
[Options]
treatTryResourcesAsStatement, Enable resources processing.
[Rule]
TodoComment
[Description]
Checks for TODO: comments. Actually
it is a generic

pattern matcher on Java comments. To check for other
patterns in Java comments, set the format property.
[Options]
format, Specify pattern to match comments against.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
