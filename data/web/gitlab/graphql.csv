title,belongs to,description,example,appendix
Vision,Vision,"We want the GraphQL API to be the primary means of interacting programmatically with GitLab. To achieve this, it needs full coverage - anything possible in the REST API should also be possible in the GraphQL API.
To help us meet this vision, the frontend should use GraphQL in preference to the REST API for new features. The GraphQL API is versionless .
There are no plans to deprecate the REST API. To reduce the technical burden of supporting two APIs in parallel, they should share implementations as much as possible.",,
How GitLab implements GraphQL,How GitLab implements GraphQL,"We use the GraphQL Ruby gem written by Robert Mosolgo . In addition, we have a subscription to GraphQL Pro . For details see GraphQL Pro subscription .
All GraphQL queries are directed to a single endpoint ( app/controllers/graphql_controller.rb#execute ), which is exposed as an API endpoint at `/api/graphql` .",,
Deep Dive,Deep Dive,"In March 2019, Nick Thomas hosted a Deep Dive (GitLab team members only: `https://gitlab.com/gitlab-org/create-stage/issues/1` ) on the GitLab GraphQL API to share domain-specific knowledge with anyone who may work in this part of the codebase in the future. You can find the 
recording on YouTube , and the slides on Google Slides and in PDF . Everything covered in this deep dive was accurate as of GitLab 11.9, and while specific details may have changed after that release, it should still serve as a good introduction.",,
GraphiQL,GraphiQL,"GraphiQL is an interactive GraphQL API explorer where you can play around with existing queries. You can access it in any GitLab environment on `https://<your-gitlab-site.com>/-/graphql-explorer` . For example, the one for GitLab.com .",,
Reviewing merge requests with GraphQL changes,Reviewing merge requests with GraphQL changes,"The GraphQL framework has some specific gotchas to be aware of, and domain expertise is required to ensure they are satisfied.
If you are asked to review a merge request that modifies any GraphQL files or adds an endpoint, have a look at our GraphQL review guide .",,
Reading GraphQL logs,Reading GraphQL logs,See the Reading GraphQL logs guide for tips on how to inspect logs of GraphQL requests and monitor the performance of your GraphQL queries.,,
Authentication,Authentication,"Authentication happens through the `GraphqlController` , right now this uses the same authentication as the Rails application. So the session can be shared.
It’s also possible to add a `private_token` to the query string, or add a `HTTP_PRIVATE_TOKEN` header.",,
Limits,Limits,Several limits apply to the GraphQL API and some of these can be overridden by developers.,,
Max page size,Limits/Max page size,"By default, connections can only return at most a maximum number of records defined in app/graphql/gitlab_schema.rb per page.
Developers can specify a custom max page size when defining a connection.",,
Max complexity,Limits/Max complexity,"Complexity is explained on our client-facing API page .
Fields default to adding `1` to a query’s complexity score, but developers can specify a custom complexity when defining a field.
The complexity score of a query can itself be queried for .",,
Request timeout,Limits/Request timeout,Requests time out at 30 seconds.,,
Limit maximum field call count,Limits/Limit maximum field call count,"In some cases, you want to prevent the evaluation of a specific field on multiple parent nodes because it results in an N+1 query problem and there is no optimal solution. This should be considered an option of last resort, to be used only when methods such as lookahead to preload associations , or using batching have been considered.
For example:","# This usage is expected.
query {
  project {
    environments
  }
}

# This usage is NOT expected.
# It results in N+1 query problem. EnvironmentsResolver can't use GraphQL batch loader in favor of GraphQL pagination.
query {
  projects {
    nodes {
      environments
    }
  }
}
",
Limit maximum field call count,Limits/Limit maximum field call count,"To prevent this, you can use the `Gitlab::Graphql::Limit::FieldCallCount` extension on the field:","# This allows maximum 1 call to the `environments` field. If the field is evaluated on more than one node,
# it raises an error.
field :environments do
        extension(::Gitlab::Graphql::Limit::FieldCallCount, limit: 1)
      end
",
Limit maximum field call count,Limits/Limit maximum field call count,or you can apply the extension in a resolver class:,"module Resolvers
  class EnvironmentsResolver < BaseResolver
    extension(::Gitlab::Graphql::Limit::FieldCallCount, limit: 1)
    # ...
  end
end
",
Limit maximum field call count,Limits/Limit maximum field call count,"When you add this limit, make sure that the affected field’s `description` is also updated accordingly. For example,","field :environments,
      description: 'Environments of the project. This field can only be resolved for one project in any single request.'
",
Breaking changes,Breaking changes,"The GitLab GraphQL API is versionless which means developers must familiarize themselves with our Deprecation and Removal process .
Breaking changes are:
Removing or renaming a field, argument, enum value, or mutation. 
Changing the type or type name of an argument. The type of an argument is declared by the client when using variables , and a change would cause a query using the old type name to be rejected by the API. 
Changing the scalar type of a field or enum value where it results in a change to how the value serializes to JSON. For example, a change from a JSON String to a JSON Number, or a change to how a String is formatted. A change to another object type can be allowed so long as all scalar type fields of the object continue to serialize in the same way. 
Raising the complexity of a field or complexity multipliers in a resolver. 
Changing a field from being not nullable ( `null:false` ) to nullable ( `null:true` ), as discussed in Nullable fields . 
Changing an argument from being optional ( `required:false` ) to being required ( `required:true` ). 
Changing the max page size of a connection. 
Lowering the global limits for query complexity and depth. 
Anything else that can result in queries hitting a limit that previously was allowed.
See the deprecating schema items section for how to deprecate items.",,
Breaking change exemptions,Breaking changes/Breaking change exemptions,See the GraphQL API breaking change exemptions documentation .,,
Global IDs,Global IDs,"The GitLab GraphQL API uses Global IDs (i.e: `""gid://gitlab/MyObject/123""` ) and never database primary key IDs.
Global ID is a convention used for caching and fetching in client-side libraries.
See also:
Exposing Global IDs . 
Mutation arguments . 
Deprecating Global IDs . 
Customer-facing Global ID documentation .
We have a custom scalar type ( `Types::GlobalIDType` ) which should be used as the type of input and output arguments when the value is a `GlobalID` . The benefits of using this type instead of `ID` are:
it validates that the value is a `GlobalID` 
it parses it into a `GlobalID` before passing it to user code 
it can be parameterized on the type of the object (for example, `GlobalIDType[Project]` ) which offers even better validation and security.
Consider using this type for all new arguments and result types. Remember that it is perfectly possible to parameterize this type with a concern or a supertype, if you want to accept a wider range of objects (such as `GlobalIDType[Issuable]` vs `GlobalIDType[Issue]` ).",,
Optimizations,Optimizations,"By default, GraphQL tends to introduce N+1 problems unless you actively try to minimize them.
For stability and scalability, you must ensure that our queries do not suffer from N+1 performance issues.
The following are a list of tools to help you to optimize your GraphQL code:
Look ahead allows you to preload data based on which fields are selected in the query. 
Batch loading allows you batch database queries together to be executed in one statement. 
BatchModelLoader is the recommended way to lookup records by ID to leverage batch loading. 
before_connection_authorization allows you to address N+1 problems specific to type authorization permission checks. 
Limit maximum field call count allows you to restrict how many times a field can return data where optimizations cannot be improved.",,
How to see N+1 problems in development,How to see N+1 problems in development,"N+1 problems can be discovered during development of a feature by:
Tailing `development.log` while you execute GraphQL queries that return collections of data. Bullet may help. 
Observing the performance bar if executing queries in the GitLab UI. 
Adding a request spec that asserts there are no (or limited) N+1 problems with the feature.",,
Types,Types,"We use a code-first schema, and we declare what type everything is in Ruby.
For example, `app/graphql/types/issue_type.rb` :","graphql_name 'Issue'

field :iid, GraphQL::Types::ID, null: true
field :title, GraphQL::Types::String, null: true

# we also have a method here that we've defined, that extends `field`
markdown_field :title_html, null: true
field :description, GraphQL::Types::String, null: true
markdown_field :description_html, null: true
",
Types,Types,"We give each type a name (in this case `Issue` ).
The `iid` , `title` and `description` are scalar GraphQL types. `iid` is a `GraphQL::Types::ID` , a special string type that signifies a unique ID. `title` and `description` are regular `GraphQL::Types::String` types.
The old scalar types `GraphQL:ID` , `GraphQL::INT_TYPE` , `GraphQL::STRING_TYPE` , `GraphQL:BOOLEAN_TYPE` , and `GraphQL::FLOAT_TYPE` are no longer allowed. Use `GraphQL::Types::ID` , `GraphQL::Types::Int` , `GraphQL::Types::String` , `GraphQL::Types::Boolean` , and `GraphQL::Types::Float` .
When exposing a model through the GraphQL API, we do so by creating a new type in `app/graphql/types` . You can also declare custom GraphQL data types for scalar data types (for example `TimeType` ).
When exposing properties in a type, make sure to keep the logic inside the definition as minimal as possible. Instead, consider moving any logic into a presenter:","class Types::MergeRequestType < BaseObject
  present_using MergeRequestPresenter

  name 'MergeRequest'
end
","An existing presenter could be used, but it is also possible to create a new presenter specifically for GraphQL.
The presenter is initialized using the object resolved by a field, and the context."
Nullable fields,Types/Nullable fields,"GraphQL allows fields to be “nullable” or “non-nullable”. The former means that `null` may be returned instead of a value of the specified type. In general , you should prefer using nullable fields to non-nullable ones, for the following reasons:
It’s common for data to switch from required to not-required, and back again 
Even when there is no prospect of a field becoming optional, it may not be available at query time 
For instance, the `content` of a blob may need to be looked up from Gitaly 
If the `content` is nullable, we can return a partial response, instead of failing the whole query 
Changing from a non-nullable field to a nullable field is difficult with a versionless schema
Non-nullable fields should only be used when a field is required, very unlikely to become optional in the future, and straightforward to calculate. An example would be `id` fields.
A non-nullable GraphQL schema field is an object type followed by the exclamation point (bang) `!` . Here’s an example from the `gitlab_schema.graphql` file:","  id: ProjectID!
",
Nullable fields,Types/Nullable fields,Here’s an example of a non-nullable GraphQL array:,"
  errors: [String!]!
","Further reading:
GraphQL Best Practices Guide . 
GraphQL documentation on Object types and fields . 
Using nullability in GraphQL"
Exposing Global IDs,Types/Exposing Global IDs,"In keeping with the GitLab use of Global IDs , always convert database primary key IDs into Global IDs when you expose them.
All fields named `id` are converted automatically into the object’s Global ID.
Fields that are not named `id` need to be manually converted. We can do this using Gitlab::GlobalID.build , or by calling `#to_global_id` on an object that has mixed in the `GlobalID::Identification` module.
Using an example from Types::Notes::DiscussionType :","field :reply_id, Types::GlobalIDType[Discussion]

def reply_id
  Gitlab::GlobalId.build(object, id: object.reply_id)
end
",
Connection types,Types/Connection types,"note 
For specifics on implementation, see Pagination implementation .
GraphQL uses cursor based pagination to expose collections of items. This provides the clients with a lot of flexibility while also allowing the backend to use different pagination models.
To expose a collection of resources we can use a connection type. This wraps the array with default pagination fields. For example a query for project-pipelines could look like this:","query($project_path: ID!) {
  project(fullPath: $project_path) {
    pipelines(first: 2) {
      pageInfo {
        hasNextPage
        hasPreviousPage
      }
      edges {
        cursor
        node {
          id
          status
        }
      }
    }
  }
}
",
Connection types,Types/Connection types,"This would return the first 2 pipelines of a project and related pagination information, ordered by descending ID. The returned data would look like this:","{
  ""data"": {
    ""project"": {
      ""pipelines"": {
        ""pageInfo"": {
          ""hasNextPage"": true,
          ""hasPreviousPage"": false
        },
        ""edges"": [
          {
            ""cursor"": ""Nzc="",
            ""node"": {
              ""id"": ""gid://gitlab/Pipeline/77"",
              ""status"": ""FAILED""
            }
          },
          {
            ""cursor"": ""Njc="",
            ""node"": {
              ""id"": ""gid://gitlab/Pipeline/67"",
              ""status"": ""FAILED""
            }
          }
        ]
      }
    }
  }
}
",
Connection types,Types/Connection types,"To get the next page, the cursor of the last known element could be passed:","query($project_path: ID!) {
  project(fullPath: $project_path) {
    pipelines(first: 2, after: ""Njc="") {
      pageInfo {
        hasNextPage
        hasPreviousPage
      }
      edges {
        cursor
        node {
          id
          status
        }
      }
    }
  }
}
","To ensure that we get consistent ordering, we append an ordering on the primary key, in descending order. The primary key is usually `id` , so we add `order(id::desc)` to the end of the relation. A primary key must be available on the underlying table."
Shortcut fields,Types/Connection types/Shortcut fields,"Sometimes it can seem straightforward to implement a “shortcut field”, having the resolver return the first of a collection if no parameters are passed. These “shortcut fields” are discouraged because they create maintenance overhead. They need to be kept in sync with their canonical field, and deprecated or modified if their canonical field changes. Use the functionality the framework provides unless there is a compelling reason to do otherwise.
For example, instead of `latest_pipeline` , use `pipelines(last:1)` .",,
Page size limit,Types/Connection types/Page size limit,"By default, the API returns at most a maximum number of records defined in app/graphql/gitlab_schema.rb per page in a connection and this is also the default number of records returned per page if no limiting arguments ( `first:` or `last:` ) are provided by a client.
The `max_page_size` argument can be used to specify a different page size limit for a connection.
caution 
It’s better to change the frontend client, or product requirements, to not need large amounts of records per page than it is to raise the `max_page_size` , as the default is set to ensure the GraphQL API remains performant.
For example:","field :tags,
  Types::ContainerRepositoryTagType.connection_type,
  null: true,
  description: 'Tags of the container repository',
  max_page_size: 20
",
Field complexity,Types/Connection types/Field complexity,"The GitLab GraphQL API uses a complexity score to limit performing overly complex queries. Complexity is described in our client documentation on the topic.
Complexity limits are defined in app/graphql/gitlab_schema.rb .
By default, fields add `1` to a query’s complexity score. This can be overridden by providing a custom
 
 complexity value for a field.
Developers should specify higher complexity for fields that cause more work to be performed by the server to return data. Fields that represent data that can be returned with little-to-no work , for example in most cases; `id` or `title` , can be given a complexity of `0` .",,
calls_gitaly,Types/Connection types/calls_gitaly,"Fields that have the potential to perform a Gitaly call when resolving must be marked as such by passing `calls_gitaly:true` to `field` when defining it.
For example:","field :blob, type: Types::Snippets::BlobType,
      description: 'Snippet blob',
      null: false,
      calls_gitaly: true
",
calls_gitaly,Types/Connection types/calls_gitaly,"This increments the complexity
 
 score of the field by `1` .
If a resolver calls Gitaly, it can be annotated with `BaseResolver.calls_gitaly!` . This passes `calls_gitaly:true` to any field that uses this resolver.
For example:","class BranchResolver < BaseResolver
  type ::Types::BranchType, null: true
  calls_gitaly!

  argument name: ::GraphQL::Types::String, required: true

  def resolve(name:)
    object.branch(name)
  end
end
","Then when we use it, any field that uses `BranchResolver` has the correct value for `calls_gitaly:` ."
Exposing permissions for a type,Types/Connection types/Exposing permissions for a type,"To expose permissions the current user has on a resource, you can call the `expose_permissions` passing in a separate type representing the permissions for the resource.
For example:","module Types
  class MergeRequestType < BaseObject
    expose_permissions Types::MergeRequestPermissionsType
  end
end
",
Exposing permissions for a type,Types/Connection types/Exposing permissions for a type,"The permission type inherits from `BasePermissionType` which includes some helper methods, that allow exposing permissions as non-nullable booleans:","class MergeRequestPermissionsType < BasePermissionType
  graphql_name 'MergeRequestPermissions'

  present_using MergeRequestPresenter

  abilities :admin_merge_request, :update_merge_request, :create_note

  ability_field :resolve_note,
                description: 'Indicates the user can resolve discussions on the merge request.'
  permission_field :push_to_source_branch, method: :can_push_to_source_branch?
end
","`permission_field` 
: Acts the same as `graphql-ruby` ’s `field` method but setting a default description and type and making them non-nullable. These options can still be overridden by adding them as arguments. 
`ability_field` 
: Expose an ability defined in our policies. This behaves the same way as `permission_field` and the same arguments can be overridden. 
`abilities` 
: Allows exposing several abilities defined in our policies at once. The fields for these must all be non-nullable booleans with a default description."
Feature flags,Feature flags,"You can implement feature flags in GraphQL to toggle:
The return value of a field. 
The behavior of an argument or mutation.
This can be done in a resolver, in the type, or even in a model method, depending on your preference and situation.
note 
It’s recommended that you also mark the item as Alpha while it is behind a feature flag. This signals to consumers of the public GraphQL API that the field is not meant to be used yet. You can also change or remove Alpha items at any time without needing to deprecate them. When the flag is removed, “release” the schema item by removing its Alpha property to make it public.",,
Descriptions for feature-flagged items,Feature flags/Descriptions for feature-flagged items,"When using a feature flag to toggle the value or behavior of a schema item, the `description` of the item must:
State that the value or behavior can be toggled by a feature flag. 
Name the feature flag. 
State what the field returns, or behavior is, when the feature flag is disabled (or enabled, if more appropriate).",,
Feature-flagged field,Feature flags/Examples of using feature flags/Feature-flagged field,A field value is toggled based on the feature flag state. A common use is to return `null` if the feature flag is disabled:,"field :foo, GraphQL::Types::String, null: true,
      alpha: { milestone: '10.0' },
      description: 'Some test field. Returns `null`' \
                   'if `my_feature_flag` feature flag is disabled.'

def foo
  object.foo if Feature.enabled?(:my_feature_flag, object)
end
",
Feature-flagged argument,Feature flags/Examples of using feature flags/Feature-flagged argument,"An argument can be ignored, or have its value changed, based on the feature flag state. A common use is to ignore the argument when a feature flag is disabled:","argument :foo, type: GraphQL::Types::String, required: false,
         alpha: { milestone: '10.0' },
         description: 'Some test argument. Is ignored if ' \
                      '`my_feature_flag` feature flag is disabled.'

def resolve(args)
  args.delete(:foo) unless Feature.enabled?(:my_feature_flag, object)
  # ...
end
",
Feature-flagged mutation,Feature flags/Examples of using feature flags/Feature-flagged mutation,A mutation that cannot be performed due to a feature flag state is handled as a non-recoverable mutation error . The error is returned at the top level:,"description 'Mutates an object. Does not mutate the object if ' \
            '`my_feature_flag` feature flag is disabled.'

def resolve(id: )
  object = authorized_find!(id: id)

  raise_resource_not_available_error! '`my_feature_flag` feature flag is disabled.' \
    if Feature.disabled?(:my_feature_flag, object)
  # ...
end
",
Deprecating schema items,Deprecating schema items,"The GitLab GraphQL API is versionless, which means we maintain backwards compatibility with older versions of the API with every change.
Rather than removing fields, arguments, enum values , or mutations , they must be deprecated instead.
The deprecated parts of the schema can then be removed in a future release in accordance with the GitLab deprecation process .
To deprecate a schema item in GraphQL:
Create a deprecation issue for the item. 
Mark the item as deprecated in the schema.
See also:
Aliasing and deprecating mutations . 
Marking schema items as Alpha . 
How to filter Kibana for queries that used deprecated fields .",,
Create a deprecation issue,Deprecating schema items/Create a deprecation issue,"Every GraphQL deprecation should have a deprecation issue created using the
 
 Deprecations
 
 issue template to track its deprecation and removal.
Apply these two labels to the deprecation issue:
`~GraphQL` 
`~deprecation`",,
Mark the item as deprecated,Deprecating schema items/Mark the item as deprecated,"Fields, arguments, enum values, and mutations are deprecated using the `deprecated` property. The value of the property is a `Hash` of:
`reason` - Reason for the deprecation. 
`milestone` - Milestone that the field was deprecated.
Example:","field :token, GraphQL::Types::String, null: true,
      deprecated: { reason: 'Login via token has been removed', milestone: '10.0' },
      description: 'Token for login.'
","The original `description` of the things being deprecated should be maintained, and should not be updated to mention the deprecation. Instead, the `reason` is appended to the `description` ."
Deprecation reason style guide,Deprecating schema items/Mark the item as deprecated/Deprecation reason style guide,"Where the reason for deprecation is due to the field, argument, or enum value being replaced, the `reason` must indicate the replacement. For example, the following is a `reason` for a replaced field:","Use `otherFieldName`
",
Deprecation reason style guide,Deprecating schema items/Mark the item as deprecated/Deprecation reason style guide,Examples:,"field :designs, ::Types::DesignManagement::DesignCollectionType, null: true,
      deprecated: { reason: 'Use `designCollection`', milestone: '10.0' },
      description: 'The designs associated with this issue.',

module Types
  class TodoStateEnum < BaseEnum
    value 'pending', deprecated: { reason: 'Use PENDING', milestone: '10.0' }
    value 'done', deprecated: { reason: 'Use DONE', milestone: '10.0' }
    value 'PENDING', value: 'pending'
    value 'DONE', value: 'done'
  end
end
","If the field, argument, or enum value being deprecated is not being replaced, a descriptive deprecation `reason` should be given."
Deprecate Global IDs,Deprecating schema items/Mark the item as deprecated/Deprecate Global IDs,"We use the rails/globalid gem to generate and parse Global IDs, so as such they are coupled to model names. When we rename a model, its Global ID changes.
If the Global ID is used as an argument type anywhere in the schema, then the Global ID change would typically constitute a breaking change.
To continue to support clients using the old Global ID argument, we add a deprecation to `Gitlab::GlobalId::Deprecations` .
note 
If the Global ID is only 
exposed as a field then we do not need to deprecate it. We consider the change to the way a Global ID is expressed in a field to be backwards-compatible. We expect that clients don’t parse these values: they are meant to be treated as opaque tokens, and any structure in them is incidental and not to be relied on.
Example scenario:
This example scenario is based on this merge request .
A model named `PrometheusService` is to be renamed `Integrations::Prometheus` . The old model name is used to create a Global ID type that is used as an argument for a mutation:","# Mutations::UpdatePrometheus:

argument :id, Types::GlobalIDType[::PrometheusService],
              required: true,
              description: ""The ID of the integration to mutate.""
",
Deprecate Global IDs,Deprecating schema items/Mark the item as deprecated/Deprecate Global IDs,"Clients call the mutation by passing a Global ID string that looks like `""gid://gitlab/PrometheusService/1""` , named as `PrometheusServiceID` , as the `input.id` argument:","mutation updatePrometheus($id: PrometheusServiceID!, $active: Boolean!) {
  prometheusIntegrationUpdate(input: { id: $id, active: $active }) {
    errors
    integration {
      active
    }
  }
}
",
Deprecate Global IDs,Deprecating schema items/Mark the item as deprecated/Deprecate Global IDs,"We rename the model to `Integrations::Prometheus` , and then update the codebase with the new name. When we come to update the mutation, we pass the renamed model to `Types::GlobalIDType[]` :","# Mutations::UpdatePrometheus:

argument :id, Types::GlobalIDType[::Integrations::Prometheus],
              required: true,
              description: ""The ID of the integration to mutate.""
",
Deprecate Global IDs,Deprecating schema items/Mark the item as deprecated/Deprecate Global IDs,"This would cause a breaking change to the mutation, as the API now rejects clients who pass an `id` argument as `""gid://gitlab/PrometheusService/1""` , or that specify the argument type as `PrometheusServiceID` in the query signature.
To allow clients to continue to interact with the mutation unchanged, edit the `DEPRECATIONS` constant in `Gitlab::GlobalId::Deprecations` and add a new `Deprecation` to the array:","DEPRECATIONS = [
  Gitlab::Graphql::DeprecationsBase::NameDeprecation.new(old_name: 'PrometheusService', new_name: 'Integrations::Prometheus', milestone: '14.0')
].freeze
",
Deprecate Global IDs,Deprecating schema items/Mark the item as deprecated/Deprecate Global IDs,"Then follow our regular deprecation process . To later remove support for the former argument style, remove the `Deprecation` :","DEPRECATIONS = [].freeze
","During the deprecation period, the API accepts either of these formats for the argument value:
`""gid://gitlab/PrometheusService/1""` 
`""gid://gitlab/Integrations::Prometheus/1""`
The API also accepts these types in the query signature for the argument:
`PrometheusServiceID` 
`IntegrationsPrometheusID`
note 
Although queries that use the old type ( `PrometheusServiceID` in this example) are considered valid and executable by the API, validator tools consider them to be invalid. They are considered invalid because we are deprecating using a bespoke method outside of the @deprecated
 
 directive , so validators are not aware of the support.
The documentation mentions that the old Global ID style is now deprecated."
Mark schema items as Alpha,Mark schema items as Alpha,"You can mark GraphQL schema items (fields, arguments, enum values, and mutations) as Alpha .
An item marked as Alpha is exempt from the deprecation process and can be removed at any time without notice. Mark an item as Alpha when it is subject to change and not ready for public use.
note 
Only mark new items as Alpha. Never mark existing items as Alpha because they’re already public.
To mark a schema item as Alpha, use the `alpha:` keyword. You must provide the `milestone:` that introduced the Alpha item.
For example:","field :token, GraphQL::Types::String, null: true,
      alpha: { milestone: '10.0' },
      description: 'Token for login.'
",
Mark schema items as Alpha,Mark schema items as Alpha,"Similarly, you can also mark an entire mutation as Alpha by updating where the mutation is mounted in `app/graphql/types/mutation_type.rb` :","mount_mutation Mutations::Ci::JobArtifact::BulkDestroy, alpha: { milestone: '15.10' }
","Alpha GraphQL items is a custom GitLab feature that leverages GraphQL deprecations. An Alpha item appears as deprecated in the GraphQL schema. Like all deprecated schema items, you can test an Alpha field in the interactive GraphQL explorer (GraphiQL). However, be aware that the GraphiQL autocomplete editor doesn’t suggest deprecated fields.
The item shows as Alpha in our generated GraphQL documentation and its GraphQL schema description."
Enums,Enums,"GitLab GraphQL enums are defined in `app/graphql/types` . When defining new enums, the following rules apply:
Values must be uppercase. 
Class names must end with the string `Enum` . 
The `graphql_name` must not contain the string `Enum` .
For example:","module Types
  class TrafficLightStateEnum < BaseEnum
    graphql_name 'TrafficLightState'
    description 'State of a traffic light'

    value 'RED', description: 'Drivers must stop.'
    value 'YELLOW', description: 'Drivers must stop when it is safe to.'
    value 'GREEN', description: 'Drivers can start or keep driving.'
  end
end
",
Enums,Enums,"If the enum is used for a class property in Ruby that is not an uppercase string, you can provide a `value:` option that adapts the uppercase value.
In the following example:
GraphQL inputs of `OPENED` are converted to `'opened'` . 
Ruby values of `'opened'` are converted to `""OPENED""` in GraphQL responses.","module Types
  class EpicStateEnum < BaseEnum
    graphql_name 'EpicState'
    description 'State of a GitLab epic'

    value 'OPENED', value: 'opened', description: 'An open Epic.'
    value 'CLOSED', value: 'closed', description: 'A closed Epic.'
  end
end
","Enum values can be deprecated using the deprecated
 
 keyword ."
Defining GraphQL enums dynamically from Rails enums,Enums/Defining GraphQL enums dynamically from Rails enums,"If your GraphQL enum is backed by a Rails enum , then consider using the Rails enum to dynamically define the GraphQL enum values. Doing so binds the GraphQL enum values to the Rails enum definition, so if values are ever added to the Rails enum then the GraphQL enum automatically reflects the change.
Example:","module Types
  class IssuableSeverityEnum < BaseEnum
    graphql_name 'IssuableSeverity'
    description 'Incident severity'

    ::IssuableSeverity.severities.each_key do |severity|
      value severity.upcase, value: severity, description: ""#{severity.titleize} severity.""
    end
  end
end
",
JSON,JSON,"When data to be returned by GraphQL is stored as JSON , we should continue to use GraphQL types whenever possible. Avoid using the `GraphQL::Types::JSON` type unless the JSON data returned is truly unstructured.
If the structure of the JSON data varies, but is one of a set of known possible structures, use a union . An example of the use of a union for this purpose is !30129 .
Field names can be mapped to hash data keys using the `hash_key:` keyword if needed.
For example, given the following JSON data:","{
  ""title"": ""My chart"",
  ""data"": [
    { ""x"": 0, ""y"": 1 },
    { ""x"": 1, ""y"": 1 },
    { ""x"": 2, ""y"": 2 }
  ]
}
",
JSON,JSON,We can use GraphQL types like this:,"module Types
  class ChartType < BaseObject
    field :title, GraphQL::Types::String, null: true, description: 'Title of the chart.'
    field :data, [Types::ChartDatumType], null: true, description: 'Data of the chart.'
  end
end

module Types
  class ChartDatumType < BaseObject
    field :x, GraphQL::Types::Int, null: true, description: 'X-axis value of the chart datum.'
    field :y, GraphQL::Types::Int, null: true, description: 'Y-axis value of the chart datum.'
  end
end
",
Descriptions,Descriptions,"All fields and arguments must have descriptions .
A description of a field or argument is given using the `description:` keyword. For example:","field :id, GraphQL::Types::ID, description: 'ID of the issue.'
field :confidential, GraphQL::Types::Boolean, description: 'Indicates the issue is confidential.'
field :closed_at, Types::TimeType, description: 'Timestamp of when the issue was closed.'
","You can view descriptions of fields and arguments in:
The GraphiQL explorer . 
The static GraphQL API reference ."
Language and punctuation,Descriptions/Description style guide/Language and punctuation,"To describe fields and arguments, use `{x}ofthe{y}` where possible, where `{x}` is the item you’re describing, and `{y}` is the resource it applies to. For example:","ID of the issue.

Author of the epics.
",
Language and punctuation,Descriptions/Description style guide/Language and punctuation,"For arguments that sort or search, start with the appropriate verb. To indicate the specified values, for conciseness, you can use `this` instead of `thegiven` or `thespecified` . For example:","Sort issues by this criteria.
","Do not start descriptions with `The` or `A` , for consistency and conciseness.
End all descriptions with a period ( `.` )."
Booleans,Descriptions/Description style guide/Booleans,"For a boolean field ( `GraphQL::Types::Boolean` ), start with a verb that describes what it does. For example:","Indicates the issue is confidential.
",
Booleans,Descriptions/Description style guide/Booleans,"If necessary, provide the default. For example:","Sets the issue to confidential. Default is false.
",
Sort enums,Descriptions/Description style guide/Sort enums,Enums for sorting should have the description `'Valuesforsorting{x}.'` . For example:,"Values for sorting container repositories.
",
Types::TimeType field description,Descriptions/Description style guide/Types::TimeType field description,"For `Types::TimeType` GraphQL fields, include the word `timestamp` . This lets the reader know that the format of the property is `Time` , rather than just `Date` .
For example:","field :closed_at, Types::TimeType, description: 'Timestamp of when the issue was closed.'
",
copy_field_description helper,Descriptions/Description style guide/copy_field_description helper,"Sometimes we want to ensure that two descriptions are always identical. For example, to keep a type field description the same as a mutation argument when they both represent the same property.
Instead of supplying a description, we can use the `copy_field_description` helper, passing it the type, and field name to copy the description of.
Example:","argument :title, GraphQL::Types::String,
          required: false,
          description: copy_field_description(Types::MergeRequestType, :title)
",
Documentation references,Descriptions/Description style guide/Documentation references,"Sometimes we want to refer to external URLs in our descriptions. To make this easier, and provide proper markup in the generated reference documentation, we provide a `see` property on fields. For example:","field :genus,
      type: GraphQL::Types::String,
      null: true,
      description: 'A taxonomic genus.'
      see: { 'Wikipedia page on genera' => 'https://wikipedia.org/wiki/Genus' }
",
Documentation references,Descriptions/Description style guide/Documentation references,This renders in our documentation as:,"A taxonomic genus. See: [Wikipedia page on genera](https://wikipedia.org/wiki/Genus)
","Multiple documentation references can be provided. The syntax for this property is a `HashMap` where the keys are textual descriptions, and the values are URLs."
Subscription tier badges,Descriptions/Description style guide/Subscription tier badges,"If a field or argument is available to higher subscription tiers than the other fields, add the tier badge inline.
For example:","description: '**(ULTIMATE ALL)** Full path of a custom template.'
",
Authorization,Authorization,See: GraphQL Authorization,,
Resolvers,Resolvers,"We define how the application serves the response using resolvers stored in the `app/graphql/resolvers` directory. The resolver provides the actual implementation logic for retrieving the objects in question.
To find objects to display in a field, we can add resolvers to `app/graphql/resolvers` .
Arguments can be defined in the resolver in the same way as in a mutation. See the Arguments section.
To limit the amount of queries performed, we can use BatchLoader .",,
Writing resolvers,Resolvers/Writing resolvers,"Our code should aim to be thin declarative wrappers around finders and services . You can repeat lists of arguments, or extract them to concerns. Composition is preferred over inheritance in most cases. Treat resolvers like controllers: resolvers should be a DSL that compose other application abstractions.
For example:","class PostResolver < BaseResolver
  type Post.connection_type, null: true
  authorize :read_blog
  description 'Blog posts, optionally filtered by name'

  argument :name, [::GraphQL::Types::String], required: false, as: :slug

  alias_method :blog, :object

  def resolve(**args)
    PostFinder.new(blog, current_user, args).execute
  end
end
","While you can use the same resolver class in two different places, such as in two different fields where the same object is exposed, you should never re-use resolver objects directly. Resolvers have a complex life-cycle, with authorization, readiness and resolution orchestrated by the framework, and at each stage lazy values can be returned to take advantage of batching opportunities. Never instantiate a resolver or a mutation in application code.
Instead, the units of code reuse are much the same as in the rest of the application:
Finders in queries to look up data. 
Services in mutations to apply operations. 
Loaders (batch-aware finders) specific to queries.
There is never any reason to use batching in a mutation. Mutations are executed in series, so there are no batching opportunities. All values are evaluated eagerly as soon as they are requested, so batching is unnecessary overhead. If you are writing:
A `Mutation` , feel free to lookup objects directly. 
A `Resolver` or methods on a `BaseObject` , then you want to allow for batching."
Error handling,Resolvers/Error handling,"Resolvers may raise errors, which are converted to top-level errors as appropriate. All anticipated errors should be caught and transformed to an appropriate GraphQL error (see Gitlab::Graphql::Errors ). Any uncaught errors are suppressed and the client receives the message `Internalserviceerror` .
The one special case is permission errors. In the REST API we return `404NotFound` for any resources that the user does not have permission to access. The equivalent behavior in GraphQL is for us to return `null` for all absent or unauthorized resources. Query resolvers should not raise errors for unauthorized resources .
The rationale for this is that clients must not be able to distinguish between the absence of a record and the presence of one they do not have access to. To do so is a security vulnerability, because it leaks information we want to keep hidden.
In most cases you don’t need to worry about this - this is handled correctly by the resolver field authorization we declare with the `authorize` DSL calls. If you need to do something more custom however, remember, if you encounter an object the `current_user` does not have access to when resolving a field, then the entire field should resolve to `null` .",,
Deriving resolvers,Resolvers/Deriving resolvers,"(including `BaseResolver.single` and `BaseResolver.last` )
For some use cases, we can derive resolvers from others. The main use case for this is one resolver to find all items, and another to find one specific one. For this, we supply convenience methods:
`BaseResolver.single` , which constructs a new resolver that selects the first item. 
`BaseResolver.last` , which constructs a resolver that selects the last item.
The correct singular type is inferred from the collection type, so we don’t have to define the `type` here.
Before you make use of these methods, consider if it would be simpler to either:
Write another resolver that defines its own arguments. 
Write a concern that abstracts out the query.
Using `BaseResolver.single` too freely is an anti-pattern. It can lead to non-sensical fields, such as a `Project.mergeRequest` field that just returns the first MR if no arguments are given. Whenever we derive a single resolver from a collection resolver, it must have more restrictive arguments.
To make this possible, use the `when_single` block to customize the single resolver. Every `when_single` block must:
Define (or re-define) at least one argument. 
Make optional filters required.
For example, we can do this by redefining an existing optional argument, changing its type and making it required:","class JobsResolver < BaseResolver
  type JobType.connection_type, null: true
  authorize :read_pipeline

  argument :name, [::GraphQL::Types::String], required: false

  when_single do
    argument :name, ::GraphQL::Types::String, required: true
  end

  def resolve(**args)
    JobsFinder.new(pipeline, current_user, args.compact).execute
  end
",
Deriving resolvers,Resolvers/Deriving resolvers,"Here we have a resolver for getting pipeline jobs. The `name` argument is optional when getting a list, but required when getting a single job.
If there are multiple arguments, and neither can be made required, we can use the block to add a ready condition:","class JobsResolver < BaseResolver
  alias_method :pipeline, :object

  type JobType.connection_type, null: true
  authorize :read_pipeline

  argument :name, [::GraphQL::Types::String], required: false
  argument :id, [::Types::GlobalIDType[::Job]],
           required: false,
           prepare: ->(ids, ctx) { ids.map(&:model_id) }

  when_single do
    argument :name, ::GraphQL::Types::String, required: false
    argument :id, ::Types::GlobalIDType[::Job],
             required: false
             prepare: ->(id, ctx) { id.model_id }

    def ready?(**args)
      raise ::Gitlab::Graphql::Errors::ArgumentError, 'Only one argument may be provided' unless args.size == 1
    end
  end

  def resolve(**args)
    JobsFinder.new(pipeline, current_user, args.compact).execute
  end
",
Deriving resolvers,Resolvers/Deriving resolvers,Then we can use these resolver on fields:,"# In PipelineType

field :jobs, resolver: JobsResolver, description: 'All jobs.'
field :job, resolver: JobsResolver.single, description: 'A single job.'
",
Look-Ahead,Resolvers/Optimizing Resolvers/Look-Ahead,"The full query is known in advance during execution, which means we can make use of lookahead to optimize our queries, and batch load associations we know we need. Consider adding lookahead support in your resolvers to avoid `N+1` performance issues.
To enable support for common lookahead use-cases (pre-loading associations when child fields are requested), you can include LooksAhead . For example:","# Assuming a model `MyThing` with attributes `[child_attribute, other_attribute, nested]`,
# where nested has an attribute named `included_attribute`.
class MyThingResolver < BaseResolver
  include LooksAhead

  # Rather than defining `resolve(**args)`, we implement: `resolve_with_lookahead(**args)`
  def resolve_with_lookahead(**args)
    apply_lookahead(MyThingFinder.new(current_user).execute)
  end

  # We list things that should always be preloaded:
  # For example, if child_attribute is always needed (during authorization
  # perhaps), then we can include it here.
  def unconditional_includes
    [:child_attribute]
  end

  # We list things that should be included if a certain field is selected:
  def preloads
    {
        field_one: [:other_attribute],
        field_two: [{ nested: [:included_attribute] }]
    }
  end
end
",
Look-Ahead,Resolvers/Optimizing Resolvers/Look-Ahead,"By default, fields defined in `#preloads` are preloaded if that field is selected in the query. Occasionally, finer control may be needed to avoid preloading too much or incorrect content.
Extending the above example, we might want to preload a different association if certain fields are requested together. This can be done by overriding `#filtered_preloads` :","class MyThingResolver < BaseResolver
  # ...

  def filtered_preloads
    return [:alternate_attribute] if lookahead.selects?(:field_one) && lookahead.selects?(:field_two)

    super
  end
end
",
Look-Ahead,Resolvers/Optimizing Resolvers/Look-Ahead,"The `LooksAhead` concern also provides basic support for preloading associations based on nested GraphQL field definitions. The WorkItemsResolver is a good example for this. `nested_preloads` is another method you can define to return a hash, but unlike the `preloads` method, the value for each hash key is another hash and not the list of associations to preload. So in the previous example, you could override `nested_preloads` like this:","class MyThingResolver < BaseResolver
  # ...

  def nested_preloads
    {
      root_field: {
        nested_field1: :association_to_preload,
        nested_field2: [:association1, :association2]
      }
    }
  end
end
","For an example of real world use, see ResolvesMergeRequests ."
before_connection_authorization,Resolvers/Optimizing Resolvers/before_connection_authorization,"A `before_connection_authorization` hook can help resolvers eliminate N+1 problems that originate from type authorization permission checks.
The `before_connection_authorization` method receives the resolved nodes and the current user. In the block, use `ActiveRecord::Associations::Preloader` or a `Preloaders::` class to preload data for the type authorization check.
Example:","class LabelsResolver < BaseResolver
  before_connection_authorization do |labels, current_user|
    Preloaders::LabelsPreloader.new(labels, current_user).preload_all
  end
end
",
BatchLoading,Resolvers/Optimizing Resolvers/BatchLoading,See GraphQL BatchLoader .,,
Correct use of Resolver#ready?,Resolvers/Optimizing Resolvers/Correct use of Resolver#ready?,"Resolvers have two public API methods as part of the framework: `#ready?(**args)` and `#resolve(**args)` . We can use `#ready?` to perform set-up, validation, or early-return without invoking `#resolve` .
Good reasons to use `#ready?` include:
Validating mutually exclusive arguments. 
Returning `Relation.none` if we know before-hand that no results are possible. 
Performing setup such as initializing instance variables (although consider lazily initialized methods for this).
Implementations of Resolver#ready?(**args) should return `(Boolean,early_return_data)` as follows:","def ready?(**args)
  [false, 'have this instead']
end
","For this reason, whenever you call a resolver (mainly in tests because framework abstractions Resolvers should not be considered re-usable, finders are to be preferred), remember to call the `ready?` method and check the boolean flag before calling `resolve` ! An example can be seen in our GraphqlHelpers ."
Negated arguments,Resolvers/Optimizing Resolvers/Negated arguments,"Negated filters can filter some resources (for example, find all issues that have the `bug` label, but don’t have the `bug2` label assigned). The `not` argument is the preferred syntax to pass negated arguments:","issues(labelName: ""bug"", not: {labelName: ""bug2""}) {
  nodes {
    id
    title
  }
}
","To avoid duplicated argument definitions, you can place these arguments in a reusable module (or class, if the arguments are nested). Alternatively, you can consider to add a helper resolver method ."
Metadata,Resolvers/Optimizing Resolvers/Metadata,"When using resolvers, they can and should serve as the SSoT for field metadata. All field options (apart from the field name) can be declared on the resolver. These include:
`type` (required - all resolvers must include a type annotation) 
`extras` 
`description` 
Gitaly annotations (with `calls_gitaly!` )
Example:","module Resolvers
  MyResolver < BaseResolver
    type Types::MyType, null: true
    extras [:lookahead]
    description 'Retrieve a single MyType'
    calls_gitaly!
  end
end
",
Pass a parent object into a child Presenter,Resolvers/Optimizing Resolvers/Pass a parent object into a child Presenter,"Sometimes you need to access the resolved query parent in a child context to compute fields. Usually the parent is only available in the `Resolver` class as `parent` .
To find the parent object in your `Presenter` class:
Add the parent object to the GraphQL `context` from your resolver’s `resolve` method:","  def resolve(**args)
    context[:parent_object] = parent
  end
",
Pass a parent object into a child Presenter,Resolvers/Optimizing Resolvers/Pass a parent object into a child Presenter,Declare that your resolver or fields require the `parent` field context. For example:,"  # in ChildType
  field :computed_field, SomeType, null: true,
        method: :my_computing_method,
        extras: [:parent], # Necessary
        description: 'My field description.'

  field :resolver_field, resolver: SomeTypeResolver

  # In SomeTypeResolver

  extras [:parent]
  type SomeType, null: true
  description 'My field description.'
",
Pass a parent object into a child Presenter,Resolvers/Optimizing Resolvers/Pass a parent object into a child Presenter,"Declare your field’s method in your Presenter class and have it accept the `parent` keyword argument. This argument contains the parent GraphQL context , so you have to access the parent object with `parent[:parent_object]` or whatever key you used in your `Resolver` :","  # in ChildPresenter
  def my_computing_method(parent:)
    # do something with `parent[:parent_object]` here
  end

  # In SomeTypeResolver

  def resolve(parent:)
    # ...
  end
","For an example of real-world use, check this MR that added
 
 scopedPath
 
 and
 
 scopedUrl
 
 to
 
 IterationPresenter"
Mutations,Mutations,"Mutations are used to change any stored values, or to trigger actions. In the same way a GET-request should not modify data, we cannot modify data in a regular GraphQL-query. We can however in a mutation.",,
Building Mutations,Mutations/Building Mutations,"Mutations are stored in `app/graphql/mutations` , ideally grouped per resources they are mutating, similar to our services. They should inherit `Mutations::BaseMutation` . The fields defined on the mutation are returned as the result of the mutation.",,
Update mutation granularity,Mutations/Building Mutations/Update mutation granularity,"The service-oriented architecture in GitLab means that most mutations call a Create, Delete, or Update service, for example `UpdateMergeRequestService` . For Update mutations, you might want to only update one aspect of an object, and thus only need a fine-grained mutation, for example `MergeRequest::SetDraft` .
It’s acceptable to have both fine-grained mutations and coarse-grained mutations, but be aware that too many fine-grained mutations can lead to organizational challenges in maintainability, code comprehensibility, and testing. Each mutation requires a new class, which can lead to technical debt. It also means the schema becomes very big, which can make it difficult for users to navigate our schema. As each new mutation also needs tests (including slower request integration tests), adding mutations slows down the test suite.
To minimize changes:
Use existing mutations, such as `MergeRequest::Update` , when available. 
Expose existing services as a coarse-grained mutation.
When a fine-grained mutation might be more appropriate:
Modifying a property that requires specific permissions or other specialized logic. 
Exposing a state-machine-like transition (locking issues, merging MRs, closing epics, etc). 
Accepting nested properties (where we accept properties for a child object). 
The semantics of the mutation can be expressed clearly and concisely.
See issue #233063 for further context.",,
Naming conventions,Mutations/Building Mutations/Naming conventions,"Each mutation must define a `graphql_name` , which is the name of the mutation in the GraphQL schema.
Example:","class UserUpdateMutation < BaseMutation
  graphql_name 'UserUpdate'
end
","Due to changes in the `1.13` version of the `graphql-ruby` gem, `graphql_name` should be the first line of the class to ensure that type names are generated correctly. The `Graphql::GraphqlNamePosition` cop enforces this. See issue #27536 for further context.
Our GraphQL mutation names are historically inconsistent, but new mutation names should follow the convention `'{Resource}{Action}'` or `'{Resource}{Action}{Attribute}'` .
Mutations that create new resources should use the verb `Create` .
Example:
`CommitCreate`
Mutations that update data should use:
The verb `Update` . 
A domain-specific verb like `Set` , `Add` , or `Toggle` if more appropriate.
Examples:
`EpicTreeReorder` 
`IssueSetWeight` 
`IssueUpdate` 
`TodoMarkDone`
Mutations that remove data should use:
The verb `Delete` rather than `Destroy` . 
A domain-specific verb like `Remove` if more appropriate.
Examples:
`AwardEmojiRemove` 
`NoteDelete`
If you need advice for mutation naming, canvass the Slack `#graphql` channel for feedback."
Fields,Mutations/Building Mutations/Fields,"In the most common situations, a mutation would return 2 fields:
The resource being modified 
A list of errors explaining why the action could not be performed. If the mutation succeeded, this list would be empty.
By inheriting any new mutations from `Mutations::BaseMutation` the `errors` field is automatically added. A `clientMutationId` field is also added, this can be used by the client to identify the result of a single mutation when multiple are performed in a single request.",,
The resolve method,Mutations/Building Mutations/The resolve method,"Similar to writing resolvers , the `resolve` method of a mutation should aim to be a thin declarative wrapper around a service .
The `resolve` method receives the mutation’s arguments as keyword arguments. From here, we can call the service that modifies the resource.
The `resolve` method should then return a hash with the same field names as defined on the mutation including an `errors` array. For example, the `Mutations::MergeRequests::SetDraft` defines a `merge_request` field:","field :merge_request,
      Types::MergeRequestType,
      null: true,
      description: ""The merge request after mutation.""
",
The resolve method,Mutations/Building Mutations/The resolve method,This means that the hash returned from `resolve` in this mutation should look like this:,"{
  # The merge request modified, this will be wrapped in the type
  # defined on the field
  merge_request: merge_request,
  # An array of strings if the mutation failed after authorization.
  # The `errors_on_object` helper collects `errors.full_messages`
  errors: errors_on_object(merge_request)
}
",
Mounting the mutation,Mutations/Building Mutations/Mounting the mutation,To make the mutation available it must be defined on the mutation type that is stored in `graphql/types/mutation_type` . The `mount_mutation` helper method defines a field based on the GraphQL-name of the mutation:,"module Types
  class MutationType < BaseObject
    graphql_name 'Mutation'

    include Gitlab::Graphql::MountMutation

    mount_mutation Mutations::MergeRequests::SetDraft
  end
end
",Generates a field called `mergeRequestSetDraft` that `Mutations::MergeRequests::SetDraft` to be resolved.
Authorizing resources,Mutations/Building Mutations/Authorizing resources,"To authorize resources inside a mutation, we first provide the required abilities on the mutation like this:","module Mutations
  module MergeRequests
    class SetDraft < Base
      graphql_name 'MergeRequestSetDraft'

      authorize :update_merge_request
    end
  end
end
","We can then call `authorize!` in the `resolve` method, passing in the resource we want to validate the abilities for.
Alternatively, we can add a `find_object` method that loads the object on the mutation. This would allow you to use the `authorized_find!` helper method.
When a user is not allowed to perform the action, or an object is not found, we should raise a `Gitlab::Graphql::Errors::ResourceNotAvailable` by calling `raise_resource_not_available_error!` from in the `resolve` method."
Errors in mutations,Mutations/Building Mutations/Errors in mutations,"We encourage following the practice of errors as data for mutations, which distinguishes errors by who they are relevant to, defined by who can deal with them.
Key points:
All mutation responses have an `errors` field. This should be populated on failure, and may be populated on success. 
Consider who needs to see the error: the user or the developer . 
Clients should always request the `errors` field when performing mutations. 
Errors may be reported to users either at `$root.errors` (top-level error) or at `$root.data.mutationName.errors` (mutation errors). The location depends on what kind of error this is, and what information it holds. 
Mutation fields must have
 
 null: true
Consider an example mutation `doTheThing` that returns a response with two fields: `errors:[String]` , and `thing:ThingType` . The specific nature of the `thing` itself is irrelevant to these examples, as we are considering the errors.
The three states a mutation response can be in are:
Success 
Failure (relevant to the user) 
Failure (irrelevant to the user)",,
Success,Mutations/Building Mutations/Errors in mutations/Success,"In the happy path, errors may be returned, along with the anticipated payload, but if everything was successful, then `errors` should be an empty array, because there are no problems we need to inform the user of.","{
  data: {
    doTheThing: {
      errors: [] // if successful, this array will generally be empty.
      thing: { .. }
    }
  }
}
",
Failure (relevant to the user),Mutations/Building Mutations/Errors in mutations/Failure (relevant to the user),"An error that affects the user occurred. We refer to these as mutation errors .
In a create mutation there is typically no `thing` to return.
In an update mutation we return the current true state of `thing` . Developers may need to call `#reset` on the `thing` instance to ensure this happens.","{
  data: {
    doTheThing: {
      errors: [""you cannot touch the thing""],
      thing: { .. }
    }
  }
}
","Examples of this include:
Model validation errors: the user may need to change the inputs. 
Permission errors: the user needs to know they cannot do this, they may need to request permission or sign in. 
Problems with the application state that prevent the user’s action (for example, merge conflicts or a locked resource).
Ideally, we should prevent the user from getting this far, but if they do, they need to be told what is wrong, so they understand the reason for the failure and what they can do to achieve their intent. For example, they might only need to retry the request.
It is possible to return recoverable errors alongside mutation data. For example, if a user uploads 10 files and 3 of them fail and the rest succeed, the errors for the failures can be made available to the user, alongside the information about the successes."
Failure (irrelevant to the user),Mutations/Building Mutations/Errors in mutations/Failure (irrelevant to the user),"One or more non-recoverable errors can be returned at the top level . These are things over which the user has little to no control, and should mainly be system or programming problems, that a developer needs to know about. In this case there is no `data` :","{
  errors: [
    {""message"": ""argument error: expected an integer, got null""},
  ]
}
","This results from raising an error during the mutation. In our implementation, the messages of argument errors and validation errors are returned to the client, and all other `StandardError` instances are caught, logged and presented to the client with the message set to `""Internalservererror""` . See GraphqlController for details.
These represent programming errors, such as:
A GraphQL syntax error, where an `Int` was passed instead of a `String` , or a required argument was not present. 
Errors in our schema, such as being unable to provide a value for a non-nullable field. 
System errors: for example, a Git storage exception, or database unavailability.
The user should not be able to cause such errors in regular usage. This category of errors should be treated as internal, and not shown to the user in specific detail.
We need to inform the user when the mutation fails, but we do not need to tell them why, because they cannot have caused it, and nothing they can do fixes it, although we may offer to retry the mutation."
Categorizing errors,Mutations/Building Mutations/Errors in mutations/Categorizing errors,"When we write mutations, we need to be conscious about which of these two categories an error state falls into (and communicate about this with frontend developers to verify our assumptions). This means distinguishing the needs of the user from the needs of the client .
Never catch an error unless the user needs to know about it.
If the user does need to know about it, communicate with frontend developers to make sure the error information we are passing back is relevant and serves a purpose.
See also the frontend GraphQL guide .",,
Aliasing and deprecating mutations,Mutations/Building Mutations/Errors in mutations/Aliasing and deprecating mutations,"The `#mount_aliased_mutation` helper allows us to alias a mutation as another name in `MutationType` .
For example, to alias a mutation called `FooMutation` as `BarMutation` :","mount_aliased_mutation 'BarMutation', Mutations::FooMutation
",
Aliasing and deprecating mutations,Mutations/Building Mutations/Errors in mutations/Aliasing and deprecating mutations,"This allows us to rename a mutation and continue to support the old name, when coupled with the deprecated argument.
Example:","mount_aliased_mutation 'UpdateFoo',
                        Mutations::Foo::Update,
                        deprecated: { reason: 'Use fooUpdate', milestone: '13.2' }
","Deprecated mutations should be added to `Types::DeprecatedMutations` and tested for in the unit test of `Types::MutationType` . The merge request !34798 can be referred to as an example of this, including the method of testing deprecated aliased mutations."
Deprecating EE mutations,Mutations/Building Mutations/Errors in mutations/Aliasing and deprecating mutations/Deprecating EE mutations,"EE mutations should follow the same process. For an example of the merge request process, read merge request !42588 .",,
Subscriptions,Subscriptions,"We use subscriptions to push updates to clients. We use the Action Cable implementation to deliver the messages over websockets.
When a client subscribes to a subscription, we store their query in-memory in Puma workers. Then when the subscription is triggered, the Puma workers execute the stored GraphQL queries and push the results to the clients.
note 
We cannot test subscriptions using GraphiQL, because they require an Action Cable client, which GraphiQL does not support at the moment.",,
Building subscriptions,Subscriptions/Building subscriptions,"All fields under `Types::SubscriptionType` are subscriptions that clients can subscribe to. These fields require a subscription class, which is a descendant of `Subscriptions::BaseSubscription` and is stored under `app/graphql/subscriptions` .
The arguments required to subscribe and the fields that are returned are defined in the subscription class. Multiple fields can share the same subscription class if they have the same arguments and return the same fields.
This class runs during the initial subscription request and subsequent updates. You can read more about this in the GraphQL Ruby guides .",,
Authorization,Subscriptions/Authorization,"You should implement the `#authorized?` method of the subscription class so that the initial subscription and subsequent updates are authorized.
When a user is not authorized, you should call the `unauthorized!` helper so that execution is halted and the user is unsubscribed. Returning `false` results in redaction of the response, but we leak information that some updates are happening. This leakage is due to a bug in the GraphQL gem .",,
Triggering subscriptions,Subscriptions/Triggering subscriptions,Define a method under the `GraphqlTriggers` module to trigger a subscription. Do not call `GitlabSchema.subscriptions.trigger` directly in application code so that we have a single source of truth and we do not trigger a subscription with different arguments and objects.,,
Pagination implementation,Pagination implementation,"For more information, see GraphQL pagination .",,
Arguments,Arguments,"Arguments for a resolver or mutation are defined using `argument` .
Example:","argument :my_arg, GraphQL::Types::String,
         required: true,
         description: ""A description of the argument.""
",
Nullability,Arguments/Nullability,"Arguments can be marked as `required:true` which means the value must be present and not `null` . If a required argument’s value can be `null` , use the `required::nullable` declaration.
Example:","argument :due_date,
         Types::TimeType,
         required: :nullable,
         description: 'The desired due date for the issue. Due date is removed if null.'
",
Nullability,Arguments/Nullability,"In the above example, the `due_date` argument must be given, but unlike the GraphQL spec, the value can be `null` . This allows ‘unsetting’ the due date in a single mutation rather than creating a new mutation for removing the due date.","{ due_date: null } # => OK
{ due_date: ""2025-01-10"" } # => OK
{  } # => invalid (not given)
",
Nullability and required: false,Arguments/Nullability/Nullability and required: false,"If an argument is marked `required:false` the client is permitted to send `null` as a value. Often this is undesirable.
If an argument is optional but `null` is not an allowed value, use validation to ensure that passing `null` returns an error:","argument :name, GraphQL::Types::String,
         required: false,
         validates: { allow_null: false }
",
Nullability and required: false,Arguments/Nullability/Nullability and required: false,"Alternatively, if you wish to allow `null` when it is not an allowed value, you can replace it with a default value:","argument :name, GraphQL::Types::String,
         required: false,
         default_value: ""No Name Provided"",
         replace_null_with_default: true
","See Validation , Nullability and Default Values for more details."
Keywords,Arguments/Nullability/Keywords,"Each GraphQL `argument` defined is passed to the `#resolve` method of a mutation as keyword arguments.
Example:","def resolve(my_arg:)
  # Perform mutation ...
end
",
Input Types,Arguments/Nullability/Input Types,"`graphql-ruby` wraps up arguments into an input type .
For example, the mergeRequestSetDraft
 
 mutation defines these arguments (some through inheritance ):","argument :project_path, GraphQL::Types::ID,
         required: true,
         description: ""Project the merge request belongs to.""

argument :iid, GraphQL::Types::String,
         required: true,
         description: ""IID of the merge request.""

argument :draft,
         GraphQL::Types::Boolean,
         required: false,
         description: <<~DESC
           Whether or not to set the merge request as a draft.
         DESC
",These arguments automatically generate an input type called `MergeRequestSetDraftInput` with the 3 arguments we specified and the `clientMutationId` .
Object identifier arguments,Arguments/Nullability/Object identifier arguments,"Arguments that identify an object should be:
A full path or an IID if an object has either. 
The object’s Global ID for all other objects. Never use plain database primary key IDs.",,
Full path object identifier arguments,Arguments/Nullability/Object identifier arguments/Full path object identifier arguments,"Historically we have been inconsistent with the naming of full path arguments, but prefer to name the argument:
`project_path` for a project full path 
`group_path` for a group full path 
`namespace_path` for a namespace full path
Using an example from the ciJobTokenScopeRemoveProject
 
 mutation :","argument :project_path, GraphQL::Types::ID,
         required: true,
         description: 'Project the CI job token scope belongs to.'
",
IID object identifier arguments,Arguments/Nullability/Object identifier arguments/IID object identifier arguments,Use the `iid` of an object in combination with its parent `project_path` or `group_path` . For example:,"argument :project_path, GraphQL::Types::ID,
         required: true,
         description: 'Project the issue belongs to.'

argument :iid, GraphQL::Types::String,
         required: true,
         description: 'IID of the issue.'
",
Global ID object identifier arguments,Arguments/Nullability/Object identifier arguments/Global ID object identifier arguments,"Using an example from the discussionToggleResolve
 
 mutation :","argument :id, Types::GlobalIDType[Discussion],
         required: true,
         description: 'Global ID of the discussion.'
",See also Deprecate Global IDs .
Sort arguments,Arguments/Nullability/Object identifier arguments/Sort arguments,"Sort arguments should use an enum type whenever possible to describe the set of available sorting values.
The enum can inherit from `Types::SortEnum` to inherit some common values.
The enum values should follow the format `{PROPERTY}_{DIRECTION}` . For example:","TITLE_ASC
",
Sort arguments,Arguments/Nullability/Object identifier arguments/Sort arguments,"Also see the description style guide for sort enums .
Example from ContainerRepositoriesResolver :","# Types::ContainerRepositorySortEnum:
module Types
  class ContainerRepositorySortEnum < SortEnum
    graphql_name 'ContainerRepositorySort'
    description 'Values for sorting container repositories'

    value 'NAME_ASC', 'Name by ascending order.', value: :name_asc
    value 'NAME_DESC', 'Name by descending order.', value: :name_desc
  end
end

# Resolvers::ContainerRepositoriesResolver:
argument :sort, Types::ContainerRepositorySortEnum,
          description: 'Sort container repositories by this criteria.',
          required: false,
          default_value: :created_desc
",
Types::TimeType,GitLab custom scalars/Types::TimeType,"Types::TimeType must be used as the type for all fields and arguments that deal with Ruby `Time` and `DateTime` objects.
The type is a custom scalar that:
Converts Ruby’s `Time` and `DateTime` objects into standardized ISO-8601 formatted strings, when used as the type for our GraphQL fields. 
Converts ISO-8601 formatted time strings into Ruby `Time` objects, when used as the type for our GraphQL arguments.
This allows our GraphQL API to have a standardized way that it presents time and handles time inputs.
Example:","field :created_at, Types::TimeType, null: true, description: 'Timestamp of when the issue was created.'
",
Testing,Testing,"For testing mutations and resolvers, consider the unit of test a full GraphQL request, not a call to a resolver. This allows us to avoid tight coupling to the framework because such coupling makes upgrades to dependencies much more difficult.
You should:
Prefer request specs (either using the full API endpoint or going through `GitlabSchema.execute` ) to unit specs for resolvers and mutations. 
Prefer `GraphqlHelpers#execute_query` and `GraphqlHelpers#run_with_clean_state` to `GraphqlHelpers#resolve` and `GraphqlHelpers#resolve_field` .
For example:","# Good:
gql_query = %q(some query text...)
post_graphql(gql_query, current_user: current_user)
# or:
GitlabSchema.execute(gql_query, context: { current_user: current_user })

# Deprecated: avoid
resolve(described_class, obj: project, ctx: { current_user: current_user })
",
Writing unit tests (deprecated),Testing/Writing unit tests (deprecated),"caution 
Avoid writing unit tests if the same thing can be tested with a full GraphQL request.
Before creating unit tests, review the following examples:
spec/graphql/resolvers/users_resolver_spec.rb 
spec/graphql/mutations/issues/create_spec.rb",,
Writing integration tests,Testing/Writing integration tests,"Integration tests check the full stack for a GraphQL query or mutation and are stored in `spec/requests/api/graphql` .
For speed, consider calling `GitlabSchema.execute` directly, or making use of smaller test schemas that only contain the types under test.
However, full request integration tests that check if data is returned verify the following additional items:
The mutation is actually queryable in the schema (was mounted in `MutationType` ). 
The data returned by a resolver or mutation correctly matches the return types of the fields and resolves without errors. 
The arguments coerce correctly on input, and the fields serialize correctly on output.
Integration tests can also verify the following items, because they invoke the full stack:
An argument or scalar’s validations apply correctly. 
Logic in a resolver or mutation’s #ready?
 
 method applies correctly. 
An argument’s
 
 default_value applies correctly. 
Objects resolve successfully, and there are no N+1 issues.
When adding a query, you can use the `aworkinggraphqlquerythatreturnsdata` and `aworkinggraphqlquerythatreturnsnodata` shared examples to test if the query renders valid results.
You can construct a query including all available fields using the `GraphqlHelpers#all_graphql_fields_for` helper. This makes it more straightforward to add a test rendering all possible fields for a query.
If you’re adding a field to a query that supports pagination and sorting, visit Testing for details.
To test GraphQL mutation requests, `GraphqlHelpers` provides two helpers: `graphql_mutation` which takes the name of the mutation, and a hash with the input for the mutation. This returns a struct with a mutation query, and prepared variables.
You can then pass this struct to the `post_graphql_mutation` helper, that posts the request with the correct parameters, like a GraphQL client would do.
To access the response of a mutation, you can use the `graphql_mutation_response` helper.
Using these helpers, you can build specs like this:","let(:mutation) do
  graphql_mutation(
    :merge_request_set_wip,
    project_path: 'gitlab-org/gitlab-foss',
    iid: '1',
    wip: true
  )
end

it 'returns a successful response' do
   post_graphql_mutation(mutation, current_user: user)

   expect(response).to have_gitlab_http_status(:success)
   expect(graphql_mutation_response(:merge_request_set_wip)['errors']).to be_empty
end
",
Testing tips and tricks,Testing/Testing tips and tricks,"Become familiar with the methods in the `GraphqlHelpers` support module. Many of these methods make writing GraphQL tests easier. 
Use traversal helpers like `GraphqlHelpers#graphql_data_at` and `GraphqlHelpers#graphql_dig_at` to access result fields. For example:","result = GitlabSchema.execute(query)

mr_iid = graphql_dig_at(result.to_h, :data, :project, :merge_request, :iid)
",
Testing tips and tricks,Testing/Testing tips and tricks,Use `GraphqlHelpers#a_graphql_entity_for` to match against results. For example:,"post_graphql(some_query)

# checks that it is a hash containing { id => global_id_of(issue) }
expect(graphql_data_at(:project, :issues, :nodes))
  .to contain_exactly(a_graphql_entity_for(issue))

# Additional fields can be passed, either as names of methods, or with values
expect(graphql_data_at(:project, :issues, :nodes))
  .to contain_exactly(a_graphql_entity_for(issue, :iid, :title, created_at: some_time))
",
Testing tips and tricks,Testing/Testing tips and tricks,"Use `GraphqlHelpers#empty_schema` to create an empty schema, rather than creating one by hand. For example:","# good
let(:schema) { empty_schema }

# bad
let(:query_type) { GraphQL::ObjectType.new }
let(:schema) { GraphQL::Schema.define(query: query_type, mutation: nil)}
",
Testing tips and tricks,Testing/Testing tips and tricks,"Use `GraphqlHelpers#query_double(schema:nil)` of `double('query',schema:nil)` . For example:","# good
let(:query) { query_double(schema: GitlabSchema) }

# bad
let(:query) { double('Query', schema: GitlabSchema) }
",
Testing tips and tricks,Testing/Testing tips and tricks,"Avoid false positives: 
Authenticating a user with the `current_user:` argument for `post_graphql` generates more queries on the first request than on subsequent requests on that same user. If you are testing for N+1 queries using QueryRecorder , use a different user for each request. 
The below example shows how a test for avoiding N+1 queries should look:","RSpec.describe 'Query.project(fullPath).pipelines' do
  include GraphqlHelpers

  let(:project) { create(:project) }

  let(:query) do
    %(
      {
        project(fullPath: ""#{project.full_path}"") {
          pipelines {
            nodes {
              id
            }
          }
        }
      }
    )
  end

  it 'avoids N+1 queries' do
    first_user = create(:user)
    second_user = create(:user)
    create(:ci_pipeline, project: project)

    control_count = ActiveRecord::QueryRecorder.new do
      post_graphql(query, current_user: first_user)
    end

    create(:ci_pipeline, project: project)

    expect do
      post_graphql(query, current_user: second_user)  # use a different user to avoid a false positive from authentication queries
    end.not_to exceed_query_limit(control_count)
  end
end
",
Testing tips and tricks,Testing/Testing tips and tricks,"Mimic the folder structure of `app/graphql/types` : 
For example, tests for fields on `Types::Ci::PipelineType` in `app/graphql/types/ci/pipeline_type.rb` should be stored in `spec/requests/api/graphql/ci/pipeline_spec.rb` regardless of the query being used to fetch the pipeline data. 
When testing resolvers using `GraphqlHelpers#resolve` , arguments for the resolver can be handled two ways. 
95% of the resolver specs use arguments that are Ruby objects, as opposed to when using the GraphQL API only strings and integers are used. This works fine in most cases. 
If your resolver takes arguments that use a `prepare` proc, such as a resolver that accepts time frame arguments ( `TimeFrameArguments` ), you must pass the `arg_style::internal_prepared` parameter into the `resolve` method. This tells the code to convert the arguments into strings and integers and pass them through regular argument handling, ensuring that the `prepare` proc is called correctly. For example in iterations_resolver_spec.rb :","def resolve_group_iterations(args = {}, obj = group, context = { current_user: current_user })
  resolve(described_class, obj: obj, args: args, ctx: context, arg_style: :internal_prepared)
end
",
Testing tips and tricks,Testing/Testing tips and tricks,"One additional caveat is that if you are passing enums as a resolver argument, you must use the external representation of the enum, rather than the internal. For example:","# good
resolve_group_iterations({ search: search, in: ['CADENCE_TITLE'] })

# bad
resolve_group_iterations({ search: search, in: [:cadence_title] })
","The use of `:internal_prepared` was added as a bridge for the GraphQL gem upgrade. Testing resolvers directly will eventually be removed , and writing unit tests for resolvers/mutations is already deprecated"
Notes about Query flow and GraphQL infrastructure,Notes about Query flow and GraphQL infrastructure,"The GitLab GraphQL infrastructure can be found in `lib/gitlab/graphql` .
Instrumentation is functionality that wraps around a query being executed. It is implemented as a module that uses the `Instrumentation` class.
Example: `Present`","module Gitlab
  module Graphql
    module Present
      #... some code above...

      def self.use(schema_definition)
        schema_definition.instrument(:field, ::Gitlab::Graphql::Present::Instrumentation.new)
      end
    end
  end
end
","A Query Analyzer contains a series of callbacks to validate queries before they are executed. Each field can pass through the analyzer, and the final value is also available to you.
Multiplex queries enable multiple queries to be sent in a single request. This reduces the number of requests sent to the server. (there are custom Multiplex Query Analyzers and Multiplex Instrumentation provided by GraphQL Ruby)."
Query limits,Notes about Query flow and GraphQL infrastructure/Query limits,"Queries and mutations are limited by depth, complexity, and recursion to protect server resources from overly ambitious or malicious queries. These values can be set as defaults and overridden in specific queries as needed. The complexity values can be set per object as well, and the final query complexity is evaluated based on how many objects are being returned. This can be used for objects that are expensive (such as requiring Gitaly calls).
For example, a conditional complexity method in a resolver:","def self.resolver_complexity(args, child_complexity:)
  complexity = super
  complexity += 2 if args[:labelName]

  complexity
end
",More about complexity: GraphQL Ruby documentation .
Documentation and schema,Documentation and schema,"Our schema is located at `app/graphql/gitlab_schema.rb` . See the schema reference for details.
This generated GraphQL documentation needs to be updated when the schema changes. For information on generating GraphQL documentation and schema files, see updating the schema documentation .
To help our readers, you should also add a new page to our GraphQL API documentation. For guidance, see the GraphQL API page.",,
Include a changelog entry,Include a changelog entry,All client-facing changes must include a changelog entry .,,
Laziness,Laziness,"One important technique unique to GraphQL for managing performance is using lazy values. Lazy values represent the promise of a result, allowing their action to be run later, which enables batching of queries in different parts of the query tree. The main example of lazy values in our code is the GraphQL BatchLoader .
To manage lazy values directly, read `Gitlab::Graphql::Lazy` , and in particular `Gitlab::Graphql::Laziness` . This contains `#force` and `#delay` , which help implement the basic operations of creation and elimination of laziness, where needed.
For dealing with lazy values without forcing them, use `Gitlab::Graphql::Lazy.with_value` .",,
