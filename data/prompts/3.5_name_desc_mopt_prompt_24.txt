Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.6.2 Horizontal whitespace
Beyond where required by the language or other style rules, and apart from literals, comments and Javadoc, a single ASCII space also appears in the following places only .
 Separating any reserved word, such as `if` , `for` or `catch` , from an open parenthesis ( `(` ) that follows it on that line 
 Separating any reserved word, such as `else` or `catch` , from a closing curly brace ( `}` ) that precedes it on that line 
 Before any open curly brace ( `{` ), with two exceptions: 
 `@SomeAnnotation({a,b})` (no space is used) 
 `String[][]x={{"foo"}};` (no space is required between `{{` , by item 9 below) 
 On both sides of any binary or ternary operator. This also applies to the following "operator-like" symbols: 
 the ampersand in a conjunctive type bound: `<TextendsFoo&Bar>` 
 the pipe for a catch block that handles multiple exceptions: `catch(FooException|BarExceptione)` 
 the colon ( `:` ) in an enhanced `for` ("foreach") statement 
 the arrow in a lambda expression: `(Stringstr)->str.length()` 
 but not 
 the two colons ( `::` ) of a method reference, which is written like `Object::toString` 
 the dot separator ( `.` ), which is written like `object.toString()` 
 After `,:;` or the closing parenthesis ( `)` ) of a cast 
 Between any content and a double slash ( `//` ) which begins a comment. Multiple spaces are allowed. 
 Between a double slash ( `//` ) which begins a comment and the comment's text. Multiple spaces are allowed. 
 Between the type and variable of a declaration: `List<String>list` 
 Optional just inside both braces of an array initializer 
 `newint[]{5,6}` and `newint[]{5,6}` are both valid 
 Between a type annotation and `[]` or `...` .
 This rule is never interpreted as requiring or forbidding additional space at the start or end of a line; it addresses only interior space.

CheckStyle Rules:
[Rule]
SingleSpaceSeparator
[Description]
Checks that non-whitespace characters are separated by no more than one
whitespace. Separating characters by tabs or multiple spaces will be
reported. Currently, the check doesn't permit horizontal alignment. To inspect
whitespaces before and after comments, set the property
validateComments to true.


Setting validateComments to false will ignore cases like:



int i;  // Multiple whitespaces before comment tokens will be ignored.
private void foo(int  /* whitespaces before and after block-comments will be
ignored */  i) {


Sometimes, users like to space similar items on different lines to the same
column position for easier reading. This feature isn't supported by this
check, so both braces in the following case will be reported as violations.



public long toNanos(long d)  { return d;             } // 2 violations
public long toMicros(long d) { return d / (C1 / C0); }
[Options]
validateComments, Control whether to validate whitespaces surrounding comments.
[Rule]
JavadocMissingWhitespaceAfterAsterisk
[Description]
Checks that there is at least one whitespace after the leading asterisk.
Although spaces after asterisks are optional in the Javadoc comments, their absence
makes the documentation difficult to read. It is the de facto standard to put at least
one whitespace after the leading asterisk.
[Options]
violateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at
Tight-HTML Rules.
[Rule]
WhitespaceAround
[Description]
Checks that a token is surrounded by whitespace. Empty constructor,
method, class, enum, interface, loop bodies (blocks), lambdas of the form


public MyClass() {}      // empty constructor
public void func() {}    // empty method
public interface Foo {} // empty interface
public class Foo {} // empty class
public enum Foo {} // empty enum
MyClass c = new MyClass() {}; // empty anonymous class
while (i = 1) {} // empty while loop
for (int i = 1; i > 1; i++) {} // empty for loop
do {} while (i = 1); // empty do-while loop
Runnable noop = () -> {}; // empty lambda
public @interface Beta {} // empty annotation type


may optionally be exempted from the policy using the
allowEmptyMethods, allowEmptyConstructors,
allowEmptyTypes, allowEmptyLoops,
allowEmptyLambdas and allowEmptyCatches
properties.

This check does not flag as violation double brace initialization like:



new Properties() {{
setProperty("key", "value");
}};


Parameter allowEmptyCatches allows to suppress violations when token
list contains SLIST to check if beginning of block is surrounded by
whitespace and catch block is empty, for example:



try {
k = 5 / i;
} catch (ArithmeticException ex) {}



With this property turned off, this raises violation because the beginning of the
catch block (left curly bracket) is not separated from the end of the catch
block (right curly bracket).
[Options]
allowEmptyCatches, Allow empty catch bodies.
allowEmptyConstructors, Allow empty constructor bodies.
allowEmptyLambdas, Allow empty lambda bodies.
allowEmptyLoops, Allow empty loop bodies.
allowEmptyMethods, Allow empty method bodies.
allowEmptyTypes, Allow empty class, interface and enum bodies.
ignoreEnhancedForColon, Ignore whitespace around colon in
enhanced for loop.
tokens, tokens to check
[Rule]
GenericWhitespace
[Description]
Checks that the whitespace around the Generic tokens (angle brackets)
"<" and ">" are correct to the typical convention.
The convention is not configurable.


Left angle bracket ("<"):


should be preceded with whitespace only in generic methods definitions.
should not be preceded with whitespace when it is preceded method name
or constructor.
should not be preceded with whitespace when following type name.
should not be followed with whitespace in all cases.


Right angle bracket (">"):


should not be preceded with whitespace in all cases.
should be followed with whitespace in almost all cases, except diamond operators
and when preceding a method name, constructor, or record header.
[Options]
[Rule]
JavadocParagraph
[Description]
Checks the Javadoc paragraph.


Checks that:



There is one blank line between each of two paragraphs.


Each paragraph but the first has <p> immediately before the first word, with
no space after.
[Options]
allowNewlineParagraph, Control whether the <p> tag should be placed immediately before the first word.
violateExecutionOnNonTightHtml, Control when to print violations if the Javadoc being examined by this check violates the tight html rules defined at
Tight-HTML Rules.
[Rule]
NoWhitespaceBefore
[Description]
Checks that there is no whitespace before a token. More
specifically, it checks that it is not preceded with whitespace, or
(if linebreaks are allowed) all characters on the line before are
whitespace. To allow linebreaks before a token, set property
allowLineBreaks to true. No check occurs
before semicolons in empty for loop initializers or conditions.
[Options]
allowLineBreaks, Control whether whitespace is allowed if the token is at a linebreak.
tokens, tokens to check
[Rule]
TrailingComment
[Description]
The check to ensure that lines with code do not end with comment.
For the case of // comments that means that the only thing
that should precede it is whitespace. It doesn't check comments if
they do not end a line; for example, it accepts the following:
Thread.sleep( 10 /*some comment here*/ ); Format
property is intended to deal with the } // while example.


Rationale: Steve McConnell in Code Complete suggests that
endline comments are a bad practice. An end line comment would be
one that is on the same line as actual code. For example:



a = b + c;      // Some insightful comment
d = e / f;        // Another comment for this line


Quoting Code Complete for the justification:


"The comments have to be aligned so that they do not
interfere with the visual structure of the code. If you don't align
them neatly, they'll make your listing look like it's been through a
washing machine."

"Endline comments tend to be hard to format...It takes
time to align them. Such time is not spent learning more about the
code; it's dedicated solely to the tedious task of pressing the
spacebar or tab key."

"Endline comments are also hard to maintain. If the code
on any line containing an endline comment grows, it bumps the
comment farther out, and all the other endline comments will have to
bumped out to match. Styles that are hard to maintain aren't
maintained...."

"Endline comments also tend to be cryptic. The right side
of the line doesn't offer much room and the desire to keep the
comment on one line means the comment must be short. Work then goes
into making the line as short as possible instead of as clear as
possible. The comment usually ends up as cryptic as
possible...."

"A systemic problem with endline comments is that it's
hard to write a meaningful comment for one line of code. Most
endline comments just repeat the line of code, which hurts more than
it helps."



McConnell's comments on being hard to maintain when the size of the line
changes are even more important in the age of automated
refactorings.
[Options]
format, Specify pattern for strings allowed before the comment.
legalComment, Define pattern for text allowed in trailing comments. This pattern will not be applied to multiline comments.
[Rule]
Indentation
[Description]
Checks correct indentation of Java code.


The idea behind this is that while pretty printers are
sometimes convenient for bulk reformats of legacy code, they often
either aren't configurable enough or just can't anticipate how
format should be done. Sometimes this is personal preference, other
times it is practical experience. In any case, this check should
just ensure that a minimal set of indentation rules is followed.


Basic offset indentation is used for indentation inside code blocks.
For any lines that span more than 1, line wrapping indentation is used for those
lines after the first.
Brace adjustment, case, and throws indentations are all used only if those specific
identifiers start the line. If, for example, a brace is used in the middle of the line,
its indentation will not take effect.
All indentations have an accumulative/recursive effect when they are triggered. If
during a line wrapping, another code block is found and it doesn't end on that same
line, then the subsequent lines afterwards, in that new code block, are increased on
top of the line wrap and any indentations above it.

Example:


if ((condition1 && condition2)
|| (condition3 && condition4)    // line wrap with bigger indentation
||!(condition5 && condition6)) { // line wrap with bigger indentation
field.doSomething()                    // basic offset
.doSomething()                     // line wrap
.doSomething( c -> {               // line wrap
return c.doSome();               // basic offset
});
}
[Options]
arrayInitIndent, Specify how far an array initialization should be indented when on next line.
basicOffset, Specify how far new indentation level should be indented when on the next line.
braceAdjustment, Specify how far a braces should be indented when on the next line.
caseIndent, Specify how far a case label should be indented when on next line.
forceStrictCondition, Force strict indent level in line wrapping case. If value is true, line wrap indent have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like.
lineWrappingIndentation, Specify how far continuation line should be indented when line-wrapping is present.
throwsIndent, Specify how far a throws clause should be indented when on next line.
[Rule]
JavadocContentLocation
[Description]
Checks that the Javadoc content begins from the same position
for all Javadoc comments in the project. Any leading asterisks and spaces
are not counted as the beginning of the content and are therefore ignored.


It is possible to enforce two different styles:



{@code first_line} - Javadoc content starts from the first line:



/** Summary text.
* More details.
*/
public void method();



{@code second_line} - Javadoc content starts from the second line:



/**
* Summary text.
* More details.
*/
public void method();
[Options]
location, Specify the policy on placement of the Javadoc content.
[Rule]
EmptyLineSeparator
[Description]
Checks for empty line separators before package, all import declarations,
fields, constructors, methods, nested classes,
static initializers and instance initializers.


Checks for empty line separators before not only statements but
implementation and documentation comments and blocks as well.


ATTENTION: empty line separator is required between token siblings,
not after line where token is found.
If token does not have a sibling of the same type, then empty line
is required at its end (for example for CLASS_DEF it is after '}').
Also, trailing comments are skipped.
[Options]
allowMultipleEmptyLines, Allow multiple empty lines between class members.
allowMultipleEmptyLinesInsideClassMembers, Allow multiple empty lines inside class members.
allowNoEmptyLineBetweenFields, Allow no empty line between fields.
tokens, tokens to check

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
