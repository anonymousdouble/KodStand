Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
7.3.1 Exception: self-explanatory members
Javadoc is optional for "simple, obvious" members like `getFoo()` , in cases where there really and truly is nothing else worthwhile to say but "Returns the foo".
 Important: it is not appropriate to cite this exception to justify omitting relevant information that a typical reader might need to know. For example, for a method named `getCanonicalName` , don't omit its documentation (with the rationale that it would say only `/**Returnsthecanonicalname.*/` ) if a typical reader may have no idea what the term "canonical name" means!

CheckStyle Rules:
[Rule]
DesignForExtension
[Description]
Checks that classes are designed for extension (subclass creation).


Nothing wrong could be with founded classes.
This check makes sense only for library projects (not application projects)
which care of ideal OOP-design to make sure that class works in all cases even misusage.
Even in library projects this check most likely will find classes that are designed
for extension by somebody. User needs to use suppressions extensively to got a benefit
from this check, and keep in suppressions all confirmed/known classes that are deigned
for inheritance intentionally to let the check catch only new classes, and bring this to
team/user attention.


ATTENTION: Only user can decide whether a class is designed for extension or not.
The check just shows all classes which are possibly designed for extension.
If smth inappropriate is found please use suppression.


ATTENTION: If the method which can be overridden in a subclass has a javadoc comment
(a good practice is to explain its self-use of overridable methods) the check will not
rise a violation. The violation can also be skipped if the method which can be overridden
in a subclass has one or more annotations that are specified in ignoredAnnotations
option. Note, that by default @Override annotation is not included in the
ignoredAnnotations set as in a subclass the method which has the annotation can also be
overridden in its subclass.


Problem is described at "Effective Java, 2nd Edition by Joshua Bloch" book, chapter
"Item 17: Design and document for inheritance or else prohibit it".


Some quotes from book:

The class must document its self-use of overridable methods.
By convention, a method that invokes overridable methods contains a description
of these invocations at the end of its documentation comment. The description
begins with the phrase ¡°This implementation.¡±

The best solution to this problem is to prohibit subclassing in classes that
are not designed and documented to be safely subclassed.

If a concrete class does not implement a standard interface, then you may
inconvenience some programmers by prohibiting inheritance. If you feel that you
must allow inheritance from such a class, one reasonable approach is to ensure
that the class never invokes any of its overridable methods and to document this
fact. In other words, eliminate the class¡¯s self-use of overridable methods entirely.
In doing so, you¡¯ll create a class that is reasonably safe to subclass. Overriding a
method will never affect the behavior of any other method.


The check finds classes that have overridable methods (public or protected methods
that are non-static, not-final, non-abstract) and have non-empty implementation.


Rationale: This library design style protects superclasses against
being broken by subclasses. The downside is that subclasses are
limited in their flexibility, in particular they cannot prevent
execution of code in the superclass, but that also means that
subclasses cannot corrupt the state of the superclass by forgetting
to call the superclass's method.


More specifically,
it enforces a programming style where superclasses provide empty
"hooks" that can be implemented by subclasses.


Example of code that cause violation as it is designed for extension:



public abstract class Plant {
private String roots;
private String trunk;

protected void validate() {
if (roots == null) throw new IllegalArgumentException("No roots!");
if (trunk == null) throw new IllegalArgumentException("No trunk!");
}

public abstract void grow();
}

public class Tree extends Plant {
private List leaves;

@Overrides
protected void validate() {
super.validate();
if (leaves == null) throw new IllegalArgumentException("No leaves!");
}

public void grow() {
validate();
}
}


Example of code without violation:



public abstract class Plant {
private String roots;
private String trunk;

private void validate() {
if (roots == null) throw new IllegalArgumentException("No roots!");
if (trunk == null) throw new IllegalArgumentException("No trunk!");
validateEx();
}

protected void validateEx() { }

public abstract void grow();
}
[Rule]
InvalidJavadocPosition
[Description]
Checks that Javadocs are located at the correct position.
As specified at

Documentation Comment Specification for the Standard Doclet,
Javadocs are recognized only when placed immediately before module, package, class,
interface, constructor, method, or field declarations. Any other position, like
in the body of a method, will be ignored by the javadoc tool and is considered
invalid by this check.
[Rule]
ExplicitInitialization
[Description]
Checks if any class or object member is explicitly initialized to
default for its type value (null for
object references, zero for numeric types and char and false for
boolean.


Rationale: Each instance variable gets initialized twice, to the
same value. Java initializes each instance variable to its default value
(0 or null) before performing any initialization specified in
the code. So there is a minor inefficiency.
[Rule]
IllegalInstantiation
[Description]
Checks for illegal instantiations where a factory method is
preferred.


Rationale: Depending on the project, for some classes it might be
preferable to create instances through factory methods rather than
calling the constructor.


A simple example is the java.lang.Boolean
class. For performance reasons, it is preferable to
use the predefined constants  TRUE and
FALSE. Constructor invocations should be
replaced by calls to Boolean.valueOf().


Some extremely performance sensitive projects may require the use of
factory methods for other classes as well, to enforce the usage of
number caches or object pools.
[Rule]
SummaryJavadoc
[Description]
Checks that

Javadoc summary sentence does not contain phrases that are not recommended to use.
Summaries that contain only the {@inheritDoc} tag are skipped. Summaries
that contain a non-empty {@code {@return}} are allowed. Check also violate Javadoc that
does not contain first sentence, though with {@code {@return}} a period is not required
as the Javadoc tool adds it.
[Rule]
JavadocVariable
[Description]
Checks that a variable has a Javadoc comment. Ignores serialVersionUID
fields.
[Rule]
VisibilityModifier
[Description]
Checks visibility of class members. Only static final, immutable or annotated
by specified annotation members may be public; other class members must be private
unless the property protectedAllowed or packageAllowed is set.


Public members are not flagged if the name matches the public
member regular expression (contains "^serialVersionUID$" by default).

Note that
Checkstyle 2 used to include "^f[A-Z][a-zA-Z0-9]*$" in the default
pattern to allow names used in container-managed persistence for Enterprise JavaBeans
(EJB) 1.1 with the default settings. With EJB 2.0 it is no longer necessary to have
public access for persistent fields, so the default has been changed.


Rationale: Enforce encapsulation.


Check also has options making it less strict:


ignoreAnnotationCanonicalNames - the list of annotations which ignore variables
in consideration. If user want to provide short annotation name that type
will match to any named the same type without consideration of package.


allowPublicFinalFields - which allows public final fields.


allowPublicImmutableFields - which allows immutable fields to be declared as
public if defined in final class.


Field is known to be immutable if:


It's declared as final

Has either a primitive type or instance of class user defined to be immutable
(such as String, ImmutableCollection from Guava, etc.)



Classes known to be immutable are listed in immutableClassCanonicalNames by their
canonical names.


Property Rationale: Forcing all fields of class to have private modifier by default is
good in most cases, but in some cases it drawbacks in too much boilerplate get/set code.
One of such cases are immutable classes.


Restriction: Check doesn't check if class is immutable, there's no
checking if accessory methods are missing and all fields are immutable, we only check
if current field is immutable or final. Under the flag
allowPublicImmutableFields, the enclosing class must also be final, to encourage
immutability. Under the flag allowPublicFinalFields, the final modifier on
the enclosing class is optional.


Star imports are out of scope of this Check. So if one of type imported via
star import collides with user specified one by its short name -
there won't be Check's violation.
[Rule]
UncommentedMain
[Description]
Detects uncommented main methods.


Rationale: A main method is often used for debugging
purposes. When debugging is finished, developers often forget
to remove the method, which changes the API and increases the
size of the resulting class or JAR file. Except for
the real program entry points, all main methods should be
removed or commented out of the sources.
[Rule]
InterfaceMemberImpliedModifier
[Description]
Checks for implicit modifiers on interface members and nested types.


This check is effectively the opposite of
RedundantModifier.
It checks the modifiers on interface members, ensuring that certain
modifiers are explicitly specified even though they are actually redundant.


Methods in interfaces are public by default, however from Java 9
they can also be private. This check provides the ability to enforce
that public is explicitly coded and not implicitly added by the compiler.


From Java 8, there are three types of methods in interfaces - static methods
marked with static, default methods marked with default and
abstract methods which do not have to be marked with anything.
From Java 9, there are also private methods marked with private.
This check provides the ability to enforce that abstract is explicitly
coded and not implicitly added by the compiler.


Fields in interfaces are always public static final and as such the
compiler does not require these modifiers. This check provides the ability to
enforce that these modifiers are explicitly coded and not implicitly added by
the compiler.


Nested types within an interface are always public static and as such the
compiler does not require the public static modifiers. This check provides
the ability to enforce that the public and static modifiers
are explicitly coded and not implicitly added by the compiler.



public interface AddressFactory {
// check enforces code contains "public static final"
public static final String UNKNOWN = "Unknown";

String OTHER = "Other";  // violation

// check enforces code contains "public" or "private"
public static AddressFactory instance();

// check enforces code contains "public abstract"
public abstract Address createAddress(String addressLine, String city);

List<Address> findAddresses(String city);  // violation

// check enforces default methods are explicitly declared "public"
public default Address createAddress(String city) {
return createAddress(UNKNOWN, city);
}

default Address createOtherAddress() {  // violation
return createAddress(OTHER, OTHER);
}
}


Rationale for this check:
Methods, fields and nested types are treated differently depending on whether
they are part of an interface or part of a class. For example, by default methods
are package-scoped on classes, but public in interfaces. However, from Java 8 onwards,
interfaces have changed to be much more like abstract classes.
Interfaces now have static and instance methods with code. Developers should not have
to remember which modifiers are required and which are implied.
This check allows the simpler alternative approach to be adopted where the
implied modifiers must always be coded explicitly.
[Rule]
AvoidInlineConditionals
[Description]
Detects inline conditionals. Here is one example of an inline conditional:



String a = getParameter("a");
String b = (a==null || a.length()<1) ? null : a.substring(1);


Rationale: Some developers find inline conditionals hard to read, so
their employer's coding standards forbid them.

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
