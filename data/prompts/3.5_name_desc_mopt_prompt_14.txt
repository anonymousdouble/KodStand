Please generate CheckStyle configurations based on the following style convention and CheckStyle rules. Ensure that the output includes only the relevant configurations for the style convention and excludes any unrelated rules.


Style Convention:
4.1.1 Use of optional braces
Braces are used with `if` , `else` , `for` , `do` and `while` statements, even when the body is empty or contains only a single statement.
 Other optional braces, such as those in a lambda expression, remain optional.

CheckStyle Rules:
[Rule]
NeedBraces
[Description]
Checks for braces around code blocks.
[Options]
allowEmptyLoopBody, Allow loops with empty bodies.
allowSingleLineStatement, Allow single-line statements without braces.
tokens, tokens to check
[Rule]
RightCurly
[Description]
Checks the placement of right curly braces ('}') for code blocks.
This check supports if-else, try-catch-finally blocks, switch statements, switch cases,
while-loops, for-loops, method definitions, class definitions, constructor definitions,
instance, static initialization blocks, annotation definitions and enum definitions.
For right curly brace of expression blocks of arrays, lambdas and class instances
please follow issue
#5945.
For right curly brace of enum constant please follow issue
#7519.
[Options]
option, Specify the policy on placement of a right curly brace ('}').
tokens, tokens to check
[Rule]
AvoidDoubleBraceInitialization
[Description]
Detects double brace initialization.


Rationale: Double brace initialization (set of

Instance Initializers in class body) may look cool,
but it is considered as anti-pattern and should be avoided.
This is also can lead to a hard-to-detect memory leak, if the anonymous class instance is
returned outside and other object(s) hold reference to it.
Created anonymous class is not static, it holds an implicit reference to the outer class
instance.
See this

blog post and

article for more details.
Check ignores any comments and semicolons in class body.
[Options]
[Rule]
UnnecessaryParentheses
[Description]
Checks if unnecessary parentheses are used in a statement or expression.
The check will flag the following with warnings:



return (x);          // parens around identifier
return (x + 1);      // parens around return value
int x = (y / 2 + 1); // parens around assignment rhs
for (int i = (0); i < 10; i++) {  // parens around literal
t -= (z + 1);                     // parens around assignment rhs
boolean a = (x > 7 && y > 5)      // parens around expression
|| z < 9;
boolean b = (~a) > -27            // parens around ~a
&& (a-- < 30);        // parens around expression
[Options]
tokens, tokens to check
[Rule]
Indentation
[Description]
Checks correct indentation of Java code.


The idea behind this is that while pretty printers are
sometimes convenient for bulk reformats of legacy code, they often
either aren't configurable enough or just can't anticipate how
format should be done. Sometimes this is personal preference, other
times it is practical experience. In any case, this check should
just ensure that a minimal set of indentation rules is followed.


Basic offset indentation is used for indentation inside code blocks.
For any lines that span more than 1, line wrapping indentation is used for those
lines after the first.
Brace adjustment, case, and throws indentations are all used only if those specific
identifiers start the line. If, for example, a brace is used in the middle of the line,
its indentation will not take effect.
All indentations have an accumulative/recursive effect when they are triggered. If
during a line wrapping, another code block is found and it doesn't end on that same
line, then the subsequent lines afterwards, in that new code block, are increased on
top of the line wrap and any indentations above it.

Example:


if ((condition1 && condition2)
|| (condition3 && condition4)    // line wrap with bigger indentation
||!(condition5 && condition6)) { // line wrap with bigger indentation
field.doSomething()                    // basic offset
.doSomething()                     // line wrap
.doSomething( c -> {               // line wrap
return c.doSome();               // basic offset
});
}
[Options]
arrayInitIndent, Specify how far an array initialization should be indented when on next line.
basicOffset, Specify how far new indentation level should be indented when on the next line.
braceAdjustment, Specify how far a braces should be indented when on the next line.
caseIndent, Specify how far a case label should be indented when on next line.
forceStrictCondition, Force strict indent level in line wrapping case. If value is true, line wrap indent have to be same as lineWrappingIndentation parameter. If value is false, line wrap indent could be bigger on any value user would like.
lineWrappingIndentation, Specify how far continuation line should be indented when line-wrapping is present.
throwsIndent, Specify how far a throws clause should be indented when on next line.
[Rule]
LeftCurly
[Description]
Checks for the placement of left curly braces
('{') for code blocks.
[Options]
ignoreEnums, Allow to ignore enums when left curly brace policy is EOL.
option, Specify the policy on placement of a left curly brace ('{').
tokens, tokens to check
[Rule]
AvoidInlineConditionals
[Description]
Detects inline conditionals. Here is one example of an inline conditional:



String a = getParameter("a");
String b = (a==null || a.length()<1) ? null : a.substring(1);


Rationale: Some developers find inline conditionals hard to read, so
their employer's coding standards forbid them.
[Options]
[Rule]
AvoidNestedBlocks
[Description]
Finds nested blocks (blocks that are used freely in the code).


Rationale: Nested blocks are often leftovers from the
debugging process, they confuse the reader.


For example, this check finds the obsolete braces in



public void guessTheOutput()
{
int whichIsWhich = 0;
{
whichIsWhich = 2;
}
System.out.println("value = " + whichIsWhich);
}

and debugging / refactoring leftovers such as


// if (conditionThatIsNotUsedAnyLonger)
{
System.out.println("unconditional");
}


A case in a switch statement does not implicitly form a block.
Thus, to be able to introduce local variables that have case
scope it is necessary to open a nested block. This is
supported, set the allowInSwitchCase property to true and
include all statements of the case in the block.
[Options]
allowInSwitchCase, Allow nested blocks if they are the only child of a switch case.
[Rule]
EmptyStatement
[Description]
Detects empty statements (standalone ";" semicolon).
Empty statements often introduce bugs that are hard to spot
[Options]
[Rule]
WhitespaceAround
[Description]
Checks that a token is surrounded by whitespace. Empty constructor,
method, class, enum, interface, loop bodies (blocks), lambdas of the form


public MyClass() {}      // empty constructor
public void func() {}    // empty method
public interface Foo {} // empty interface
public class Foo {} // empty class
public enum Foo {} // empty enum
MyClass c = new MyClass() {}; // empty anonymous class
while (i = 1) {} // empty while loop
for (int i = 1; i > 1; i++) {} // empty for loop
do {} while (i = 1); // empty do-while loop
Runnable noop = () -> {}; // empty lambda
public @interface Beta {} // empty annotation type


may optionally be exempted from the policy using the
allowEmptyMethods, allowEmptyConstructors,
allowEmptyTypes, allowEmptyLoops,
allowEmptyLambdas and allowEmptyCatches
properties.

This check does not flag as violation double brace initialization like:



new Properties() {{
setProperty("key", "value");
}};


Parameter allowEmptyCatches allows to suppress violations when token
list contains SLIST to check if beginning of block is surrounded by
whitespace and catch block is empty, for example:



try {
k = 5 / i;
} catch (ArithmeticException ex) {}



With this property turned off, this raises violation because the beginning of the
catch block (left curly bracket) is not separated from the end of the catch
block (right curly bracket).
[Options]
allowEmptyCatches, Allow empty catch bodies.
allowEmptyConstructors, Allow empty constructor bodies.
allowEmptyLambdas, Allow empty lambda bodies.
allowEmptyLoops, Allow empty loop bodies.
allowEmptyMethods, Allow empty method bodies.
allowEmptyTypes, Allow empty class, interface and enum bodies.
ignoreEnhancedForColon, Ignore whitespace around colon in
enhanced for loop.
tokens, tokens to check

Response Format Should be a json object:
{
    "Answer":  Respond with either Yes or No to show whether CheckStyle configurations exist for the given style convention,
    "Configuration": If the answer is Yes, provide the configuration. There can be one or multiple CheckStyle rules for the given style convention. The configuration format should be xml format:
    "<module name='rule_name_1'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_n' value='value_n'/>
    </module>
    ...
    <module name='rule_name_x'>
        <property name='id' value='id_value_1'/>
        <property name='name_1' value='value_1'/>
        <property name='name_2' value='value_2'/>
        ...
        <property name='name_m' value='value_m'/>
    </module>"
}
